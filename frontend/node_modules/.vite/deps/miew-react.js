import {
  CssBaseline_default,
  Provider_default,
  applyMiddleware,
  combineReducers,
  compose,
  createStore,
  createTheme_default,
  es_default
} from "./chunk-RRUO65NX.js";
import {
  Emotion$1,
  ThemeProvider,
  _extends,
  createEmotionProps,
  hasOwn,
  init_emotion_cache_browser_development_esm,
  init_emotion_element_489459f2_browser_development_esm,
  init_emotion_react_browser_development_esm,
  init_emotion_react_isolated_hnrs_browser_development_esm,
  init_emotion_serialize_development_esm,
  init_emotion_use_insertion_effect_with_fallbacks_browser_esm,
  init_emotion_utils_browser_esm,
  init_emotion_weak_memoize_esm,
  init_extends,
  require_hoist_non_react_statics_cjs
} from "./chunk-QW3AL77I.js";
import {
  require_jsx_runtime
} from "./chunk-YPGNGA4Z.js";
import {
  require_regenerator
} from "./chunk-T3EA7QLL.js";
import {
  _defineProperty,
  _objectWithoutPropertiesLoose
} from "./chunk-5BNGF3BS.js";
import "./chunk-6W5FFVKH.js";
import {
  require_lodash
} from "./chunk-DDZZXKO5.js";
import {
  require_react
} from "./chunk-NKBGLYTV.js";
import {
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/@emotion/react/jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js
var ReactJSXRuntime = __toESM(require_jsx_runtime());
init_emotion_element_489459f2_browser_development_esm();
var import_react = __toESM(require_react());
init_emotion_cache_browser_development_esm();
init_extends();
init_emotion_weak_memoize_esm();
init_emotion_react_isolated_hnrs_browser_development_esm();
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
init_emotion_utils_browser_esm();
init_emotion_serialize_development_esm();
init_emotion_use_insertion_effect_with_fallbacks_browser_esm();
var jsx2 = function jsx3(type, props, key) {
  if (!hasOwn.call(props, "css")) {
    return ReactJSXRuntime.jsx(type, props, key);
  }
  return ReactJSXRuntime.jsx(Emotion$1, createEmotionProps(type, props), key);
};
var jsxs2 = function jsxs3(type, props, key) {
  if (!hasOwn.call(props, "css")) {
    return ReactJSXRuntime.jsxs(type, props, key);
  }
  return ReactJSXRuntime.jsxs(Emotion$1, createEmotionProps(type, props), key);
};

// node_modules/miew-react/dist/index.modern.js
var import_react3 = __toESM(require_react());

// node_modules/miew/dist/miew.module.js
var import_lodash = __toESM(require_lodash());

// node_modules/three/build/three.module.js
var REVISION = "131";
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var GLSL3 = "300 es";
var EventDispatcher = class {
  addEventListener(type, listener2) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener2) === -1) {
      listeners[type].push(listener2);
    }
  }
  hasEventListener(type, listener2) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener2) !== -1;
  }
  removeEventListener(type, listener2) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener2);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array4 = listenerArray.slice(0);
      for (let i2 = 0, l2 = array4.length; i2 < l2; i2++) {
        array4[i2].call(this, event);
      }
      event.target = null;
    }
  }
};
var _lut = [];
for (let i2 = 0; i2 < 256; i2++) {
  _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
}
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function mapLinear(x2, a1, a2, b1, b2) {
  return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x2, y2, value) {
  if (x2 !== y2) {
    return (value - x2) / (y2 - x2);
  } else {
    return 0;
  }
}
function lerp(x2, y2, t2) {
  return (1 - t2) * x2 + t2 * y2;
}
function damp(x2, y2, lambda, dt) {
  return lerp(x2, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x2, length = 1) {
  return length - Math.abs(euclideanModulo(x2, length * 2) - length);
}
function smoothstep(x2, min, max) {
  if (x2 <= min) return 0;
  if (x2 >= max) return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * (3 - 2 * x2);
}
function smootherstep(x2, min, max) {
  if (x2 <= min) return 0;
  if (x2 >= max) return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0) _seed = s2 % 2147483647;
  _seed = _seed * 16807 % 2147483647;
  return (_seed - 1) / 2147483646;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q2, a2, b2, c2, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b2 / 2);
  const s2 = sin(b2 / 2);
  const c13 = cos((a2 + c2) / 2);
  const s13 = sin((a2 + c2) / 2);
  const c1_3 = cos((a2 - c2) / 2);
  const s1_3 = sin((a2 - c2) / 2);
  const c3_1 = cos((c2 - a2) / 2);
  const s3_1 = sin((c2 - a2) / 2);
  switch (order) {
    case "XYX":
      q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
var MathUtils = Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler
});
var Vector2 = class {
  constructor(x2 = 0, y2 = 0) {
    this.x = x2;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array4, offset = 0) {
    this.x = array4[offset];
    this.y = array4[offset + 1];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.x;
    array4[offset + 1] = this.y;
    return array4;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const x2 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x2 * c2 - y2 * s2 + center.x;
    this.y = x2 * s2 + y2 * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
};
Vector2.prototype.isVector2 = true;
var Matrix3 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me = m2.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a2 = te[0], b2 = te[1], c2 = te[2], d2 = te[3], e2 = te[4], f2 = te[5], g2 = te[6], h2 = te[7], i2 = te[8];
    return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix42) {
    return this.setFromMatrix4(matrix42).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(
      sx * c2,
      sx * s2,
      -sx * (c2 * cx + s2 * cy) + cx + tx,
      -sy * s2,
      sy * c2,
      -sy * (-s2 * cx + c2 * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c2 * a11 + s2 * a21;
    te[3] = c2 * a12 + s2 * a22;
    te[6] = c2 * a13 + s2 * a23;
    te[1] = -s2 * a11 + c2 * a21;
    te[4] = -s2 * a12 + c2 * a22;
    te[7] = -s2 * a13 + c2 * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te[i2] !== me[i2]) return false;
    }
    return true;
  }
  fromArray(array4, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array4[i2 + offset];
    }
    return this;
  }
  toArray(array4 = [], offset = 0) {
    const te = this.elements;
    array4[offset] = te[0];
    array4[offset + 1] = te[1];
    array4[offset + 2] = te[2];
    array4[offset + 3] = te[3];
    array4[offset + 4] = te[4];
    array4[offset + 5] = te[5];
    array4[offset + 6] = te[6];
    array4[offset + 7] = te[7];
    array4[offset + 8] = te[8];
    return array4;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
Matrix3.prototype.isMatrix3 = true;
var _canvas;
var ImageUtils = class {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
var textureId = 0;
var Texture = class _Texture extends EventDispatcher {
  constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i2 = 0, l2 = image.length; i2 < l2; i2++) {
            if (image[i2].isDataTexture) {
              url.push(serializeImage(image[i2].image));
            } else {
              url.push(serializeImage(image[i2]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
};
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var Vector4 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x2, y2, z2, w2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w2;
    this.w = e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15] * w2;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x2, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x2 = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y2 = xy / x2;
          z2 = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x2 = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x2 = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x2, y2, z2, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3) s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array4, offset = 0) {
    this.x = array4[offset];
    this.y = array4[offset + 1];
    this.z = array4[offset + 2];
    this.w = array4[offset + 3];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.x;
    array4[offset + 1] = this.y;
    array4[offset + 2] = this.z;
    array4[offset + 3] = this.w;
    return array4;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
};
Vector4.prototype.isVector4 = true;
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options2 = {}) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    this.texture = new Texture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.image = { width, height, depth: 1 };
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
    this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : false;
    this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.image = { ...this.texture.image };
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
  constructor(width, height, count) {
    super(width, height);
    const texture = this.texture;
    this.texture = [];
    for (let i2 = 0; i2 < count; i2++) {
      this.texture[i2] = texture.clone();
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
        this.texture[i2].image.width = width;
        this.texture[i2].image.height = height;
        this.texture[i2].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }
  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    this.texture.length = 0;
    for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
      this.texture[i2] = source.texture[i2].clone();
    }
    return this;
  }
};
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options2) {
    super(width, height, options2);
    this.samples = 4;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
};
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
var Quaternion = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
  }
  static slerp(qa, qb, qm, t2) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm.slerpQuaternions(qa, qb, t2);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, w2) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion2) {
    this._x = quaternion2.x;
    this._y = quaternion2.y;
    this._z = quaternion2.z;
    this._w = quaternion2.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x2 / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x2 / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0) return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q2, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2, p2) {
    if (p2 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q2, p2);
    }
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a2, b2) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t2) {
    if (t2 === 0) return this;
    if (t2 === 1) return this.copy(qb);
    const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w2 + t2 * this._w;
      this._x = s2 * x2 + t2 * this._x;
      this._y = s2 * y2 + t2 * this._y;
      this._z = s2 * z2 + t2 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t2) {
    this.copy(qa).slerp(qb, t2);
  }
  equals(quaternion2) {
    return quaternion2._x === this._x && quaternion2._y === this._y && quaternion2._z === this._z && quaternion2._w === this._w;
  }
  fromArray(array4, offset = 0) {
    this._x = array4[offset];
    this._y = array4[offset + 1];
    this._z = array4[offset + 2];
    this._w = array4[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this._x;
    array4[offset + 1] = this._y;
    array4[offset + 2] = this._z;
    array4[offset + 3] = this._w;
    return array4;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Quaternion.prototype.isQuaternion = true;
var Vector3 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(x2, y2, z2) {
    if (z2 === void 0) z2 = this.z;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  }
  multiply(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v2, w2);
    }
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6] * z2;
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7] * z2;
    this.z = e2[2] * x2 + e2[5] * y2 + e2[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    const w2 = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12]) * w2;
    this.y = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13]) * w2;
    this.z = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14]) * w2;
    return this;
  }
  applyQuaternion(q2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const ix = qw * x2 + qy * z2 - qz * y2;
    const iy = qw * y2 + qz * x2 - qx * z2;
    const iz = qw * z2 + qx * y2 - qy * x2;
    const iw = -qx * x2 - qy * y2 - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v2, w2);
    }
    return this.crossVectors(this, v2);
  }
  crossVectors(a2, b2) {
    const ax = a2.x, ay = a2.y, az = a2.z;
    const bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array4, offset = 0) {
    this.x = array4[offset];
    this.y = array4[offset + 1];
    this.z = array4[offset + 2];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.x;
    array4[offset + 1] = this.y;
    array4[offset + 2] = this.z;
    return array4;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
};
Vector3.prototype.isVector3 = true;
var _vector$c = new Vector3();
var _quaternion$4 = new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array4) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = array4.length; i2 < l2; i2 += 3) {
      const x2 = array4[i2];
      const y2 = array4[i2 + 1];
      const z2 = array4[i2 + 2];
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (z2 < minZ) minZ = z2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY) maxY = y2;
      if (z2 > maxZ) maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
      const x2 = attribute.getX(i2);
      const y2 = attribute.getY(i2);
      const z2 = attribute.getZ(i2);
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (z2 < minZ) minZ = z2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY) maxY = y2;
      if (z2 > maxZ) maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object4) {
    this.makeEmpty();
    return this.expandByObject(object4);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object4) {
    object4.updateWorldMatrix(false, false);
    const geometry = object4.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box$3.copy(geometry.boundingBox);
      _box$3.applyMatrix4(object4.matrixWorld);
      this.union(_box$3);
    }
    const children = object4.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box3.prototype.isBox3 = true;
var _points = [
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3()
];
var _vector$b = new Vector3();
var _box$3 = new Box3();
var _v0$2 = new Vector3();
var _v1$7 = new Vector3();
var _v2$3 = new Vector3();
var _f0 = new Vector3();
var _f1 = new Vector3();
var _f2 = new Vector3();
var _center = new Vector3();
var _extents = new Vector3();
var _triangleNormal = new Vector3();
var _testAxis = new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
var _box$2 = new Box3();
var _v1$6 = new Vector3();
var _toFarthestPoint = new Vector3();
var _toPoint = new Vector3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$a = new Vector3();
var _segCenter = new Vector3();
var _segDir = new Vector3();
var _diff = new Vector3();
var _edge1 = new Vector3();
var _edge2 = new Vector3();
var _normal$1 = new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction2 = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction2;
  }
  set(origin, direction2) {
    this.origin.copy(origin);
    this.direction.copy(direction2);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a2, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a2);
    _edge2.subVectors(c2, a2);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix42) {
    this.origin.applyMatrix4(matrix42);
    this.direction.transformDirection(matrix42);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class _Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new _Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m2) {
    const te = this.elements, me = m2.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me = m2.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m2) {
    const te = this.elements;
    const me = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x2 = euler.x, y2 = euler.y, z2 = euler.z;
    const a2 = Math.cos(x2), b2 = Math.sin(x2);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = -c2 * f2;
      te[8] = d2;
      te[1] = af + be * d2;
      te[5] = ae - bf * d2;
      te[9] = -b2 * c2;
      te[2] = bf - ae * d2;
      te[6] = be + af * d2;
      te[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce + df * b2;
      te[4] = de * b2 - cf;
      te[8] = a2 * d2;
      te[1] = a2 * f2;
      te[5] = a2 * e2;
      te[9] = -b2;
      te[2] = cf * b2 - de;
      te[6] = df + ce * b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce - df * b2;
      te[4] = -a2 * f2;
      te[8] = de + cf * b2;
      te[1] = cf + de * b2;
      te[5] = a2 * e2;
      te[9] = df - ce * b2;
      te[2] = -a2 * d2;
      te[6] = b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = be * d2 - af;
      te[8] = ae * d2 + bf;
      te[1] = c2 * f2;
      te[5] = bf * d2 + ae;
      te[9] = af * d2 - be;
      te[2] = -d2;
      te[6] = b2 * c2;
      te[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = bd - ac * f2;
      te[8] = bc * f2 + ad;
      te[1] = f2;
      te[5] = a2 * e2;
      te[9] = -b2 * e2;
      te[2] = -d2 * e2;
      te[6] = ad * f2 + bc;
      te[10] = ac - bd * f2;
    } else if (euler.order === "XZY") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = -f2;
      te[8] = d2 * e2;
      te[1] = ac * f2 + bd;
      te[5] = a2 * e2;
      te[9] = ad * f2 - bc;
      te[2] = bc * f2 - ad;
      te[6] = b2 * e2;
      te[10] = bd * f2 + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m2, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n2);
    }
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x2, y2, z2) {
    const te = this.elements;
    if (x2.isVector3) {
      te[12] = x2.x;
      te[13] = x2.y;
      te[14] = x2.z;
    } else {
      te[12] = x2;
      te[13] = y2;
      te[14] = z2;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te = this.elements;
    const x2 = v2.x, y2 = v2.y, z2 = v2.z;
    te[0] *= x2;
    te[4] *= y2;
    te[8] *= z2;
    te[1] *= x2;
    te[5] *= y2;
    te[9] *= z2;
    te[2] *= x2;
    te[6] *= y2;
    te[10] *= z2;
    te[3] *= x2;
    te[7] *= y2;
    te[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x2, y2, z2) {
    this.set(
      1,
      0,
      0,
      x2,
      0,
      1,
      0,
      y2,
      0,
      0,
      1,
      z2,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c2,
      -s2,
      0,
      0,
      s2,
      c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c2,
      0,
      s2,
      0,
      0,
      1,
      0,
      0,
      -s2,
      0,
      c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c2,
      -s2,
      0,
      0,
      s2,
      c2,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x2 = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t2 * x2, ty = t2 * y2;
    this.set(
      tx * x2 + c2,
      tx * y2 - s2 * z2,
      tx * z2 + s2 * y2,
      0,
      tx * y2 + s2 * z2,
      ty * y2 + c2,
      ty * z2 - s2 * x2,
      0,
      tx * z2 - s2 * y2,
      ty * z2 + s2 * x2,
      t2 * z2 * z2 + c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x2, y2, z2) {
    this.set(
      x2,
      0,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      0,
      z2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion2, scale) {
    const te = this.elements;
    const x2 = quaternion2._x, y2 = quaternion2._y, z2 = quaternion2._z, w2 = quaternion2._w;
    const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion2, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion2.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x2 = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b2 = (top + bottom) / (top - bottom);
    const c2 = -(far + near) / (far - near);
    const d2 = -2 * far * near / (far - near);
    te[0] = x2;
    te[4] = 0;
    te[8] = a2;
    te[12] = 0;
    te[1] = 0;
    te[5] = y2;
    te[9] = b2;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w2 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x2 = (right + left) * w2;
    const y2 = (top + bottom) * h2;
    const z2 = (far + near) * p2;
    te[0] = 2 * w2;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x2;
    te[1] = 0;
    te[5] = 2 * h2;
    te[9] = 0;
    te[13] = -y2;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p2;
    te[14] = -z2;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te[i2] !== me[i2]) return false;
    }
    return true;
  }
  fromArray(array4, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array4[i2 + offset];
    }
    return this;
  }
  toArray(array4 = [], offset = 0) {
    const te = this.elements;
    array4[offset] = te[0];
    array4[offset + 1] = te[1];
    array4[offset + 2] = te[2];
    array4[offset + 3] = te[3];
    array4[offset + 4] = te[4];
    array4[offset + 5] = te[5];
    array4[offset + 6] = te[6];
    array4[offset + 7] = te[7];
    array4[offset + 8] = te[8];
    array4[offset + 9] = te[9];
    array4[offset + 10] = te[10];
    array4[offset + 11] = te[11];
    array4[offset + 12] = te[12];
    array4[offset + 13] = te[13];
    array4[offset + 14] = te[14];
    array4[offset + 15] = te[15];
    return array4;
  }
};
Matrix4.prototype.isMatrix4 = true;
var _v1$5 = new Vector3();
var _m1$2 = new Matrix4();
var _zero = new Vector3(0, 0, 0);
var _one = new Vector3(1, 1, 1);
var _x = new Vector3();
var _y = new Vector3();
var _z = new Vector3();
var _matrix$1 = new Matrix4();
var _quaternion$3 = new Quaternion();
var Euler = class _Euler {
  constructor(x2 = 0, y2 = 0, z2 = 0, order = _Euler.DefaultOrder) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, order = this._order) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order = this._order, update = true) {
    const te = m2.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update) {
    _matrix$1.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v2, order = this._order) {
    return this.set(v2.x, v2.y, v2.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array4) {
    this._x = array4[0];
    this._y = array4[1];
    this._z = array4[2];
    if (array4[3] !== void 0) this._order = array4[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this._x;
    array4[offset + 1] = this._y;
    array4[offset + 2] = this._z;
    array4[offset + 3] = this._order;
    return array4;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel4) {
    this.mask = 1 << channel4 | 0;
  }
  enable(channel4) {
    this.mask |= 1 << channel4 | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel4) {
    this.mask ^= 1 << channel4 | 0;
  }
  disable(channel4) {
    this.mask &= ~(1 << channel4 | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix4();
var _target = new Vector3();
var _position$3 = new Vector3();
var _scale$2 = new Vector3();
var _quaternion$2 = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Object3D = class _Object3D extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = _Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion2 = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion2.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion2, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion2._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion2
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = _Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q2) {
    this.quaternion.premultiply(q2);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  setRotationFromQuaternion(q2) {
    this.quaternion.copy(q2);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x2, y2, z2) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object4) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object4 === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object4);
      return this;
    }
    if (object4 && object4.isObject3D) {
      if (object4.parent !== null) {
        object4.parent.remove(object4);
      }
      object4.parent = this;
      this.children.push(object4);
      object4.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object4);
    }
    return this;
  }
  remove(object4) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object4);
    if (index !== -1) {
      object4.parent = null;
      this.children.splice(index, 1);
      object4.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object4 = this.children[i2];
      object4.parent = null;
      object4.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object4) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object4.parent !== null) {
      object4.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object4.parent.matrixWorld);
    }
    object4.applyMatrix4(_m1$1);
    this.add(object4);
    object4.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name2) {
    return this.getObjectByProperty("name", name2);
  }
  getObjectByProperty(name2, value) {
    if (this[name2] === value) return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object4 = child.getObjectByProperty(name2, value);
      if (object4 !== void 0) {
        return object4;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object4 = {};
    object4.uuid = this.uuid;
    object4.type = this.type;
    if (this.name !== "") object4.name = this.name;
    if (this.castShadow === true) object4.castShadow = true;
    if (this.receiveShadow === true) object4.receiveShadow = true;
    if (this.visible === false) object4.visible = false;
    if (this.frustumCulled === false) object4.frustumCulled = false;
    if (this.renderOrder !== 0) object4.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}") object4.userData = this.userData;
    object4.layers = this.layers.mask;
    object4.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object4.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object4.type = "InstancedMesh";
      object4.count = this.count;
      object4.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object4.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object4.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object4.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture) {
        object4.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object4.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object4.bindMode = this.bindMode;
      object4.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object4.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object4.material = uuids;
      } else {
        object4.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object4.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object4.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object4.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object4.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries2 = extractFromCache(meta.geometries);
      const materials2 = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries2.length > 0) output.geometries = geometries2;
      if (materials2.length > 0) output.materials = materials2;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
    }
    output.object = object4;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
var _v0$1 = new Vector3();
var _v1$3 = new Vector3();
var _v2$2 = new Vector3();
var _v3$1 = new Vector3();
var _vab = new Vector3();
var _vac = new Vector3();
var _vbc = new Vector3();
var _vap = new Vector3();
var _vbp = new Vector3();
var _vcp = new Vector3();
var Triangle = class _Triangle {
  constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
  }
  static getNormal(a2, b2, c2, target) {
    target.subVectors(c2, b2);
    _v0$1.subVectors(a2, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a2, b2, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b2, a2);
    _v2$2.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point, a2, b2, c2) {
    this.getBarycoord(point, a2, b2, c2, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a2, b2, c2, direction2) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a2, b2);
    return _v0$1.cross(_v1$3).dot(direction2) < 0 ? true : false;
  }
  set(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return _Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return _Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return _Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return _Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction2) {
    return _Triangle.isFrontFacing(this.a, this.b, this.c, direction2);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p2, target) {
    const a2 = this.a, b2 = this.b, c2 = this.c;
    let v2, w2;
    _vab.subVectors(b2, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w2);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va + vb + vc);
    v2 = vb * denom;
    w2 = vc * denom;
    return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
var Material = class extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
  }
  onBuild() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularTint && this.specularTint.isColor) data.specularTint = this.specularTint.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularTintMap && this.specularTintMap.isTexture) data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationTint !== void 0) data.attenuationTint = this.attenuationTint.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}") data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
};
Material.prototype.isMaterial = true;
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2) return q2;
  if (t2 < 2 / 3) return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
  return p2;
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
var Color = class {
  constructor(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      return this.set(r2);
    }
    return this.setRGB(r2, g2, b2);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r2, g2, b2) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    return this;
  }
  setHSL(h2, s2, l2) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp(s2, 0, 1);
    l2 = clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q2 = 2 * l2 - p2;
      this.r = hue2rgb(q2, p2, h2 + 1 / 3);
      this.g = hue2rgb(q2, p2, h2);
      this.b = hue2rgb(q2, p2, h2 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string5) {
      if (string5 === void 0) return;
      if (parseFloat(string5) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color2;
      const name2 = m2[1];
      const components = m2[2];
      switch (name2) {
        case "rgb":
        case "rgba":
          if (color2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color2[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color2[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color2[3], 10)) / 255;
            handleAlpha(color2[4]);
            return this;
          }
          if (color2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color2[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color2[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color2[3], 10)) / 100;
            handleAlpha(color2[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h2 = parseFloat(color2[1]) / 360;
            const s2 = parseInt(color2[2], 10) / 100;
            const l2 = parseInt(color2[3], 10) / 100;
            handleAlpha(color2[4]);
            return this.setHSL(h2, s2, l2);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  copyGammaToLinear(color2, gammaFactor = 2) {
    this.r = Math.pow(color2.r, gammaFactor);
    this.g = Math.pow(color2.g, gammaFactor);
    this.b = Math.pow(color2.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color2, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color2.r, safeInverse);
    this.g = Math.pow(color2.g, safeInverse);
    this.b = Math.pow(color2.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear(color2.r);
    this.g = SRGBToLinear(color2.g);
    this.b = SRGBToLinear(color2.b);
    return this;
  }
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB(color2.r);
    this.g = LinearToSRGB(color2.g);
    this.b = LinearToSRGB(color2.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l2;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color2, alpha) {
    this.r += (color2.r - this.r) * alpha;
    this.g += (color2.g - this.g) * alpha;
    this.b += (color2.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color2, alpha) {
    this.getHSL(_hslA);
    color2.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array4, offset = 0) {
    this.r = array4[offset];
    this.g = array4[offset + 1];
    this.b = array4[offset + 2];
    return this;
  }
  toArray(array4 = [], offset = 0) {
    array4[offset] = this.r;
    array4[offset + 1] = this.g;
    array4[offset + 2] = this.b;
    return array4;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
};
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
var _vector$9 = new Vector3();
var _vector2$1 = new Vector2();
var BufferAttribute = class {
  constructor(array4, itemSize, normalized) {
    if (Array.isArray(array4)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array4;
    this.itemSize = itemSize;
    this.count = array4 !== void 0 ? array4.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  copyArray(array4) {
    this.array.set(array4);
    return this;
  }
  copyColorsArray(colors) {
    const array4 = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = colors.length; i2 < l2; i2++) {
      let color2 = colors[i2];
      if (color2 === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color2 = new Color();
      }
      array4[offset++] = color2.r;
      array4[offset++] = color2.g;
      array4[offset++] = color2.b;
    }
    return this;
  }
  copyVector2sArray(vectors2) {
    const array4 = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors2.length; i2 < l2; i2++) {
      let vector = vectors2[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array4[offset++] = vector.x;
      array4[offset++] = vector.y;
    }
    return this;
  }
  copyVector3sArray(vectors2) {
    const array4 = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors2.length; i2 < l2; i2++) {
      let vector = vectors2[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array4[offset++] = vector.x;
      array4[offset++] = vector.y;
      array4[offset++] = vector.z;
    }
    return this;
  }
  copyVector4sArray(vectors2) {
    const array4 = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors2.length; i2 < l2; i2++) {
      let vector = vectors2[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array4[offset++] = vector.x;
      array4[offset++] = vector.y;
      array4[offset++] = vector.z;
      array4[offset++] = vector.w;
    }
    return this;
  }
  applyMatrix3(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyMatrix4(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.transformDirection(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x2) {
    this.array[index * this.itemSize] = x2;
    return this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y2) {
    this.array[index * this.itemSize + 1] = y2;
    return this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z2) {
    this.array[index * this.itemSize + 2] = z2;
    return this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w2) {
    this.array[index * this.itemSize + 3] = w2;
    return this;
  }
  setXY(index, x2, y2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    this.array[index + 3] = w2;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
    return data;
  }
};
BufferAttribute.prototype.isBufferAttribute = true;
var Uint16BufferAttribute = class extends BufferAttribute {
  constructor(array4, itemSize, normalized) {
    super(new Uint16Array(array4), itemSize, normalized);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute {
  constructor(array4, itemSize, normalized) {
    super(new Uint32Array(array4), itemSize, normalized);
  }
};
var Float16BufferAttribute = class extends BufferAttribute {
  constructor(array4, itemSize, normalized) {
    super(new Uint16Array(array4), itemSize, normalized);
  }
};
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
var Float32BufferAttribute = class extends BufferAttribute {
  constructor(array4, itemSize, normalized) {
    super(new Float32Array(array4), itemSize, normalized);
  }
};
function arrayMax(array4) {
  if (array4.length === 0) return -Infinity;
  let max = array4[0];
  for (let i2 = 1, l2 = array4.length; i2 < l2; ++i2) {
    if (array4[i2] > max) max = array4[i2];
  }
  return max;
}
var _id = 0;
var _m1 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$1 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$8 = new Vector3();
var BufferGeometry = class _BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _id++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name2) {
    return this.attributes[name2];
  }
  setAttribute(name2, attribute) {
    this.attributes[name2] = attribute;
    return this;
  }
  deleteAttribute(name2) {
    delete this.attributes[name2];
    return this;
  }
  hasAttribute(name2) {
    return this.attributes[name2] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q2) {
    _m1.makeRotationFromQuaternion(q2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x2, y2, z2) {
    _m1.makeTranslation(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x2, y2, z2) {
    _m1.makeScale(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      const point = points[i2];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
            _vector$8.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j2);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeFaceNormals() {
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b2, c2) {
      vA.fromArray(positions, a2 * 3);
      vB.fromArray(positions, b2 * 3);
      vC.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a2 * 2);
      uvB.fromArray(uvs, b2 * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b2].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups2 = this.groups;
    if (groups2.length === 0) {
      groups2 = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il = groups2.length; i2 < il; ++i2) {
      const group = groups2[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleTriangle(
          indices[j2 + 0],
          indices[j2 + 1],
          indices[j2 + 2]
        );
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromArray(normals, v2 * 3);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp2.copy(t2);
      tmp2.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp22.crossVectors(n22, t2);
      const test = tmp22.dot(tan2[v2]);
      const w2 = test < 0 ? -1 : 1;
      tangents[v2 * 4] = tmp2.x;
      tangents[v2 * 4 + 1] = tmp2.y;
      tangents[v2 * 4 + 2] = tmp2.z;
      tangents[v2 * 4 + 3] = w2;
    }
    for (let i2 = 0, il = groups2.length; i2 < il; ++i2) {
      const group = groups2[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleVertex(indices[j2 + 0]);
        handleVertex(indices[j2 + 1]);
        handleVertex(indices[j2 + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      );
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0) continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i2 = 0, j2 = attributeOffset; i2 < length; i2++, j2++) {
        attributeArray1[j2] = attributeArray2[i2];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array4 = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array22 = new array4.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j2 = 0; j2 < itemSize; j2++) {
          array22[index2++] = array4[index++];
        }
      }
      return new BufferAttribute(array22, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new _BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name2, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name2 in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name2];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name2] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups2 = this.groups;
    for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
      const group = groups2[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array4 = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        array4.push(attribute.toJSON(data.data));
      }
      if (array4.length > 0) {
        morphAttributes[key] = array4;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups2 = this.groups;
    if (groups2.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups2));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new _BufferGeometry().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      this.setAttribute(name2, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name2 in morphAttributes) {
      const array4 = [];
      const morphAttribute = morphAttributes[name2];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array4.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name2] = array4;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups2 = source.groups;
    for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
      const group = groups2[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
BufferGeometry.prototype.isBufferGeometry = true;
var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var _sphere$3 = new Sphere();
var _vA$1 = new Vector3();
var _vB$1 = new Vector3();
var _vC$1 = new Vector3();
var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();
var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();
var _uvA$1 = new Vector2();
var _uvB$1 = new Vector2();
var _uvC$1 = new Vector2();
var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();
var Mesh = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material2 = new MeshBasicMaterial()) {
    super();
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material2;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material2 = this.material;
    const matrixWorld = this.matrixWorld;
    if (material2 === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups2 = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material2)) {
          for (let i2 = 0, il = groups2.length; i2 < il; i2++) {
            const group = groups2[i2];
            const groupMaterial = material2[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = index.getX(j2);
              const b2 = index.getX(j2 + 1);
              const c2 = index.getX(j2 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = index.getX(i2);
            const b2 = index.getX(i2 + 1);
            const c2 = index.getX(i2 + 2);
            intersection = checkBufferGeometryIntersection(this, material2, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material2)) {
          for (let i2 = 0, il = groups2.length; i2 < il; i2++) {
            const group = groups2[i2];
            const groupMaterial = material2[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = j2;
              const b2 = j2 + 1;
              const c2 = j2 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = i2;
            const b2 = i2 + 1;
            const c2 = i2 + 2;
            intersection = checkBufferGeometryIntersection(this, material2, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
};
Mesh.prototype.isMesh = true;
function checkIntersection(object4, material2, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material2.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material2.side !== DoubleSide, point);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object4.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object: object4
  };
}
function checkBufferGeometryIntersection(object4, material2, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
  _vA$1.fromBufferAttribute(position, a2);
  _vB$1.fromBufferAttribute(position, b2);
  _vC$1.fromBufferAttribute(position, c2);
  const morphInfluences = object4.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0) continue;
      _tempA.fromBufferAttribute(morphAttribute, a2);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object4.isSkinnedMesh) {
    object4.boneTransform(a2, _vA$1);
    object4.boneTransform(b2, _vB$1);
    object4.boneTransform(c2, _vC$1);
  }
  const intersection = checkIntersection(object4, material2, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a2);
      _uvB$1.fromBufferAttribute(uv, b2);
      _uvC$1.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a2);
      _uvB$1.fromBufferAttribute(uv2, b2);
      _uvC$1.fromBufferAttribute(uv2, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = class _BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segmentWidth - widthHalf;
          vector[u2] = x2 * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property = src[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u2][p2] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp2 = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp2) {
      merged[p2] = tmp2[p2];
    }
  }
  return merged;
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false
      // set to use shader texture LOD
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name2 in this.uniforms) {
      const uniform = this.uniforms[name2];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name2] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name2] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name2] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name2] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name2] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name2] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name2] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name2] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
};
ShaderMaterial.prototype.isShaderMaterial = true;
var Camera = class extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Camera.prototype.isCamera = true;
var PerspectiveCamera = class extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
};
PerspectiveCamera.prototype.isPerspectiveCamera = true;
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
CubeTexture.prototype.isCubeTexture = true;
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size, options2, dummy) {
    if (Number.isInteger(options2)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options2 = dummy;
    }
    super(size, size, options2);
    options2 = options2 || {};
    this.texture = new CubeTexture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material2 = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material2.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material2);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color2, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color2, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
var _vector1 = new Vector3();
var _vector2 = new Vector3();
var _normalMatrix = new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x2, y2, z2, w2) {
    this.normal.set(x2, y2, z2);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a2, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    const direction2 = line.delta(_vector1);
    const denominator = this.normal.dot(direction2);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(direction2).multiplyScalar(t2).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Plane.prototype.isPlane = true;
var _sphere$2 = new Sphere();
var _vector$7 = new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m2) {
    const planes = this.planes;
    const me = m2.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object4) {
    const geometry = object4.geometry;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object4.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  const buffers2 = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array4 = attribute.array;
    const usage = attribute.usage;
    const buffer3 = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer3);
    gl.bufferData(bufferType, array4, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array4 instanceof Float32Array) {
      type = 5126;
    } else if (array4 instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array4 instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array4 instanceof Int16Array) {
      type = 5122;
    } else if (array4 instanceof Uint32Array) {
      type = 5125;
    } else if (array4 instanceof Int32Array) {
      type = 5124;
    } else if (array4 instanceof Int8Array) {
      type = 5120;
    } else if (array4 instanceof Uint8Array) {
      type = 5121;
    } else if (array4 instanceof Uint8ClampedArray) {
      type = 5121;
    }
    return {
      buffer: buffer3,
      type,
      bytesPerElement: array4.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer3, attribute, bufferType) {
    const array4 = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer3);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array4);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array4.BYTES_PER_ELEMENT,
          array4,
          updateRange.offset,
          updateRange.count
        );
      } else {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array4.BYTES_PER_ELEMENT,
          array4.subarray(updateRange.offset, updateRange.offset + updateRange.count)
        );
      }
      updateRange.count = -1;
    }
  }
  function get3(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers2.get(attribute);
  }
  function remove3(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers2.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers2.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers2.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers2.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers2.get(attribute);
    if (data === void 0) {
      buffers2.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get3,
    remove: remove3,
    update
  };
}
var PlaneGeometry = class _PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x2 = ix * segment_width - width_half;
        vertices.push(x2, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b2 = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n	return ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	#ifdef SPECULAR\n		vec3 specularIntensityFactor = vec3( specularIntensity );\n		vec3 specularTintFactor = specularTint;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARTINTMAP\n			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n		#endif\n		material.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n	#else\n		vec3 specularIntensityFactor = vec3( 1.0 );\n		vec3 specularTintFactor = vec3( 1.0 );\n		material.specularColorF90 = vec3( 1.0 );\n	#endif\n	material.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n	material.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n	vec3 specularColorF90;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationTint, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec4 vWorldPosition;\n	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n		vec3 modelScale;\n		modelScale.x = length(vec3(modelMatrix[0].xyz));\n		modelScale.y = length(vec3(modelMatrix[1].xyz));\n		modelScale.z = length(vec3(modelMatrix[2].xyz));\n		return normalize(refractionVector) * thickness * modelScale;\n	}\n	float applyIorToRoughness(float roughness, float ior) {\n		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n	}\n	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n	}\n	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n		if (attenuationDistance == 0.0) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;\n		}\n	}\n	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance) {\n		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n		return (1.0 - specularColor) * attenuatedColor * baseColor;\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n		#ifdef USE_TANGENT\n			vTangent = normalize( transformedTangent );\n			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n		#endif\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularTint;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARTINTMAP\n		uniform sampler2D specularTintMap;\n	#endif\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#ifdef USE_TRANSMISSION\n	varying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition;\n#endif\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
var UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new Color(0) },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationTint: { value: new Color(0) },
      specularIntensity: { value: 0 },
      specularIntensityMap: { value: null },
      specularTint: { value: new Color(1, 1, 1) },
      specularTintMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color2, alpha) {
    state.buffers.color.setClear(color2.r, color2.g, color2.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color2, alpha = 1) {
      clearColor.set(color2);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities2) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities2.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities2.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object4, material2, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material2);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers) saveCache(geometry, index);
    } else {
      const wireframe = material2.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object4.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object4, material2, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities2.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities2.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities2.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material2) {
    const wireframe = material2.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0) return true;
      if (cachedAttribute.attribute !== geometryAttribute) return true;
      if (cachedAttribute.data !== geometryAttribute.data) return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities2.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities2.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object4, material2, program, geometry) {
    if (capabilities2.isWebGL2 === false && (object4.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null) return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material2.defaultAttributeValues;
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name2];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer3 = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer3);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer3);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name2 === "instanceMatrix") {
          const attribute = attributes.get(object4.instanceMatrix);
          if (attribute === void 0) continue;
          const buffer3 = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer3);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name2 === "instanceColor") {
          const attribute = attributes.get(object4.instanceColor);
          if (attribute === void 0) continue;
          const buffer3 = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer3);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name2];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset2();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset2() {
    resetDefaultState();
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset: reset2,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  let mode2;
  function setMode(value) {
    mode2 = value;
  }
  function render(start, count) {
    gl.drawArrays(mode2, start, count);
    info.update(count, mode2, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode2, start, count, primcount);
    info.update(count, mode2, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material2, camera, useCache) {
    const planes = material2.clippingPlanes, clipIntersection = material2.clipIntersection, clipShadows = material2.clipShadows;
    const materialProperties = properties.get(material2);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get3(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get3,
    dispose
  };
}
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
};
OrthographicCamera.prototype.isOrthographicCamera = true;
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
};
RawShaderMaterial.prototype.isRawShaderMaterial = true;
var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow(2, LOD_MAX);
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
var MAX_SAMPLES = 20;
var ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
var backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
var _flatCamera = new OrthographicCamera();
var { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();
var _clearColor = new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector3(1, 1, 1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, -1),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-PHI, INV_PHI, 0)
];
function convertLinearToRGBE(color2) {
  const maxComponent = Math.max(color2.r, color2.g, color2.b);
  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
  color2.multiplyScalar(Math.pow(2, -fExp));
  const alpha = (fExp + 128) / 255;
  return alpha;
}
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null) this._cubemapShader.dispose();
    if (this._equirectShader !== null) this._equirectShader.dispose();
    for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
      _lodPlanes[i2].dispose();
    }
  }
  // private interface
  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material2) {
    const tmpMesh = new Mesh(_lodPlanes[0], material2);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    renderer.autoClear = false;
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background).convertSRGBToLinear();
        scene.background = null;
        const alpha = convertLinearToRGBE(backgroundMaterial.color);
        backgroundMaterial.opacity = alpha;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
      const alpha = convertLinearToRGBE(backgroundMaterial.color);
      backgroundMaterial.opacity = alpha;
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(forwardSign[i2], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.lookAt(0, forwardSign[i2], 0);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i2]);
      }
      _setViewport(
        cubeUVRenderTarget,
        col * SIZE_MAX,
        i2 > 2 ? SIZE_MAX : 0,
        SIZE_MAX,
        SIZE_MAX
      );
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.autoClear = originalAutoClear;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material2 = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material2);
    const uniforms = material2.uniforms;
    uniforms["envMap"].value = texture;
    if (!texture.isCubeTexture) {
      uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
    }
    uniforms["inputEncoding"].value = ENCODINGS[texture.encoding];
    uniforms["outputEncoding"].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
      const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
      const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction2 !== "latitudinal" && direction2 !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x3 = i2 / sigmaPixels;
      const weight = Math.exp(-x3 * x3 / 2);
      weights.push(weight);
      if (i2 == 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction2 === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = LOD_MAX - lodIn;
    blurUniforms["inputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
    blurUniforms["outputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
    const outputSize = _sizeLods[lodOut];
    const x2 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y2 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _isLDR(texture) {
  if (texture === void 0 || texture.type !== UnsignedByteType) return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes2 = [];
  const _sizeLods2 = [];
  const _sigmas2 = [];
  let lod = LOD_MAX;
  for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods2.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
    } else if (i2 == 0) {
      sigma = 0;
    }
    _sigmas2.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x2 = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill2 = [face, face, face, face, face, face];
      faceIndex.set(fill2, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    _lodPlanes2.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
}
function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x2, y2, width, height) {
  target.viewport.set(x2, y2, width, height);
  target.scissor.set(x2, y2, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: { "n": maxSamples },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "texelSize": { value: texelSize },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function _getEncodings() {
  return (
    /* glsl */
    `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get3(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (cubeUVmaps.has(texture)) {
          return cubeUVmaps.get(texture).texture;
        } else {
          const image = texture.image;
          if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
            const currentRenderTarget = renderer.getRenderTarget();
            if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
            const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
            cubeUVmaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return renderTarget.texture;
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubemapUV.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get: get3,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name2) {
    if (extensions[name2] !== void 0) {
      return extensions[name2];
    }
    let extension;
    switch (name2) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name2);
    }
    extensions[name2] = extension;
    return extension;
  }
  return {
    has: function(name2) {
      return getExtension(name2) !== null;
    },
    init: function(capabilities2) {
      if (capabilities2.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name2) {
      const extension = getExtension(name2);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name2 + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries2 = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name2 in geometry.attributes) {
      attributes.remove(geometry.attributes[name2]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries2[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get3(object4, geometry) {
    if (geometries2[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries2[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name2 in geometryAttributes) {
      attributes.update(geometryAttributes[name2], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name2 in morphAttributes) {
      const array4 = morphAttributes[name2];
      for (let i2 = 0, l2 = array4.length; i2 < l2; i2++) {
        attributes.update(array4[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array4 = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l2 = array4.length; i2 < l2; i2 += 3) {
        const a2 = array4[i2 + 0];
        const b2 = array4[i2 + 1];
        const c2 = array4[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      const array4 = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l2 = array4.length / 3 - 1; i2 < l2; i2 += 3) {
        const a2 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get: get3,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  let mode2;
  function setMode(value) {
    mode2 = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode2, count, type, start * bytesPerElement);
    info.update(count, mode2, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode2, count, type, start * bytesPerElement, primcount);
    info.update(count, mode2, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode2, instanceCount) {
    render.calls++;
    switch (mode2) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode2);
        break;
    }
  }
  function reset2() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset: reset2,
    update
  };
}
function numericalSort(a2, b2) {
  return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
  return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object4, geometry, material2, program) {
    const objectInfluences = object4.morphTargetInfluences;
    const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0 || influences.length !== length) {
      influences = [];
      for (let i2 = 0; i2 < length; i2++) {
        influences[i2] = [i2, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i2 = 0; i2 < length; i2++) {
      const influence = influences[i2];
      influence[0] = i2;
      influence[1] = objectInfluences[i2];
    }
    influences.sort(absNumericalSort);
    for (let i2 = 0; i2 < 8; i2++) {
      if (i2 < length && influences[i2][1]) {
        workInfluences[i2][0] = influences[i2][0];
        workInfluences[i2][1] = influences[i2][1];
      } else {
        workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i2][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = geometry.morphAttributes.position;
    const morphNormals = geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      const influence = workInfluences[i2];
      const index = influence[0];
      const value = influence[1];
      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
          geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
          geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
        }
        morphInfluences[i2] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
          geometry.deleteAttribute("morphTarget" + i2);
        }
        if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
          geometry.deleteAttribute("morphNormal" + i2);
        }
        morphInfluences[i2] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries2, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object4) {
    const frame = info.render.frame;
    const geometry = object4.geometry;
    const buffergeometry = geometries2.get(object4, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries2.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object4.isInstancedMesh) {
      if (object4.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object4.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object4.instanceMatrix, 34962);
      if (object4.instanceColor !== null) {
        attributes.update(object4.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
var DataTexture2DArray = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture2DArray.prototype.isDataTexture2DArray = true;
var DataTexture3D = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array4, nBlocks, blockSize) {
  const firstElem = array4[0];
  if (firstElem <= 0 || firstElem > 0) return array4;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array4[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length) return false;
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2]) return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2)) return;
  gl.uniform2iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2)) return;
  gl.uniform3iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2)) return;
  gl.uniform4iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV1ui(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2)) return;
  gl.uniform2uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2)) return;
  gl.uniform3uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2)) return;
  gl.uniform4uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueT1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v2 || emptyTexture, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || emptyTexture3d, unit);
}
function setValueT6(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyTexture2dArray, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v2) {
  const data = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v2) {
  const data = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v2) {
  const data = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl, v2) {
  gl.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl, v2) {
  gl.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl, v2) {
  gl.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl, v2) {
  gl.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    u2.setValue(gl, value[u2.id], textures);
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n2 = gl.getProgramParameter(program, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name2, value, textures) {
  const u2 = this.map[name2];
  if (u2 !== void 0) u2.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object4, name2) {
  const v2 = object4[name2];
  if (v2 !== void 0) this.setValue(gl, name2, v2);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2], v2 = values[u2.id];
    if (v2.needsUpdate !== false) {
      u2.setValue(gl, v2.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r2 = [];
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    if (u2.id in values) r2.push(u2);
  }
  return r2;
};
function WebGLShader(gl, type, string5) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string5);
  gl.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function addLineNumbers(string5) {
  const lines = string5.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === "") return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name2 in defines) {
    const value = defines[name2];
    if (value === false) continue;
    chunks.push("#define " + name2 + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n2 = gl.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n2; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name2 = info.name;
    attributes[name2] = gl.getAttribLocation(program, name2);
  }
  return attributes;
}
function filterEmptyLine(string5) {
  return string5 !== "";
}
function replaceLightNums(string5, parameters) {
  return string5.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string5, parameters) {
  return string5.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string5) {
  return string5.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string5 = ShaderChunk[include];
  if (string5 === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string5);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string5) {
  return string5.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string5 = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string5 += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string5;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader2 = parameters.vertexShader;
  let fragmentShader2 = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      // add '.0' if integer
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.specularTintMap ? getTexelDecodingFunction("specularTintMapTexelToLinear", parameters.specularTintMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader2 = resolveIncludes(vertexShader2);
  vertexShader2 = replaceLightNums(vertexShader2, parameters);
  vertexShader2 = replaceClippingPlaneNums(vertexShader2, parameters);
  fragmentShader2 = resolveIncludes(fragmentShader2);
  fragmentShader2 = replaceLightNums(fragmentShader2, parameters);
  fragmentShader2 = replaceClippingPlaneNums(fragmentShader2, parameters);
  vertexShader2 = unrollLoops(vertexShader2);
  fragmentShader2 = unrollLoops(fragmentShader2);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader2;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader2;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities2, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities2.isWebGL2;
  const logarithmicDepthBuffer = capabilities2.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities2.floatVertexTextures;
  const maxVertexUniforms = capabilities2.maxVertexUniforms;
  const vertexTextures = capabilities2.vertexTextures;
  let precision = capabilities2.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "specularIntensityMap",
    "specularTintMap",
    "specularTintMapEncoding",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmission",
    "transmissionMap",
    "thicknessMap"
  ];
  function getMaxBones(object4) {
    const skeleton = object4.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material2, lights, shadows, scene, object4) {
    const fog = scene.fog;
    const environment = material2.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material2.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material2.envMap || environment);
    const shaderID = shaderIDs[material2.type];
    const maxBones = object4.isSkinnedMesh ? getMaxBones(object4) : 0;
    if (material2.precision !== null) {
      precision = capabilities2.getMaxPrecision(material2.precision);
      if (precision !== material2.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material2.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader2, fragmentShader2;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader2 = shader.vertexShader;
      fragmentShader2 = shader.fragmentShader;
    } else {
      vertexShader2 = material2.vertexShader;
      fragmentShader2 = material2.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material2.type,
      vertexShader: vertexShader2,
      fragmentShader: fragmentShader2,
      defines: material2.defines,
      isRawShaderMaterial: material2.isRawShaderMaterial === true,
      glslVersion: material2.glslVersion,
      precision,
      instancing: object4.isInstancedMesh === true,
      instancingColor: object4.isInstancedMesh === true && object4.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material2.map,
      mapEncoding: getTextureEncodingFromMap(material2.map),
      matcap: !!material2.matcap,
      matcapEncoding: getTextureEncodingFromMap(material2.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material2.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material2.lightMap),
      aoMap: !!material2.aoMap,
      emissiveMap: !!material2.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material2.emissiveMap),
      bumpMap: !!material2.bumpMap,
      normalMap: !!material2.normalMap,
      objectSpaceNormalMap: material2.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material2.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material2.clearcoatMap,
      clearcoatRoughnessMap: !!material2.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material2.clearcoatNormalMap,
      displacementMap: !!material2.displacementMap,
      roughnessMap: !!material2.roughnessMap,
      metalnessMap: !!material2.metalnessMap,
      specularMap: !!material2.specularMap,
      specularIntensityMap: !!material2.specularIntensityMap,
      specularTintMap: !!material2.specularTintMap,
      specularTintMapEncoding: getTextureEncodingFromMap(material2.specularTintMap),
      alphaMap: !!material2.alphaMap,
      gradientMap: !!material2.gradientMap,
      sheen: !!material2.sheen,
      transmission: !!material2.transmission,
      transmissionMap: !!material2.transmissionMap,
      thicknessMap: !!material2.thicknessMap,
      combine: material2.combine,
      vertexTangents: !!material2.normalMap && !!object4.geometry && !!object4.geometry.attributes.tangent,
      vertexColors: material2.vertexColors,
      vertexAlphas: material2.vertexColors === true && !!object4.geometry && !!object4.geometry.attributes.color && object4.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material2.map || !!material2.bumpMap || !!material2.normalMap || !!material2.specularMap || !!material2.alphaMap || !!material2.emissiveMap || !!material2.roughnessMap || !!material2.metalnessMap || !!material2.clearcoatMap || !!material2.clearcoatRoughnessMap || !!material2.clearcoatNormalMap || !!material2.displacementMap || !!material2.transmissionMap || !!material2.thicknessMap || !!material2.specularIntensityMap || !!material2.specularTintMap,
      uvsVertexOnly: !(!!material2.map || !!material2.bumpMap || !!material2.normalMap || !!material2.specularMap || !!material2.alphaMap || !!material2.emissiveMap || !!material2.roughnessMap || !!material2.metalnessMap || !!material2.clearcoatNormalMap || !!material2.transmission || !!material2.transmissionMap || !!material2.thicknessMap || !!material2.specularIntensityMap || !!material2.specularTintMap) && !!material2.displacementMap,
      fog: !!fog,
      useFog: material2.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material2.flatShading,
      sizeAttenuation: material2.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object4.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: !!object4.geometry && !!object4.geometry.morphAttributes.position,
      morphNormals: !!object4.geometry && !!object4.geometry.morphAttributes.normal,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material2.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material2.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material2.premultipliedAlpha,
      alphaTest: material2.alphaTest,
      doubleSided: material2.side === DoubleSide,
      flipSided: material2.side === BackSide,
      depthPacking: material2.depthPacking !== void 0 ? material2.depthPacking : false,
      index0AttributeName: material2.index0AttributeName,
      extensionDerivatives: material2.extensions && material2.extensions.derivatives,
      extensionFragDepth: material2.extensions && material2.extensions.fragDepth,
      extensionDrawBuffers: material2.extensions && material2.extensions.drawBuffers,
      extensionShaderTextureLOD: material2.extensions && material2.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material2.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array4 = [];
    if (parameters.shaderID) {
      array4.push(parameters.shaderID);
    } else {
      array4.push(parameters.fragmentShader);
      array4.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name2 in parameters.defines) {
        array4.push(name2);
        array4.push(parameters.defines[name2]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i2 = 0; i2 < parameterNames.length; i2++) {
        array4.push(parameters[parameterNames[i2]]);
      }
      array4.push(renderer.outputEncoding);
      array4.push(renderer.gammaFactor);
    }
    array4.push(parameters.customProgramCacheKey);
    return array4.join();
  }
  function getUniforms(material2) {
    const shaderID = shaderIDs[material2.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material2.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
      const preexistingProgram = programs[p2];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get3(object4) {
    let map = properties.get(object4);
    if (map === void 0) {
      map = {};
      properties.set(object4, map);
    }
    return map;
  }
  function remove3(object4) {
    properties.delete(object4);
  }
  function update(object4, key, value) {
    properties.get(object4)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get3,
    remove: remove3,
    update,
    dispose
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.program !== b2.program) {
    return a2.program.id - b2.program.id;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  const defaultProgram = { id: -1 };
  function init2() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object4, geometry, material2, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material2);
    if (renderItem === void 0) {
      renderItem = {
        id: object4.id,
        object: object4,
        geometry,
        material: material2,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object4.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object4.id;
      renderItem.object = object4;
      renderItem.geometry = geometry;
      renderItem.material = material2;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object4.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object4, geometry, material2, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object4, geometry, material2, groupOrder, z2, group);
    if (material2.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material2.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object4, geometry, material2, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object4, geometry, material2, groupOrder, z2, group);
    if (material2.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material2.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init: init2,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = /* @__PURE__ */ new WeakMap();
  function get3(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get3,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities2) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix42 = new Matrix4();
  const matrix422 = new Matrix4();
  function setup(lights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++) state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color2 = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color2.r * intensity;
        g2 += color2.g * intensity;
        b2 += color2.b * intensity;
      } else if (light.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities2.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix422.identity();
        matrix42.copy(light.matrixWorld);
        matrix42.premultiply(viewMatrix);
        matrix422.extractRotation(matrix42);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix422);
        uniforms.halfHeight.applyMatrix4(matrix422);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities2) {
  const lights = new WebGLLights(extensions, capabilities2);
  const lightsArray = [];
  const shadowsArray = [];
  function init2() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init: init2,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities2) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get3(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities2);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities2);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get3,
    dispose
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport2 = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport2.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport2);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object4, geometry, material2, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object4.customDistanceMaterial : object4.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material2.clipShadows === true && material2.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material2.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material2.visible;
    result.wireframe = material2.wireframe;
    if (type === VSMShadowMap) {
      result.side = material2.shadowSide !== null ? material2.shadowSide : material2.side;
    } else {
      result.side = material2.shadowSide !== null ? material2.shadowSide : shadowSide[material2.side];
    }
    result.clipShadows = material2.clipShadows;
    result.clippingPlanes = material2.clippingPlanes;
    result.clipIntersection = material2.clipIntersection;
    result.wireframeLinewidth = material2.wireframeLinewidth;
    result.linewidth = material2.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object4, camera, shadowCamera, light, type) {
    if (object4.visible === false) return;
    const visible = object4.layers.test(camera.layers);
    if (visible && (object4.isMesh || object4.isLine || object4.isPoints)) {
      if ((object4.castShadow || object4.receiveShadow && type === VSMShadowMap) && (!object4.frustumCulled || _frustum.intersectsObject(object4))) {
        object4.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object4.matrixWorld);
        const geometry = _objects.update(object4);
        const material2 = object4.material;
        if (Array.isArray(material2)) {
          const groups2 = geometry.groups;
          for (let k2 = 0, kl = groups2.length; k2 < kl; k2++) {
            const group = groups2[k2];
            const groupMaterial = material2[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object4, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object4, group);
            }
          }
        } else if (material2.visible) {
          const depthMaterial = getDepthMaterial(object4, geometry, material2, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object4, null);
        }
      }
    }
    const children = object4.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color2 = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color2.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color2) === false) {
          gl.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color2);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let xrFramebuffer = null;
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindXRFramebuffer(framebuffer) {
    if (framebuffer !== xrFramebuffer) {
      gl.bindFramebuffer(36160, framebuffer);
      xrFramebuffer = framebuffer;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material2, frontFaceCW) {
    material2.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material2.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material2.blending === NormalBlending && material2.transparent === false ? setBlending(NoBlending) : setBlending(material2.blending, material2.blendEquation, material2.blendSrc, material2.blendDst, material2.blendEquationAlpha, material2.blendSrcAlpha, material2.blendDstAlpha, material2.premultipliedAlpha);
    depthBuffer.setFunc(material2.depthFunc);
    depthBuffer.setTest(material2.depthTest);
    depthBuffer.setMask(material2.depthWrite);
    colorBuffer.setMask(material2.colorWrite);
    const stencilWrite = material2.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material2.stencilWriteMask);
      stencilBuffer.setFunc(material2.stencilFunc, material2.stencilRef, material2.stencilFuncMask);
      stencilBuffer.setOp(material2.stencilFail, material2.stencilZFail, material2.stencilZPass);
    }
    setPolygonOffset(material2.polygonOffset, material2.polygonOffsetFactor, material2.polygonOffsetUnits);
    material2.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset2() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    xrFramebuffer = null;
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    bindXRFramebuffer,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset: reset2
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities2, utils2, info) {
  const isWebGL2 = capabilities2.isWebGL2;
  const maxTextures = capabilities2.maxTextures;
  const maxCubemapSize = capabilities2.maxCubemapSize;
  const maxTextureSize = capabilities2.maxTextureSize;
  const maxSamples = capabilities2.maxSamples;
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height, depth = 1) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false) return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126) internalFormat = 34837;
      if (glType === 5131) internalFormat = 34843;
      if (glType === 5121) internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget) return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i2 = 0, il = texture.length; i2 < il; i2++) {
        const attachmentProperties = properties.get(texture[i2]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i2]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false)) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities2.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray) textureType = 35866;
    if (texture.isDataTexture3D) textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format);
    let glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils2.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils2.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
        mipmap = mipmaps[i2];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i2 = 0; i2 < 6; i2++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
      } else {
        cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format), glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i2 = 0; i2 < 6; i2++) {
        mipmaps = cubeImage[i2].mipmaps;
        for (let j2 = 0; j2 < mipmaps.length; j2++) {
          const mipmap = mipmaps[j2];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i2 = 0; i2 < 6; i2++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            const mipmapImage = mipmap.image[i2].image;
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils2.convert(texture.format);
    const glType = utils2.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    state.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils2.convert(texture.format);
      const glType = utils2.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      textureProperties.__webglTexture = _gl.createTexture();
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities2.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const attachmentProperties = properties.get(textures[i2]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils2.convert(texture.format);
          const glType = utils2.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);
        }
      }
      state.bindTexture(3553, null);
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
      }
      state.bindTexture(glTextureType, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state.bindTexture(target, null);
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  function convert(p2) {
    let extension;
    if (p2 === UnsignedByteType) return 5121;
    if (p2 === UnsignedShort4444Type) return 32819;
    if (p2 === UnsignedShort5551Type) return 32820;
    if (p2 === UnsignedShort565Type) return 33635;
    if (p2 === ByteType) return 5120;
    if (p2 === ShortType) return 5122;
    if (p2 === UnsignedShortType) return 5123;
    if (p2 === IntType) return 5124;
    if (p2 === UnsignedIntType) return 5125;
    if (p2 === FloatType) return 5126;
    if (p2 === HalfFloatType) {
      if (isWebGL2) return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p2 === AlphaFormat) return 6406;
    if (p2 === RGBFormat) return 6407;
    if (p2 === RGBAFormat) return 6408;
    if (p2 === LuminanceFormat) return 6409;
    if (p2 === LuminanceAlphaFormat) return 6410;
    if (p2 === DepthFormat) return 6402;
    if (p2 === DepthStencilFormat) return 34041;
    if (p2 === RedFormat) return 6403;
    if (p2 === RedIntegerFormat) return 36244;
    if (p2 === RGFormat) return 33319;
    if (p2 === RGIntegerFormat) return 33320;
    if (p2 === RGBIntegerFormat) return 36248;
    if (p2 === RGBAIntegerFormat) return 36249;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format || p2 === SRGB8_ALPHA8_ASTC_4x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x5_Format || p2 === SRGB8_ALPHA8_ASTC_8x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x5_Format || p2 === SRGB8_ALPHA8_ASTC_10x6_Format || p2 === SRGB8_ALPHA8_ASTC_10x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (isWebGL2) return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
var ArrayCamera = class extends PerspectiveCamera {
  constructor(array4 = []) {
    super();
    this.cameras = array4;
  }
};
ArrayCamera.prototype.isArrayCamera = true;
var Group = class extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
};
Group.prototype.isGroup = true;
var _moveEvent = { type: "move" };
var WebXRController = class {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
};
var WebXRManager = class extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    const state = renderer.state;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    let glBinding = null;
    let glFramebuffer = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    const controllers = [];
    const inputSourcesMap = /* @__PURE__ */ new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      state.bindXRFramebuffer(null);
      renderer.setRenderTarget(renderer.getRenderTarget());
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        const attributes = gl.getContextAttributes();
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
        } else {
          let depthFormat = 0;
          if (attributes.antialias) {
            const layerInit = {
              antialias: true,
              alpha: attributes.alpha,
              depth: attributes.depth,
              stencil: attributes.stencil,
              framebufferScaleFactor
            };
            glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({ layers: [glBaseLayer] });
          } else {
            if (attributes.depth) {
              depthFormat = attributes.stencil ? 34041 : 6402;
            }
            const projectionlayerInit = {
              colorFormat: attributes.alpha ? 6408 : 6407,
              depthFormat,
              scaleFactor: framebufferScaleFactor
            };
            glBinding = new XRWebGLBinding(session, gl);
            glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
            glFramebuffer = gl.createFramebuffer();
            session.updateRenderState({ layers: [glProjLayer] });
          }
        }
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        inputSourcesMap.set(inputSources[i2], controllers[i2]);
      }
      for (let i2 = 0; i2 < event.removed.length; i2++) {
        const inputSource = event.removed[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i2 = 0; i2 < event.added.length; i2++) {
        const inputSource = event.added[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null) return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i2 = 0; i2 < cameras2.length; i2++) {
        updateCamera(cameras2[i2], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          state.bindXRFramebuffer(glBaseLayer.framebuffer);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i2 = 0; i2 < views.length; i2++) {
          const view = views[i2];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            state.bindXRFramebuffer(glFramebuffer);
            if (glSubImage.depthStencilTexture !== void 0) {
              gl.framebufferTexture2D(36160, 36096, 3553, glSubImage.depthStencilTexture, 0);
            }
            gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);
            viewport = glSubImage.viewport;
          }
          const camera = cameras[i2];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i2 === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      }
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const controller = controllers[i2];
        const inputSource = inputSources[i2];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
};
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material2, pixelRatio, height, transmissionRenderTarget) {
    if (material2.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material2);
    } else if (material2.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material2);
      refreshUniformsLambert(uniforms, material2);
    } else if (material2.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material2);
      refreshUniformsToon(uniforms, material2);
    } else if (material2.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material2);
      refreshUniformsPhong(uniforms, material2);
    } else if (material2.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material2);
      if (material2.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material2, transmissionRenderTarget);
      } else {
        refreshUniformsStandard(uniforms, material2);
      }
    } else if (material2.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material2);
      refreshUniformsMatcap(uniforms, material2);
    } else if (material2.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material2);
      refreshUniformsDepth(uniforms, material2);
    } else if (material2.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material2);
      refreshUniformsDistance(uniforms, material2);
    } else if (material2.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material2);
      refreshUniformsNormal(uniforms, material2);
    } else if (material2.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material2);
      if (material2.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material2);
      }
    } else if (material2.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material2, pixelRatio, height);
    } else if (material2.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material2);
    } else if (material2.isShadowMaterial) {
      uniforms.color.value.copy(material2.color);
      uniforms.opacity.value = material2.opacity;
    } else if (material2.isShaderMaterial) {
      material2.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material2) {
    uniforms.opacity.value = material2.opacity;
    if (material2.color) {
      uniforms.diffuse.value.copy(material2.color);
    }
    if (material2.emissive) {
      uniforms.emissive.value.copy(material2.emissive).multiplyScalar(material2.emissiveIntensity);
    }
    if (material2.map) {
      uniforms.map.value = material2.map;
    }
    if (material2.alphaMap) {
      uniforms.alphaMap.value = material2.alphaMap;
    }
    if (material2.specularMap) {
      uniforms.specularMap.value = material2.specularMap;
    }
    const envMap = properties.get(material2).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material2.reflectivity;
      uniforms.refractionRatio.value = material2.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material2.lightMap) {
      uniforms.lightMap.value = material2.lightMap;
      uniforms.lightMapIntensity.value = material2.lightMapIntensity;
    }
    if (material2.aoMap) {
      uniforms.aoMap.value = material2.aoMap;
      uniforms.aoMapIntensity.value = material2.aoMapIntensity;
    }
    let uvScaleMap;
    if (material2.map) {
      uvScaleMap = material2.map;
    } else if (material2.specularMap) {
      uvScaleMap = material2.specularMap;
    } else if (material2.displacementMap) {
      uvScaleMap = material2.displacementMap;
    } else if (material2.normalMap) {
      uvScaleMap = material2.normalMap;
    } else if (material2.bumpMap) {
      uvScaleMap = material2.bumpMap;
    } else if (material2.roughnessMap) {
      uvScaleMap = material2.roughnessMap;
    } else if (material2.metalnessMap) {
      uvScaleMap = material2.metalnessMap;
    } else if (material2.alphaMap) {
      uvScaleMap = material2.alphaMap;
    } else if (material2.emissiveMap) {
      uvScaleMap = material2.emissiveMap;
    } else if (material2.clearcoatMap) {
      uvScaleMap = material2.clearcoatMap;
    } else if (material2.clearcoatNormalMap) {
      uvScaleMap = material2.clearcoatNormalMap;
    } else if (material2.clearcoatRoughnessMap) {
      uvScaleMap = material2.clearcoatRoughnessMap;
    } else if (material2.specularIntensityMap) {
      uvScaleMap = material2.specularIntensityMap;
    } else if (material2.specularTintMap) {
      uvScaleMap = material2.specularTintMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material2.aoMap) {
      uv2ScaleMap = material2.aoMap;
    } else if (material2.lightMap) {
      uv2ScaleMap = material2.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material2) {
    uniforms.diffuse.value.copy(material2.color);
    uniforms.opacity.value = material2.opacity;
  }
  function refreshUniformsDash(uniforms, material2) {
    uniforms.dashSize.value = material2.dashSize;
    uniforms.totalSize.value = material2.dashSize + material2.gapSize;
    uniforms.scale.value = material2.scale;
  }
  function refreshUniformsPoints(uniforms, material2, pixelRatio, height) {
    uniforms.diffuse.value.copy(material2.color);
    uniforms.opacity.value = material2.opacity;
    uniforms.size.value = material2.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material2.map) {
      uniforms.map.value = material2.map;
    }
    if (material2.alphaMap) {
      uniforms.alphaMap.value = material2.alphaMap;
    }
    let uvScaleMap;
    if (material2.map) {
      uvScaleMap = material2.map;
    } else if (material2.alphaMap) {
      uvScaleMap = material2.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material2) {
    uniforms.diffuse.value.copy(material2.color);
    uniforms.opacity.value = material2.opacity;
    uniforms.rotation.value = material2.rotation;
    if (material2.map) {
      uniforms.map.value = material2.map;
    }
    if (material2.alphaMap) {
      uniforms.alphaMap.value = material2.alphaMap;
    }
    let uvScaleMap;
    if (material2.map) {
      uvScaleMap = material2.map;
    } else if (material2.alphaMap) {
      uvScaleMap = material2.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material2) {
    if (material2.emissiveMap) {
      uniforms.emissiveMap.value = material2.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material2) {
    uniforms.specular.value.copy(material2.specular);
    uniforms.shininess.value = Math.max(material2.shininess, 1e-4);
    if (material2.emissiveMap) {
      uniforms.emissiveMap.value = material2.emissiveMap;
    }
    if (material2.bumpMap) {
      uniforms.bumpMap.value = material2.bumpMap;
      uniforms.bumpScale.value = material2.bumpScale;
      if (material2.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material2.normalMap) {
      uniforms.normalMap.value = material2.normalMap;
      uniforms.normalScale.value.copy(material2.normalScale);
      if (material2.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material2.displacementMap) {
      uniforms.displacementMap.value = material2.displacementMap;
      uniforms.displacementScale.value = material2.displacementScale;
      uniforms.displacementBias.value = material2.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material2) {
    if (material2.gradientMap) {
      uniforms.gradientMap.value = material2.gradientMap;
    }
    if (material2.emissiveMap) {
      uniforms.emissiveMap.value = material2.emissiveMap;
    }
    if (material2.bumpMap) {
      uniforms.bumpMap.value = material2.bumpMap;
      uniforms.bumpScale.value = material2.bumpScale;
      if (material2.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material2.normalMap) {
      uniforms.normalMap.value = material2.normalMap;
      uniforms.normalScale.value.copy(material2.normalScale);
      if (material2.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material2.displacementMap) {
      uniforms.displacementMap.value = material2.displacementMap;
      uniforms.displacementScale.value = material2.displacementScale;
      uniforms.displacementBias.value = material2.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material2) {
    uniforms.roughness.value = material2.roughness;
    uniforms.metalness.value = material2.metalness;
    if (material2.roughnessMap) {
      uniforms.roughnessMap.value = material2.roughnessMap;
    }
    if (material2.metalnessMap) {
      uniforms.metalnessMap.value = material2.metalnessMap;
    }
    if (material2.emissiveMap) {
      uniforms.emissiveMap.value = material2.emissiveMap;
    }
    if (material2.bumpMap) {
      uniforms.bumpMap.value = material2.bumpMap;
      uniforms.bumpScale.value = material2.bumpScale;
      if (material2.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material2.normalMap) {
      uniforms.normalMap.value = material2.normalMap;
      uniforms.normalScale.value.copy(material2.normalScale);
      if (material2.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material2.displacementMap) {
      uniforms.displacementMap.value = material2.displacementMap;
      uniforms.displacementScale.value = material2.displacementScale;
      uniforms.displacementBias.value = material2.displacementBias;
    }
    const envMap = properties.get(material2).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material2.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material2, transmissionRenderTarget) {
    refreshUniformsStandard(uniforms, material2);
    uniforms.reflectivity.value = material2.reflectivity;
    uniforms.clearcoat.value = material2.clearcoat;
    uniforms.clearcoatRoughness.value = material2.clearcoatRoughness;
    if (material2.sheen) uniforms.sheen.value.copy(material2.sheen);
    if (material2.clearcoatMap) {
      uniforms.clearcoatMap.value = material2.clearcoatMap;
    }
    if (material2.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material2.clearcoatRoughnessMap;
    }
    if (material2.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material2.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material2.clearcoatNormalMap;
      if (material2.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material2.transmission;
    if (material2.transmissionMap) {
      uniforms.transmissionMap.value = material2.transmissionMap;
    }
    if (material2.transmission > 0) {
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
    }
    uniforms.thickness.value = material2.thickness;
    if (material2.thicknessMap) {
      uniforms.thicknessMap.value = material2.thicknessMap;
    }
    uniforms.attenuationDistance.value = material2.attenuationDistance;
    uniforms.attenuationTint.value.copy(material2.attenuationTint);
    uniforms.specularIntensity.value = material2.specularIntensity;
    uniforms.specularTint.value.copy(material2.specularTint);
    if (material2.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material2.specularIntensityMap;
    }
    if (material2.specularTintMap) {
      uniforms.specularTintMap.value = material2.specularTintMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material2) {
    if (material2.matcap) {
      uniforms.matcap.value = material2.matcap;
    }
    if (material2.bumpMap) {
      uniforms.bumpMap.value = material2.bumpMap;
      uniforms.bumpScale.value = material2.bumpScale;
      if (material2.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material2.normalMap) {
      uniforms.normalMap.value = material2.normalMap;
      uniforms.normalScale.value.copy(material2.normalScale);
      if (material2.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material2.displacementMap) {
      uniforms.displacementMap.value = material2.displacementMap;
      uniforms.displacementScale.value = material2.displacementScale;
      uniforms.displacementBias.value = material2.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material2) {
    if (material2.displacementMap) {
      uniforms.displacementMap.value = material2.displacementMap;
      uniforms.displacementScale.value = material2.displacementScale;
      uniforms.displacementBias.value = material2.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material2) {
    if (material2.displacementMap) {
      uniforms.displacementMap.value = material2.displacementMap;
      uniforms.displacementScale.value = material2.displacementScale;
      uniforms.displacementBias.value = material2.displacementBias;
    }
    uniforms.referencePosition.value.copy(material2.referencePosition);
    uniforms.nearDistance.value = material2.nearDistance;
    uniforms.farDistance.value = material2.farDistance;
  }
  function refreshUniformsNormal(uniforms, material2) {
    if (material2.bumpMap) {
      uniforms.bumpMap.value = material2.bumpMap;
      uniforms.bumpScale.value = material2.bumpScale;
      if (material2.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material2.normalMap) {
      uniforms.normalMap.value = material2.normalMap;
      uniforms.normalScale.value.copy(material2.normalScale);
      if (material2.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material2.displacementMap) {
      uniforms.displacementMap.value = material2.displacementMap;
      uniforms.displacementScale.value = material2.displacementScale;
      uniforms.displacementBias.value = material2.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport2 = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _currentDrawBuffers = [];
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext2(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null) return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext2(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext2(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities2, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries2, objects;
  let programCache, materials2, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils2, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities2 = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities2);
    utils2 = new WebGLUtils(_gl, extensions, capabilities2);
    state = new WebGLState(_gl, extensions, capabilities2);
    _currentDrawBuffers[0] = 1029;
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities2, utils2, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities2);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities2);
    geometries2 = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries2, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities2, bindingStates, clipping);
    materials2 = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities2);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities2);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities2);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities2);
    info.programs = programCache.programs;
    _this.capabilities = capabilities2;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension) extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension) extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport2);
  };
  this.setViewport = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _viewport2.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport2.set(x2, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color2, depth, stencil) {
    let bits = 0;
    if (color2 === void 0 || color2) bits |= 16384;
    if (depth === void 0 || depth) bits |= 256;
    if (stencil === void 0 || stencil) bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material2 = event.target;
    material2.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material2);
  }
  function deallocateMaterial(material2) {
    releaseMaterialProgramReferences(material2);
    properties.remove(material2);
  }
  function releaseMaterialProgramReferences(material2) {
    const programs = properties.get(material2).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
    }
  }
  function renderObjectImmediate(object4, program) {
    object4.render(function(object5) {
      _this.renderBufferImmediate(object5, program);
    });
  }
  this.renderBufferImmediate = function(object4, program) {
    bindingStates.initAttributes();
    const buffers2 = properties.get(object4);
    if (object4.hasPositions && !buffers2.position) buffers2.position = _gl.createBuffer();
    if (object4.hasNormals && !buffers2.normal) buffers2.normal = _gl.createBuffer();
    if (object4.hasUvs && !buffers2.uv) buffers2.uv = _gl.createBuffer();
    if (object4.hasColors && !buffers2.color) buffers2.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object4.hasPositions) {
      _gl.bindBuffer(34962, buffers2.position);
      _gl.bufferData(34962, object4.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object4.hasNormals) {
      _gl.bindBuffer(34962, buffers2.normal);
      _gl.bufferData(34962, object4.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object4.hasUvs) {
      _gl.bindBuffer(34962, buffers2.uv);
      _gl.bufferData(34962, object4.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object4.hasColors) {
      _gl.bindBuffer(34962, buffers2.color);
      _gl.bufferData(34962, object4.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object4.count);
    object4.count = 0;
  };
  this.renderBufferDirect = function(camera, scene, geometry, material2, object4, group) {
    if (scene === null) scene = _emptyScene;
    const frontFaceCW = object4.isMesh && object4.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material2, object4);
    state.setMaterial(material2, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0) return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material2.wireframe === true) {
      index = geometries2.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0) {
      morphtargets.update(object4, geometry, material2, program);
    }
    bindingStates.setup(object4, material2, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return;
    if (object4.isMesh) {
      if (material2.wireframe === true) {
        state.setLineWidth(material2.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object4.isLine) {
      let lineWidth = material2.linewidth;
      if (lineWidth === void 0) lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object4.isLineSegments) {
        renderer.setMode(1);
      } else if (object4.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object4.isPoints) {
      renderer.setMode(0);
    } else if (object4.isSprite) {
      renderer.setMode(4);
    }
    if (object4.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object4.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function(object4) {
      if (object4.isLight && object4.layers.test(camera.layers)) {
        currentRenderState.pushLight(object4);
        if (object4.castShadow) {
          currentRenderState.pushShadow(object4);
        }
      }
    });
    currentRenderState.setupLights();
    scene.traverse(function(object4) {
      const material2 = object4.material;
      if (material2) {
        if (Array.isArray(material2)) {
          for (let i2 = 0; i2 < material2.length; i2++) {
            const material22 = material2[i2];
            getProgram(material22, scene, object4);
          }
        } else {
          getProgram(material2, scene, object4);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined") animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true) return;
    if (scene.autoUpdate === true) scene.updateMatrixWorld();
    if (camera.parent === null) camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
      camera = xr.getCamera();
    }
    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true) clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true) clipping.endShadows();
    if (this.info.autoReset === true) this.info.reset();
    background.render(currentRenderList, scene);
    const opaqueObjects = currentRenderList.opaque;
    const transmissiveObjects = currentRenderList.transmissive;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object4, camera, groupOrder, sortObjects) {
    if (object4.visible === false) return;
    const visible = object4.layers.test(camera.layers);
    if (visible) {
      if (object4.isGroup) {
        groupOrder = object4.renderOrder;
      } else if (object4.isLOD) {
        if (object4.autoUpdate === true) object4.update(camera);
      } else if (object4.isLight) {
        currentRenderState.pushLight(object4);
        if (object4.castShadow) {
          currentRenderState.pushShadow(object4);
        }
      } else if (object4.isSprite) {
        if (!object4.frustumCulled || _frustum.intersectsSprite(object4)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object4.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object4);
          const material2 = object4.material;
          if (material2.visible) {
            currentRenderList.push(object4, geometry, material2, groupOrder, _vector3.z, null);
          }
        }
      } else if (object4.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object4.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object4, null, object4.material, groupOrder, _vector3.z, null);
      } else if (object4.isMesh || object4.isLine || object4.isPoints) {
        if (object4.isSkinnedMesh) {
          if (object4.skeleton.frame !== info.render.frame) {
            object4.skeleton.update();
            object4.skeleton.frame = info.render.frame;
          }
        }
        if (!object4.frustumCulled || _frustum.intersectsObject(object4)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object4.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object4);
          const material2 = object4.material;
          if (Array.isArray(material2)) {
            const groups2 = geometry.groups;
            for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
              const group = groups2[i2];
              const groupMaterial = material2[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object4, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material2.visible) {
            currentRenderList.push(object4, geometry, material2, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object4.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {
    if (_transmissionRenderTarget === null) {
      const needsAntialias = _antialias === true && capabilities2.isWebGL2 === true;
      const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
      _transmissionRenderTarget = new renderTargetType(1024, 1024, {
        generateMipmaps: true,
        type: utils2.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping
      });
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
    renderObjects(transmissiveObjects, scene, camera);
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    if (camera.isArrayCamera) {
      const cameras = camera.cameras;
      for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
        const camera2 = cameras[i2];
        state.viewport(_currentViewport.copy(camera2.viewport));
        currentRenderState.setupLightsView(camera2);
        for (let j2 = 0, jl = renderList.length; j2 < jl; j2++) {
          const renderItem = renderList[j2];
          const object4 = renderItem.object;
          const geometry = renderItem.geometry;
          const material2 = overrideMaterial === null ? renderItem.material : overrideMaterial;
          const group = renderItem.group;
          if (object4.layers.test(camera2.layers)) {
            renderObject(object4, scene, camera2, geometry, material2, group);
          }
        }
      }
    } else {
      for (let j2 = 0, jl = renderList.length; j2 < jl; j2++) {
        const renderItem = renderList[j2];
        const object4 = renderItem.object;
        const geometry = renderItem.geometry;
        const material2 = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        renderObject(object4, scene, camera, geometry, material2, group);
      }
    }
  }
  function renderObject(object4, scene, camera, geometry, material2, group) {
    object4.onBeforeRender(_this, scene, camera, geometry, material2, group);
    object4.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object4.matrixWorld);
    object4.normalMatrix.getNormalMatrix(object4.modelViewMatrix);
    if (object4.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material2, object4);
      state.setMaterial(material2);
      bindingStates.reset();
      renderObjectImmediate(object4, program);
    } else {
      if (material2.transparent === true && material2.side === DoubleSide) {
        material2.side = BackSide;
        material2.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material2, object4, group);
        material2.side = FrontSide;
        material2.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material2, object4, group);
        material2.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material2, object4, group);
      }
    }
    object4.onAfterRender(_this, scene, camera, geometry, material2, group);
  }
  function getProgram(material2, scene, object4) {
    if (scene.isScene !== true) scene = _emptyScene;
    const materialProperties = properties.get(material2);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material2, lights.state, shadowsArray, scene, object4);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material2.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material2.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material2.envMap || materialProperties.environment);
    if (programs === void 0) {
      material2.addEventListener("dispose", onMaterialDispose);
      programs = /* @__PURE__ */ new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material2, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material2);
      material2.onBuild(parameters2, _this);
      material2.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material2.isShaderMaterial && !material2.isRawShaderMaterial || material2.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material2, parameters2);
    materialProperties.needsLights = materialNeedsLights(material2);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material2, parameters2) {
    const materialProperties = properties.get(material2);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
  }
  function setProgram(camera, scene, material2, object4) {
    if (scene.isScene !== true) scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material2.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = (material2.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material2.envMap || environment);
    const vertexAlphas = material2.vertexColors === true && !!object4.geometry && !!object4.geometry.attributes.color && object4.geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!object4.geometry && !!object4.geometry.attributes.tangent;
    const morphTargets = !!object4.geometry && !!object4.geometry.morphAttributes.position;
    const morphNormals = !!object4.geometry && !!object4.geometry.morphAttributes.normal;
    const materialProperties = properties.get(material2);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material2.id === _currentMaterialId;
        clipping.setState(material2, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material2.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object4.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object4.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object4.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object4.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material2.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material2.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material2, scene, object4);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material2.id !== _currentMaterialId) {
      _currentMaterialId = material2.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities2.logarithmicDepthBuffer) {
        p_uniforms.setValue(
          _gl,
          "logDepthBufFC",
          2 / (Math.log(camera.far + 1) / Math.LN2)
        );
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material2.isShaderMaterial || material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshStandardMaterial || material2.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(
            _gl,
            _vector3.setFromMatrixPosition(camera.matrixWorld)
          );
        }
      }
      if (material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshLambertMaterial || material2.isMeshBasicMaterial || material2.isMeshStandardMaterial || material2.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material2.isMeshPhongMaterial || material2.isMeshToonMaterial || material2.isMeshLambertMaterial || material2.isMeshBasicMaterial || material2.isMeshStandardMaterial || material2.isShaderMaterial || material2.isShadowMaterial || object4.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (object4.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object4, "bindMatrix");
      p_uniforms.setOptional(_gl, object4, "bindMatrixInverse");
      const skeleton = object4.skeleton;
      if (skeleton) {
        if (capabilities2.floatVertexTextures) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object4.receiveShadow) {
      materialProperties.receiveShadow = object4.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object4.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material2.fog) {
        materials2.refreshFogUniforms(m_uniforms, fog);
      }
      materials2.refreshMaterialUniforms(m_uniforms, material2, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material2.isShaderMaterial && material2.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material2.uniformsNeedUpdate = false;
    }
    if (material2.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object4.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object4.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object4.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object4.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material2) {
    return material2.isMeshLambertMaterial || material2.isMeshToonMaterial || material2.isMeshPhongMaterial || material2.isMeshStandardMaterial || material2.isShadowMaterial || material2.isShaderMaterial && material2.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities2.drawBuffers) {
      let needsUpdate = false;
      if (renderTarget) {
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures2 = renderTarget.texture;
          if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== 36064) {
            for (let i2 = 0, il = textures2.length; i2 < il; i2++) {
              _currentDrawBuffers[i2] = 36064 + i2;
            }
            _currentDrawBuffers.length = textures2.length;
            needsUpdate = true;
          }
        } else {
          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
            _currentDrawBuffers[0] = 36064;
            _currentDrawBuffers.length = 1;
            needsUpdate = true;
          }
        }
      } else {
        if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
          _currentDrawBuffers[0] = 1029;
          _currentDrawBuffers.length = 1;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities2.isWebGL2) {
          _gl.drawBuffers(_currentDrawBuffers);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
        }
      }
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer3, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils2.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities2.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils2.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities2.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x2, y2, width, height, utils2.convert(textureFormat), utils2.convert(textureType), buffer3);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    let glFormat = utils2.convert(texture.format);
    if (capabilities2.isWebGL2) {
      if (glFormat === 6407) glFormat = 32849;
      if (glFormat === 6408) glFormat = 32856;
    }
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils2.convert(dstTexture.format);
    const glType = utils2.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils2.convert(dstTexture.format);
    const glType = utils2.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image.width);
    _gl.pixelStorei(32878, image.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class _FogExp2 {
  constructor(color2, density = 25e-5) {
    this.name = "";
    this.color = new Color(color2);
    this.density = density;
  }
  clone() {
    return new _FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
FogExp2.prototype.isFogExp2 = true;
var Fog = class _Fog {
  constructor(color2, near = 1, far = 1e3) {
    this.name = "";
    this.color = new Color(color2);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new _Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
Fog.prototype.isFog = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  }
};
Scene.prototype.isScene = true;
var InterleavedBuffer = class {
  constructor(array4, stride) {
    this.array = array4;
    this.stride = stride;
    this.count = array4 !== void 0 ? array4.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array4 = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array4, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
InterleavedBuffer.prototype.isInterleavedBuffer = true;
var _vector$6 = new Vector3();
var InterleavedBufferAttribute = class _InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.transformDirection(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  setX(index, x2) {
    this.data.array[index * this.data.stride + this.offset] = x2;
    return this;
  }
  setY(index, y2) {
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  setZ(index, z2) {
    this.data.array[index * this.data.stride + this.offset + 2] = z2;
    return this;
  }
  setW(index, w2) {
    this.data.array[index * this.data.stride + this.offset + 3] = w2;
    return this;
  }
  getX(index) {
    return this.data.array[index * this.data.stride + this.offset];
  }
  getY(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  }
  getZ(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  }
  getW(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  }
  setXY(index, x2, y2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    this.data.array[index + 3] = w2;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array4 = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array4.push(this.data.array[index + j2]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array4), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new _InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array4 = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array4.push(this.data.array[index + j2]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array4,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
};
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
SpriteMaterial.prototype.isSpriteMaterial = true;
var _geometry;
var _intersectPoint = new Vector3();
var _worldScale = new Vector3();
var _mvPosition = new Vector3();
var _alignedPosition = new Vector2();
var _rotatedPosition = new Vector2();
var _viewWorldMatrix = new Matrix4();
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var Sprite = class extends Object3D {
  constructor(material2) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material2 !== void 0 ? material2 : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _v1$2 = new Vector3();
var _v2$1 = new Vector3();
var _basePosition = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _vector$5 = new Vector3();
var _matrix = new Matrix4();
var SkinnedMesh = class extends Mesh {
  constructor(geometry, material2) {
    super(geometry, material2);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  copy(source) {
    super.copy(source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.x = skinWeight.getX(i2);
      vector.y = skinWeight.getY(i2);
      vector.z = skinWeight.getZ(i2);
      vector.w = skinWeight.getW(i2);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  boneTransform(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
};
SkinnedMesh.prototype.isSkinnedMesh = true;
var Bone = class extends Object3D {
  constructor() {
    super();
    this.type = "Bone";
  }
};
Bone.prototype.isBone = true;
var DataTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { data, width, height };
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture.prototype.isDataTexture = true;
var _offsetMatrix = new Matrix4();
var _identityMatrix = new Matrix4();
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
var InstancedMesh = class extends Mesh {
  constructor(geometry, material2, count) {
    super(geometry, material2);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }
  copy(source) {
    super.copy(source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  }
  getColorAt(index, color2) {
    color2.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color2) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color2.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
InstancedMesh.prototype.isInstancedMesh = true;
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
  }
};
LineBasicMaterial.prototype.isLineBasicMaterial = true;
var _start$1 = new Vector3();
var _end$1 = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$1 = new Sphere();
var Line = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material2 = new LineBasicMaterial()) {
    super();
    this.type = "Line";
    this.geometry = geometry;
    this.material = material2;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
          _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
          _end$1.fromBufferAttribute(positionAttribute, i2);
          lineDistances[i2] = lineDistances[i2 - 1];
          lineDistances[i2] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          const a2 = index.getX(i2);
          const b2 = index.getX(i2 + 1);
          vStart.fromBufferAttribute(positionAttribute, a2);
          vEnd.fromBufferAttribute(positionAttribute, b2);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects2.push({
            distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          vStart.fromBufferAttribute(positionAttribute, i2);
          vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects2.push({
            distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
};
Line.prototype.isLine = true;
var _start = new Vector3();
var _end = new Vector3();
var LineSegments = class extends Line {
  constructor(geometry, material2) {
    super(geometry, material2);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
          _start.fromBufferAttribute(positionAttribute, i2);
          _end.fromBufferAttribute(positionAttribute, i2 + 1);
          lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
          lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
};
LineSegments.prototype.isLineSegments = true;
var LineLoop = class extends Line {
  constructor(geometry, material2) {
    super(geometry, material2);
    this.type = "LineLoop";
  }
};
LineLoop.prototype.isLineLoop = true;
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
PointsMaterial.prototype.isPointsMaterial = true;
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();
var _position$2 = new Vector3();
var Points = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material2 = new PointsMaterial()) {
    super();
    this.type = "Points";
    this.geometry = geometry;
    this.material = material2;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2++) {
          const a2 = index.getX(i2);
          _position$2.fromBufferAttribute(positionAttribute, a2);
          testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end; i2 < l2; i2++) {
          _position$2.fromBufferAttribute(positionAttribute, i2);
          testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
};
Points.prototype.isPoints = true;
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object4) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object: object4
    });
  }
}
var VideoTexture = class extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
VideoTexture.prototype.isVideoTexture = true;
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
CompressedTexture.prototype.isCompressedTexture = true;
var CanvasTexture = class extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
};
CanvasTexture.prototype.isCanvasTexture = true;
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
DepthTexture.prototype.isDepthTexture = true;
var CircleGeometry = class _CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s2 = 0, i2 = 3; s2 <= segments; s2++, i2 += 3) {
      const segment = thetaStart + s2 / segments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i2] / radius + 1) / 2;
      uv.y = (vertices[i2 + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i2 = 1; i2 <= segments; i2++) {
      indices.push(i2, i2 + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new _CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
};
var CylinderGeometry = class _CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y2 = 0; y2 <= heightSegments; y2++) {
        const indexRow = [];
        const v2 = y2 / heightSegments;
        const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
        for (let x2 = 0; x2 <= radialSegments; x2++) {
          const u2 = x2 / radialSegments;
          const theta = u2 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v2 * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u2, 1 - v2);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        for (let y2 = 0; y2 < heightSegments; y2++) {
          const a2 = indexArray[y2][x2];
          const b2 = indexArray[y2 + 1][x2];
          const c2 = indexArray[y2 + 1][x2 + 1];
          const d2 = indexArray[y2][x2 + 1];
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x2 = 1; x2 <= radialSegments; x2++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x2 = 0; x2 <= radialSegments; x2++) {
        const u2 = x2 / radialSegments;
        const theta = u2 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign2;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        const c2 = centerIndexStart + x2;
        const i2 = centerIndexEnd + x2;
        if (top === true) {
          indices.push(i2, i2 + 1, c2);
        } else {
          indices.push(i2 + 1, i2, c2);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  static fromJSON(data) {
    return new _CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var ConeGeometry = class _ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new _ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var PolyhedronGeometry = class _PolyhedronGeometry extends BufferGeometry {
  constructor(vertices, indices, radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      for (let i2 = 0; i2 < indices.length; i2 += 3) {
        getVertexByIndex(indices[i2 + 0], a2);
        getVertexByIndex(indices[i2 + 1], b2);
        getVertexByIndex(indices[i2 + 2], c2);
        subdivideFace(a2, b2, c2, detail2);
      }
    }
    function subdivideFace(a2, b2, c2, detail2) {
      const cols = detail2 + 1;
      const v2 = [];
      for (let i2 = 0; i2 <= cols; i2++) {
        v2[i2] = [];
        const aj = a2.clone().lerp(c2, i2 / cols);
        const bj = b2.clone().lerp(c2, i2 / cols);
        const rows = cols - i2;
        for (let j2 = 0; j2 <= rows; j2++) {
          if (j2 === 0 && i2 === cols) {
            v2[i2][j2] = aj;
          } else {
            v2[i2][j2] = aj.clone().lerp(bj, j2 / rows);
          }
        }
      }
      for (let i2 = 0; i2 < cols; i2++) {
        for (let j2 = 0; j2 < 2 * (cols - i2) - 1; j2++) {
          const k2 = Math.floor(j2 / 2);
          if (j2 % 2 === 0) {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
            pushVertex(v2[i2][k2]);
          } else {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex.x = vertexBuffer[i2 + 0];
        vertex.y = vertexBuffer[i2 + 1];
        vertex.z = vertexBuffer[i2 + 2];
        vertex.normalize().multiplyScalar(radius2);
        vertexBuffer[i2 + 0] = vertex.x;
        vertexBuffer[i2 + 1] = vertex.y;
        vertexBuffer[i2 + 2] = vertex.z;
      }
    }
    function generateUVs() {
      const vertex = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex.x = vertexBuffer[i2 + 0];
        vertex.y = vertexBuffer[i2 + 1];
        vertex.z = vertexBuffer[i2 + 2];
        const u2 = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v2 = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u2, 1 - v2);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
        const x0 = uvBuffer[i2 + 0];
        const x1 = uvBuffer[i2 + 2];
        const x2 = uvBuffer[i2 + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i2 + 0] += 1;
          if (x1 < 0.2) uvBuffer[i2 + 2] += 1;
          if (x2 < 0.2) uvBuffer[i2 + 4] += 1;
        }
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i2 = 0, j2 = 0; i2 < vertexBuffer.length; i2 += 9, j2 += 6) {
        a2.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
        b2.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
        c2.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
        uvA.set(uvBuffer[j2 + 0], uvBuffer[j2 + 1]);
        uvB.set(uvBuffer[j2 + 2], uvBuffer[j2 + 3]);
        uvC.set(uvBuffer[j2 + 4], uvBuffer[j2 + 5]);
        centroid.copy(a2).add(b2).add(c2).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j2 + 0, a2, azi);
        correctUV(uvB, j2 + 2, b2, azi);
        correctUV(uvC, j2 + 4, c2, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  static fromJSON(data) {
    return new _PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
};
var DodecahedronGeometry = class _DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const r2 = 1 / t2;
    const vertices = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      // (1/, , 0)
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      0,
      // (, 0, 1/)
      -t2,
      0,
      -r2,
      t2,
      0,
      -r2,
      -t2,
      0,
      r2,
      t2,
      0,
      r2
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _DodecahedronGeometry(data.radius, data.detail);
  }
};
var _v0 = new Vector3();
var _v1$1 = new Vector3();
var _normal = new Vector3();
var _triangle = new Triangle();
var EdgesGeometry = class extends BufferGeometry {
  constructor(geometry, thresholdAngle) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      thresholdAngle
    };
    thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
    if (geometry.isGeometry === true) {
      console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
    const indexAttr = geometry.getIndex();
    const positionAttr = geometry.getAttribute("position");
    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
    const indexArr = [0, 0, 0];
    const vertKeys = ["a", "b", "c"];
    const hashes = new Array(3);
    const edgeData = {};
    const vertices = [];
    for (let i2 = 0; i2 < indexCount; i2 += 3) {
      if (indexAttr) {
        indexArr[0] = indexAttr.getX(i2);
        indexArr[1] = indexAttr.getX(i2 + 1);
        indexArr[2] = indexAttr.getX(i2 + 2);
      } else {
        indexArr[0] = i2;
        indexArr[1] = i2 + 1;
        indexArr[2] = i2 + 2;
      }
      const { a: a2, b: b2, c: c2 } = _triangle;
      a2.fromBufferAttribute(positionAttr, indexArr[0]);
      b2.fromBufferAttribute(positionAttr, indexArr[1]);
      c2.fromBufferAttribute(positionAttr, indexArr[2]);
      _triangle.getNormal(_normal);
      hashes[0] = `${a2.x},${a2.y},${a2.z}`;
      hashes[1] = `${b2.x},${b2.y},${b2.z}`;
      hashes[2] = `${c2.x},${c2.y},${c2.z}`;
      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
        continue;
      }
      for (let j2 = 0; j2 < 3; j2++) {
        const jNext = (j2 + 1) % 3;
        const vecHash0 = hashes[j2];
        const vecHash1 = hashes[jNext];
        const v0 = _triangle[vertKeys[j2]];
        const v1 = _triangle[vertKeys[jNext]];
        const hash = `${vecHash0}_${vecHash1}`;
        const reverseHash = `${vecHash1}_${vecHash0}`;
        if (reverseHash in edgeData && edgeData[reverseHash]) {
          if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
            vertices.push(v0.x, v0.y, v0.z);
            vertices.push(v1.x, v1.y, v1.z);
          }
          edgeData[reverseHash] = null;
        } else if (!(hash in edgeData)) {
          edgeData[hash] = {
            index0: indexArr[j2],
            index1: indexArr[jNext],
            normal: _normal.clone()
          };
        }
      }
    }
    for (const key in edgeData) {
      if (edgeData[key]) {
        const { index0, index1 } = edgeData[key];
        _v0.fromBufferAttribute(positionAttr, index0);
        _v1$1.fromBufferAttribute(positionAttr, index1);
        vertices.push(_v0.x, _v0.y, _v0.z);
        vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
      }
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
};
var Curve = class {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current2, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p2 = 1; p2 <= divisions; p2++) {
      current2 = this.getPoint(p2 / divisions);
      sum += current2.distanceTo(last);
      cache.push(sum);
      last = current2;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u2, distance) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i2 + segmentFraction) / (il - 1);
    return t2;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0) t1 = 0;
    if (t22 > 1) t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector3());
      tangents[i2].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
};
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0) deltaAngle += twoPi;
    while (deltaAngle > twoPi) deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x2 = this.aX + this.xRadius * Math.cos(angle);
    let y2 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x2 - this.aX;
      const ty = y2 - this.aY;
      x2 = tx * cos - ty * sin + this.aX;
      y2 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x2, y2);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
EllipseCurve.prototype.isEllipseCurve = true;
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
};
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init2(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init2(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init2(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l2 = points.length;
    const p2 = (l2 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p2);
    let weight = p2 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    } else if (weight === 0 && intPoint === l2 - 1) {
      intPoint = l2 - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l2];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l2];
    const p22 = points[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) {
      p3 = points[(intPoint + 2) % l2];
    } else {
      tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
      if (dt1 < 1e-4) dt1 = 1;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
    }
    point.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t2, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * p2;
}
function QuadraticBezierP1(t2, p2) {
  return 2 * (1 - t2) * t2 * p2;
}
function QuadraticBezierP2(t2, p2) {
  return t2 * t2 * p2;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * k2 * p2;
}
function CubicBezierP1(t2, p2) {
  const k2 = 1 - t2;
  return 3 * k2 * k2 * t2 * p2;
}
function CubicBezierP2(t2, p2) {
  return 3 * (1 - t2) * t2 * t2 * p2;
}
function CubicBezierP3(t2, p2) {
  return t2 * t2 * t2 * p2;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t2, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t2, v0.y, v1.y, v2.y, v3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve.prototype.isCubicBezierCurve = true;
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t2, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t2, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t2, v0.z, v1.z, v2.z, v3.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
var LineCurve = class extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
LineCurve.prototype.isLineCurve = true;
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t2, v0.x, v1.x, v2.x),
      QuadraticBezier(t2, v0.y, v1.y, v2.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t2, v0.x, v1.x, v2.x),
      QuadraticBezier(t2, v0.y, v1.y, v2.y),
      QuadraticBezier(t2, v0.z, v1.z, v2.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p2 = (points.length - 1) * t2;
    const intPoint = Math.floor(p2);
    const weight = p2 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p1.x, p22.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p22.y, p3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
};
SplineCurve.prototype.isSplineCurve = true;
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x2, y2, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x2 = data[i2];
        y2 = data[i2 + 1];
        if (x2 < minX) minX = x2;
        if (y2 < minY) minY = y2;
        if (x2 > maxX) maxX = x2;
        if (y2 > maxY) maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next) break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  let p2 = ear.next.next;
  while (p2 !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p2.i / dim);
      triangles.push(b2.i / dim);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue2 = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue2.push(getLeftmost(list));
  }
  queue2.sort(compareX);
  for (i2 = 0; i2 < queue2.length; i2++) {
    eliminateHole(queue2[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b2 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b2, b2.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p2.y) return p2;
          if (hy === p2.next.y) return p2.next;
        }
        m2 = p2.x < p2.next.x ? p2 : p2.next;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2) return null;
  if (hx === qx) return m2;
  const stop = m2, mx = m2.x, my = m2.y;
  let tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === null) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e2;
        else list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
  (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
  (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
  equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2, inside = false;
  const px2 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an2 = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an2;
  an2.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  const p2 = new Node(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
}
function Node(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
var ShapeUtils = class _ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n2 = contour.length;
    let a2 = 0;
    for (let p2 = n2 - 1, q2 = 0; q2 < n2; p2 = q2++) {
      a2 += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
    }
    return a2 * 0.5;
  }
  static isClockWise(pts) {
    return _ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
var ExtrudeGeometry = class _ExtrudeGeometry extends BufferGeometry {
  constructor(shapes, options2) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options: options2
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
      const steps = options2.steps !== void 0 ? options2.steps : 1;
      let depth = options2.depth !== void 0 ? options2.depth : 100;
      let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
      let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 6;
      let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 2;
      let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
      let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
      const extrudePath = options2.extrudePath;
      const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
      if (options2.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options2.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i2 = 0, il = contour.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
        if (j2 === il) j2 = 0;
        if (k2 === il) k2 = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k2]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i2 = 0, il = ahole.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
          if (j2 === il) j2 = 0;
          if (k2 === il) k2 = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k2]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b2 = 0; b2 < bevelSegments; b2++) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, -z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            v2(vert.x, vert.y, -z2);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, depth + z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth + z2);
            } else {
              v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2], face[1], face[0]);
          }
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i2 = contour2.length;
        while (--i2 >= 0) {
          const j2 = i2;
          let k2 = i2 - 1;
          if (k2 < 0) k2 = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a2 = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c2 = layeroffset + k2 + slen2, d2 = layeroffset + j2 + slen2;
            f4(a2, b2, c2, d2);
          }
        }
      }
      function v2(x2, y2, z2) {
        placeholder.push(x2);
        placeholder.push(y2);
        placeholder.push(z2);
      }
      function f3(a2, b2, c2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(c2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a2, b2, c2, d2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(d2);
        addVertex(b2);
        addVertex(c2);
        addVertex(d2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options2 = this.parameters.options;
    return toJSON$1(shapes, options2, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new _ExtrudeGeometry(geometryShapes, data.options);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options2, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options2.extrudePath !== void 0) data.options.extrudePath = options2.extrudePath.toJSON();
  return data;
}
var IcosahedronGeometry = class _IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      0,
      0,
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      t2,
      0,
      -1,
      t2,
      0,
      1,
      -t2,
      0,
      -1,
      -t2,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _IcosahedronGeometry(data.radius, data.detail);
  }
};
var LatheGeometry = class _LatheGeometry extends BufferGeometry {
  constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const inverseSegments = 1 / segments;
    const vertex = new Vector3();
    const uv = new Vector2();
    for (let i2 = 0; i2 <= segments; i2++) {
      const phi = phiStart + i2 * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j2 = 0; j2 <= points.length - 1; j2++) {
        vertex.x = points[j2].x * sin;
        vertex.y = points[j2].y;
        vertex.z = points[j2].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);
        uv.x = i2 / segments;
        uv.y = j2 / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }
    for (let i2 = 0; i2 < segments; i2++) {
      for (let j2 = 0; j2 < points.length - 1; j2++) {
        const base = j2 + i2 * points.length;
        const a2 = base;
        const b2 = base + points.length;
        const c2 = base + points.length + 1;
        const d2 = base + 1;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.computeVertexNormals();
    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n3 = new Vector3();
      const base = segments * points.length * 3;
      for (let i2 = 0, j2 = 0; i2 < points.length; i2++, j2 += 3) {
        n1.x = normals[j2 + 0];
        n1.y = normals[j2 + 1];
        n1.z = normals[j2 + 2];
        n2.x = normals[base + j2 + 0];
        n2.y = normals[base + j2 + 1];
        n2.z = normals[base + j2 + 2];
        n3.addVectors(n1, n2).normalize();
        normals[j2 + 0] = normals[base + j2 + 0] = n3.x;
        normals[j2 + 1] = normals[base + j2 + 1] = n3.y;
        normals[j2 + 2] = normals[base + j2 + 2] = n3.z;
      }
    }
  }
  static fromJSON(data) {
    return new _LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
};
var OctahedronGeometry = class _OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _OctahedronGeometry(data.radius, data.detail);
  }
};
var ParametricGeometry = class extends BufferGeometry {
  constructor(func3, slices, stacks) {
    super();
    this.type = "ParametricGeometry";
    this.parameters = {
      func: func3,
      slices,
      stacks
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 1e-5;
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    if (func3.length < 3) {
      console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    }
    const sliceCount = slices + 1;
    for (let i2 = 0; i2 <= stacks; i2++) {
      const v2 = i2 / stacks;
      for (let j2 = 0; j2 <= slices; j2++) {
        const u2 = j2 / slices;
        func3(u2, v2, p0);
        vertices.push(p0.x, p0.y, p0.z);
        if (u2 - EPS >= 0) {
          func3(u2 - EPS, v2, p1);
          pu.subVectors(p0, p1);
        } else {
          func3(u2 + EPS, v2, p1);
          pu.subVectors(p1, p0);
        }
        if (v2 - EPS >= 0) {
          func3(u2, v2 - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func3(u2, v2 + EPS, p1);
          pv.subVectors(p1, p0);
        }
        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2, v2);
      }
    }
    for (let i2 = 0; i2 < stacks; i2++) {
      for (let j2 = 0; j2 < slices; j2++) {
        const a2 = i2 * sliceCount + j2;
        const b2 = i2 * sliceCount + j2 + 1;
        const c2 = (i2 + 1) * sliceCount + j2 + 1;
        const d2 = (i2 + 1) * sliceCount + j2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var RingGeometry = class _RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector3();
    const uv = new Vector2();
    for (let j2 = 0; j2 <= phiSegments; j2++) {
      for (let i2 = 0; i2 <= thetaSegments; i2++) {
        const segment = thetaStart + i2 / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j2 = 0; j2 < phiSegments; j2++) {
      const thetaSegmentLevel = j2 * (thetaSegments + 1);
      for (let i2 = 0; i2 < thetaSegments; i2++) {
        const segment = i2 + thetaSegmentLevel;
        const a2 = segment;
        const b2 = segment + thetaSegments + 1;
        const c2 = segment + thetaSegments + 2;
        const d2 = segment + 1;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new _RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
};
var ShapeGeometry = class _ShapeGeometry extends BufferGeometry {
  constructor(shapes, curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i2 = 0; i2 < shapes.length; i2++) {
        addShape(shapes[i2]);
        this.addGroup(groupStart, groupCount, i2);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
        const vertex = shapeVertices[i2];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }
      for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
        const face = faces[i2];
        const a2 = face[0] + indexOffset;
        const b2 = face[1] + indexOffset;
        const c2 = face[2] + indexOffset;
        indices.push(a2, b2, c2);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    return new _ShapeGeometry(geometryShapes, data.curveSegments);
  }
};
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var SphereGeometry = class _SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v2 = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a2 = grid[iy][ix + 1];
        const b2 = grid[iy][ix];
        const c2 = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a2, b2, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new _SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
};
var TetrahedronGeometry = class _TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _TetrahedronGeometry(data.radius, data.detail);
  }
};
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (!(font && font.isFont)) {
      console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
      return new BufferGeometry();
    }
    const shapes = font.generateShapes(text, parameters.size);
    parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
    if (parameters.bevelThickness === void 0) parameters.bevelThickness = 10;
    if (parameters.bevelSize === void 0) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === void 0) parameters.bevelEnabled = false;
    super(shapes, parameters);
    this.type = "TextGeometry";
  }
};
var TorusGeometry = class _TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3();
    for (let j2 = 0; j2 <= radialSegments; j2++) {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        const u2 = i2 / tubularSegments * arc;
        const v2 = j2 / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v2)) * Math.cos(u2);
        vertex.y = (radius + tube * Math.cos(v2)) * Math.sin(u2);
        vertex.z = tube * Math.sin(v2);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center.x = radius * Math.cos(u2);
        center.y = radius * Math.sin(u2);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= radialSegments; j2++) {
      for (let i2 = 1; i2 <= tubularSegments; i2++) {
        const a2 = (tubularSegments + 1) * j2 + i2 - 1;
        const b2 = (tubularSegments + 1) * (j2 - 1) + i2 - 1;
        const c2 = (tubularSegments + 1) * (j2 - 1) + i2;
        const d2 = (tubularSegments + 1) * j2 + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new _TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
};
var TorusKnotGeometry = class _TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p2 = 2, q2 = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p2,
      q: q2
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B2 = new Vector3();
    const T = new Vector3();
    const N2 = new Vector3();
    for (let i2 = 0; i2 <= tubularSegments; ++i2) {
      const u2 = i2 / tubularSegments * p2 * Math.PI * 2;
      calculatePositionOnCurve(u2, p2, q2, radius, P1);
      calculatePositionOnCurve(u2 + 0.01, p2, q2, radius, P2);
      T.subVectors(P2, P1);
      N2.addVectors(P2, P1);
      B2.crossVectors(T, N2);
      N2.crossVectors(B2, T);
      B2.normalize();
      N2.normalize();
      for (let j2 = 0; j2 <= radialSegments; ++j2) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v2);
        const cy = tube * Math.sin(v2);
        vertex.x = P1.x + (cx * N2.x + cy * B2.x);
        vertex.y = P1.y + (cx * N2.y + cy * B2.y);
        vertex.z = P1.z + (cx * N2.z + cy * B2.z);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= tubularSegments; j2++) {
      for (let i2 = 1; i2 <= radialSegments; i2++) {
        const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
        const b2 = (radialSegments + 1) * j2 + (i2 - 1);
        const c2 = (radialSegments + 1) * j2 + i2;
        const d2 = (radialSegments + 1) * (j2 - 1) + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u2, p3, q3, radius2, position) {
      const cu = Math.cos(u2);
      const su = Math.sin(u2);
      const quOverP = q3 / p3 * u2;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  static fromJSON(data) {
    return new _TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
};
var TubeGeometry = class _TubeGeometry extends BufferGeometry {
  constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P2 = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i2 = 0; i2 < tubularSegments; i2++) {
        generateSegment(i2);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i2) {
      P2 = path.getPointAt(i2 / tubularSegments, P2);
      const N2 = frames.normals[i2];
      const B2 = frames.binormals[i2];
      for (let j2 = 0; j2 <= radialSegments; j2++) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const sin = Math.sin(v2);
        const cos = -Math.cos(v2);
        normal.x = cos * N2.x + sin * B2.x;
        normal.y = cos * N2.y + sin * B2.y;
        normal.z = cos * N2.z + sin * B2.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex.x = P2.x + radius * normal.x;
        vertex.y = P2.y + radius * normal.y;
        vertex.z = P2.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    function generateIndices() {
      for (let j2 = 1; j2 <= tubularSegments; j2++) {
        for (let i2 = 1; i2 <= radialSegments; i2++) {
          const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
          const b2 = (radialSegments + 1) * j2 + (i2 - 1);
          const c2 = (radialSegments + 1) * j2 + i2;
          const d2 = (radialSegments + 1) * (j2 - 1) + i2;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
        }
      }
    }
    function generateUVs() {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        for (let j2 = 0; j2 <= radialSegments; j2++) {
          uv.x = i2 / tubularSegments;
          uv.y = j2 / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new _TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed
    );
  }
};
var WireframeGeometry = class extends BufferGeometry {
  constructor(geometry) {
    super();
    this.type = "WireframeGeometry";
    if (geometry.isGeometry === true) {
      console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const vertices = [];
    const edges = /* @__PURE__ */ new Set();
    const start = new Vector3();
    const end = new Vector3();
    if (geometry.index !== null) {
      const position = geometry.attributes.position;
      const indices = geometry.index;
      let groups2 = geometry.groups;
      if (groups2.length === 0) {
        groups2 = [{ start: 0, count: indices.count, materialIndex: 0 }];
      }
      for (let o2 = 0, ol = groups2.length; o2 < ol; ++o2) {
        const group = groups2[o2];
        const groupStart = group.start;
        const groupCount = group.count;
        for (let i2 = groupStart, l2 = groupStart + groupCount; i2 < l2; i2 += 3) {
          for (let j2 = 0; j2 < 3; j2++) {
            const index1 = indices.getX(i2 + j2);
            const index2 = indices.getX(i2 + (j2 + 1) % 3);
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
    } else {
      const position = geometry.attributes.position;
      for (let i2 = 0, l2 = position.count / 3; i2 < l2; i2++) {
        for (let j2 = 0; j2 < 3; j2++) {
          const index1 = 3 * i2 + j2;
          const index2 = 3 * i2 + (j2 + 1) % 3;
          start.fromBufferAttribute(position, index1);
          end.fromBufferAttribute(position, index2);
          if (isUniqueEdge(start, end, edges) === true) {
            vertices.push(start.x, start.y, start.z);
            vertices.push(end.x, end.y, end.z);
          }
        }
      }
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
};
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1, hash2);
    return true;
  }
}
var Geometries = Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  ParametricGeometry,
  ParametricBufferGeometry: ParametricGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TextGeometry,
  TextBufferGeometry: TextGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry
});
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
};
ShadowMaterial.prototype.isShadowMaterial = true;
var MeshStandardMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
var MeshPhysicalMaterial = class extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoat = 0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5;
    Object.defineProperty(this, "ior", {
      get: function() {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      },
      set: function(ior) {
        this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
      }
    });
    this.sheen = null;
    this.transmission = 0;
    this.transmissionMap = null;
    this.thickness = 0.01;
    this.thicknessMap = null;
    this.attenuationDistance = 0;
    this.attenuationTint = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularTint = new Color(1, 1, 1);
    this.specularTintMap = null;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;
    if (source.sheen) {
      this.sheen = (this.sheen || new Color()).copy(source.sheen);
    } else {
      this.sheen = null;
    }
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationTint.copy(source.attenuationTint);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularTint.copy(source.specularTint);
    this.specularTintMap = source.specularTintMap;
    return this;
  }
};
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
var MeshPhongMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshToonMaterial.prototype.isMeshToonMaterial = true;
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
};
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var Materials = Object.freeze({
  __proto__: null,
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
var AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(array4, from, to) {
    if (AnimationUtils.isTypedArray(array4)) {
      return new array4.constructor(array4.subarray(from, to !== void 0 ? to : array4.length));
    }
    return array4.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function(array4, type, forceClone) {
    if (!array4 || // let 'undefined' and 'null' pass
    !forceClone && array4.constructor === type) return array4;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array4);
    }
    return Array.prototype.slice.call(array4);
  },
  isTypedArray: function(object4) {
    return ArrayBuffer.isView(object4) && !(object4 instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(times) {
    function compareTime(i2, j2) {
      return times[i2] - times[j2];
    }
    const n2 = times.length;
    const result = new Array(n2);
    for (let i2 = 0; i2 !== n2; ++i2) result[i2] = i2;
    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
      const srcOffset = order[i2] * stride;
      for (let j2 = 0; j2 !== stride; ++j2) {
        result[dstOffset++] = values[srcOffset + j2];
      }
    }
    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i2 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i2++];
    }
    if (key === void 0) return;
    let value = key[valuePropertyName];
    if (value === void 0) return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name2, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name2;
    const tracks = [];
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      const track = clip.tracks[i2];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j2 = 0; j2 < track.times.length; ++j2) {
        const frame = track.times[j2] * fps;
        if (frame < startFrame || frame >= endFrame) continue;
        times.push(track.times[j2]);
        for (let k2 = 0; k2 < valueSize; ++k2) {
          values.push(track.values[j2 * valueSize + k2]);
        }
      }
      if (times.length === 0) continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      if (minStartTime > clip.tracks[i2].times[0]) {
        minStartTime = clip.tracks[i2].times[0];
      }
    }
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      clip.tracks[i2].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0) fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i2 = 0; i2 < numTracks; ++i2) {
      const referenceTrack = referenceClip.tracks[i2];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string") continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0) continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j2 = 0; j2 < numTimes; ++j2) {
        const valueStart = j2 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(
            targetTrack.values,
            valueStart,
            referenceValue,
            0,
            targetTrack.values,
            valueStart
          );
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k2 = 0; k2 < valueEnd; ++k2) {
            targetTrack.values[valueStart + k2] -= referenceValue[k2];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
var Interpolant = class {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t2 < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t2 < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t2, t0);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t2 < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t2, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t2);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
var CubicInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    const sP = -wP * ppp + 2 * wP * pp - wP * p2;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
};
var LinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
};
var KeyframeTrack = class {
  constructor(name2, times, values, interpolation) {
    if (name2 === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
    this.name = name2;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values[offset + j2];
            if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values[writeOffset + j2] = values[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name2, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name2;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push(
        (i2 + numMorphTargets - 1) % numMorphTargets,
        i2,
        (i2 + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i2].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name2, -1, tracks);
  }
  static findByName(objectOrClipArray, name2) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name2) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern2 = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern2);
      if (parts && parts.length > 1) {
        const name2 = parts[1];
        let animationMorphTargets = animationToMorphTargets[name2];
        if (!animationMorphTargets) {
          animationToMorphTargets[name2] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name2 in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name2, animationToMorphTargets[name2], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
var LoadingManager = class {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
};
var DefaultLoadingManager = new LoadingManager();
var Loader = class {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
};
var loading = {};
var FileLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data.length);
            for (let i2 = 0; i2 < data.length; i2++) {
              view[i2] = data.charCodeAt(i2);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], { type: mimeType });
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser2 = new DOMParser();
            response = parser2.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0) console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onLoad) callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError) callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks = loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onError) callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onError) callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0) request.responseType = this.responseType;
      if (this.withCredentials !== void 0) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
};
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image) {
        texture.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  }
};
var TextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
};
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t2) {
    const d2 = t2 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d2) {
        const diff = curveLengths[i2] - d2;
        const curve = this.curves[i2];
        const segmentLength = curve.getLength();
        const u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u2);
      }
      i2++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
      const curve = curves[i2];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j2 = 0; j2 < pts.length; j2++) {
        const point = pts[j2];
        if (last && last.equals(point)) continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
      const curve = source.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      const curve = this.curves[i2];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
      const curve = json.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
    return this;
  }
  moveTo(x2, y2) {
    this.currentPoint.set(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y2));
    this.curves.push(curve);
    this.currentPoint.set(x2, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
      const hole = source.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      const hole = this.holes[i2];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
      const hole = json.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Light = class extends Object3D {
  constructor(color2, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color2);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    return data;
  }
};
Light.prototype.isLight = true;
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
HemisphereLight.prototype.isHemisphereLight = true;
var _projScreenMatrix$1 = new Matrix4();
var _lightPositionWorld$1 = new Vector3();
var _lookTarget$1 = new Vector3();
var LightShadow = class {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object4 = {};
    if (this.bias !== 0) object4.bias = this.bias;
    if (this.normalBias !== 0) object4.normalBias = this.normalBias;
    if (this.radius !== 1) object4.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object4.mapSize = this.mapSize.toArray();
    object4.camera = this.camera.toJSON(false).object;
    delete object4.camera.matrix;
    return object4;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
};
SpotLightShadow.prototype.isSpotLightShadow = true;
var SpotLight = class extends Light {
  constructor(color2, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color2, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
SpotLight.prototype.isSpotLight = true;
var _projScreenMatrix = new Matrix4();
var _lightPositionWorld = new Vector3();
var _lookTarget = new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
};
PointLightShadow.prototype.isPointLightShadow = true;
var PointLight = class extends Light {
  constructor(color2, intensity, distance = 0, decay = 1) {
    super(color2, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
PointLight.prototype.isPointLight = true;
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
};
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
var DirectionalLight = class extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
DirectionalLight.prototype.isDirectionalLight = true;
var AmbientLight = class extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.type = "AmbientLight";
  }
};
AmbientLight.prototype.isAmbientLight = true;
var RectAreaLight = class extends Light {
  constructor(color2, intensity, width = 10, height = 10) {
    super(color2, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
};
RectAreaLight.prototype.isRectAreaLight = true;
var SphericalHarmonics3 = class {
  constructor() {
    this.coefficients = [];
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  }
  zero() {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z2);
    target.addScaledVector(coeff[3], 0.488603 * x2);
    target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));
    target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));
    return target;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
    target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);
    target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));
    return target;
  }
  add(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh.coefficients[i2]);
    }
    return this;
  }
  addScaledSH(sh, s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].addScaledVector(sh.coefficients[i2], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array4, offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array4, offset + i2 * 3);
    }
    return this;
  }
  toArray(array4 = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array4, offset + i2 * 3);
    }
    return array4;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal, shBasis) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x2;
    shBasis[4] = 1.092548 * x2 * y2;
    shBasis[5] = 1.092548 * y2 * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x2 * z2;
    shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);
  }
};
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
};
LightProbe.prototype.isLightProbe = true;
var LoaderUtils = class {
  static decodeText(array4) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array4);
    }
    let s2 = "";
    for (let i2 = 0, il = array4.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array4[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1) return "./";
    return url.substr(0, index + 1);
  }
};
var InstancedBufferGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
};
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
var InstancedBufferAttribute = class extends BufferAttribute {
  constructor(array4, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    super(array4, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
};
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
var ImageBitmapLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options2) {
    this.options = options2;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e2) {
      if (onError) onError(e2);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
};
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
var ShapePath = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x2, y2) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    this.currentPath.lineTo(x2, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
        const tmpPath2 = inSubpaths[i2];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p2 = polyLen - 1, q2 = 0; q2 < polyLen; p2 = q2++) {
        let edgeLowPt = inPolygon[p2];
        let edgeHighPt = inPolygon[q2];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q2];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p2];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true;
            if (perpEdge < 0) continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y) continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i2 = 0, l2 = subPaths.length; i2 < l2; i2++) {
      tmpPath = subPaths[i2];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
      }
    }
    if (!newShapes[0]) return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
      tmpShape = newShapes[i2].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i2];
      for (let j2 = 0, jl = tmpHoles.length; j2 < jl; j2++) {
        tmpShape.holes.push(tmpHoles[j2].h);
      }
    }
    return shapes;
  }
};
var Font = class {
  constructor(data) {
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p2 = 0, pl = paths.length; p2 < pl; p2++) {
      Array.prototype.push.apply(shapes, paths[p2].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i2 = 0; i2 < chars.length; i2++) {
    const char = chars[i2];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x2, y2, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i2 = 0, l2 = outline.length; i2 < l2; ) {
      const action = outline[i2++];
      switch (action) {
        case "m":
          x2 = outline[i2++] * scale + offsetX;
          y2 = outline[i2++] * scale + offsetY;
          path.moveTo(x2, y2);
          break;
        case "l":
          x2 = outline[i2++] * scale + offsetX;
          y2 = outline[i2++] * scale + offsetY;
          path.lineTo(x2, y2);
          break;
        case "q":
          cpx = outline[i2++] * scale + offsetX;
          cpy = outline[i2++] * scale + offsetY;
          cpx1 = outline[i2++] * scale + offsetX;
          cpy1 = outline[i2++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i2++] * scale + offsetX;
          cpy = outline[i2++] * scale + offsetY;
          cpx1 = outline[i2++] * scale + offsetX;
          cpy1 = outline[i2++] * scale + offsetY;
          cpx2 = outline[i2++] * scale + offsetX;
          cpy2 = outline[i2++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}
Font.prototype.isFont = true;
var _context;
var AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer3) {
      try {
        const bufferCopy = buffer3.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
};
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
var AmbientLightProbe = class extends LightProbe {
  constructor(color2, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color2);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
AmbientLightProbe.prototype.isAmbientLightProbe = true;
var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();
var StereoCamera = class {
  constructor() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(camera) {
    const cache = this._cache;
    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep;
      const projectionMatrix = camera.projectionMatrix.clone();
      const eyeSepHalf = cache.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
      const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
      let xmin, xmax;
      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;
      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix);
      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
};
var _position$1 = new Vector3();
var _quaternion$1 = new Quaternion();
var _scale$1 = new Vector3();
var _orientation$1 = new Vector3();
var Audio = class extends Object3D {
  constructor(listener2) {
    super();
    this.type = "Audio";
    this.listener = listener2;
    this.context = listener2.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener2.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay) this.play();
    return this;
  }
  play(delay2 = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay2;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value) value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0) return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter2) {
    return this.setFilters(filter2 ? [filter2] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
var _position = new Vector3();
var _quaternion = new Quaternion();
var _scale = new Vector3();
var _orientation = new Vector3();
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i2 = 0; i2 < data.length; i2++) {
      value += data[i2];
    }
    return value / data.length;
  }
};
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(accuIndex, weight) {
    const buffer3 = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer3[offset + i2] = buffer3[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer3, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(weight) {
    const buffer3 = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer3, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(accuIndex) {
    const stride = this.valueSize, buffer3 = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(
        buffer3,
        offset,
        originalValueOffset,
        1 - weight,
        stride
      );
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer3, offset, this._addIndex * stride, 1, stride);
    }
    for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
      if (buffer3[i2] !== buffer3[i2 + stride]) {
        binding.setValue(buffer3, offset);
        break;
      }
    }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const binding = this.binding;
    const buffer3 = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer3, originalValueOffset);
    for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
      buffer3[i2] = buffer3[originalValueOffset + i2 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      this.buffer[i2] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) {
      this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
    }
  }
  // mix functions
  _select(buffer3, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer3[dstOffset + i2] = buffer3[srcOffset + i2];
      }
    }
  }
  _slerp(buffer3, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer3, dstOffset, buffer3, dstOffset, buffer3, srcOffset, t2);
  }
  _slerpAdditive(buffer3, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer3, workOffset, buffer3, dstOffset, buffer3, srcOffset);
    Quaternion.slerpFlat(buffer3, dstOffset, buffer3, dstOffset, buffer3, workOffset, t2);
  }
  _lerp(buffer3, dstOffset, srcOffset, t2, stride) {
    const s2 = 1 - t2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer3[j2] = buffer3[j2] * s2 + buffer3[srcOffset + i2] * t2;
    }
  }
  _lerpAdditive(buffer3, dstOffset, srcOffset, t2, stride) {
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer3[j2] = buffer3[j2] + buffer3[srcOffset + i2] * t2;
    }
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
var _supportedObjectNames = ["material", "materials", "bones"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array4, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array4, offset);
  }
  setValue(array4, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array4, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
};
var PropertyBinding = class _PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
    this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new _PropertyBinding(root, path, parsedPath);
    } else {
      return new _PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name2) {
    return name2.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer3, offset) {
    buffer3[offset] = this.node[this.propertyName];
  }
  _getValue_array(buffer3, offset) {
    const source = this.resolvedProperty;
    for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
      buffer3[offset++] = source[i2];
    }
  }
  _getValue_arrayElement(buffer3, offset) {
    buffer3[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer3, offset) {
    this.resolvedProperty.toArray(buffer3, offset);
  }
  // Direct
  _setValue_direct(buffer3, offset) {
    this.targetObject[this.propertyName] = buffer3[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer3, offset) {
    this.targetObject[this.propertyName] = buffer3[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer3, offset) {
    this.targetObject[this.propertyName] = buffer3[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer3, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer3[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer3, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer3[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer3, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer3[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer3, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer3[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer3, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer3[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer3, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer3[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer3, offset) {
    this.resolvedProperty.fromArray(buffer3, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer3, offset) {
    this.resolvedProperty.fromArray(buffer3, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer3, offset) {
    this.resolvedProperty.fromArray(buffer3, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var AnimationObjectGroup = class {
  constructor() {
    this.uuid = generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      indices[arguments[i2].uuid] = i2;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object4 = arguments[i2], uuid = object4.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object4);
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          bindings[j2].push(new PropertyBinding(object4, paths[j2], parsedPaths[j2]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object4;
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object4, paths[j2], parsedPaths[j2]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object4 = arguments[i2], uuid = object4.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object4;
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          const bindingsForPath = bindings[j2], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // remove & forget
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object4 = arguments[i2], uuid = object4.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0) return bindings[index];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i2 = nCachedObjects, n2 = objects.length; i2 !== n2; ++i2) {
      const object4 = objects[i2];
      bindingsForPath[i2] = new PropertyBinding(object4, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
var AnimationAction = class {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const interpolant = tracks[i2].createInterpolant(null);
      interpolants[i2] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  // State & Scheduling
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode2, repetitions) {
    this.loop = mode2;
    this.repetitions = repetitions;
    return this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished) this.paused = true;
        else this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished) this.paused = true;
          else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings2 = this._interpolantSettings;
    if (pingPong) {
      settings2.endingStart = ZeroSlopeEnding;
      settings2.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings2.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings2.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings2.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings2.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
};
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const track = tracks[i2], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(
          PropertyBinding.create(root, trackName, path),
          track.ValueTypeName,
          track.getValueSize()
        );
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0]
        );
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions2 = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions2.length;
    actions2.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions2 = this._actions, lastInactiveAction = actions2[actions2.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions2[cacheIndex] = lastInactiveAction;
    actions2.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
      const binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions2 = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions2[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions2[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions2[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions2 = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions2[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions2[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions2[prevIndex] = lastActiveAction;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        this._controlInterpolantsResultBuffer
      );
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null) return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  // get an existing action
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const actions2 = this._actions, nActions = this._nActiveActions;
    for (let i2 = nActions - 1; i2 >= 0; --i2) {
      actions2[i2].stop();
    }
    return this;
  }
  // advance the time and update apply the animation
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions2 = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i2 = 0; i2 !== nActions; ++i2) {
      const action = actions2[i2];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i2 = 0; i2 < this._actions.length; i2++) {
      this._actions[i2].time = 0;
    }
    return this.update(timeInSeconds);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(clip) {
    const actions2 = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
        const action = actionsToRemove[i2];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions2[actions2.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions2[cacheIndex] = lastInactiveAction;
        actions2.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  // remove a targeted clip from the cache
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class _Uniform {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new _Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
var InstancedInterleavedBuffer = class extends InterleavedBuffer {
  constructor(array4, stride, meshPerAttribute = 1) {
    super(array4, stride);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
};
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
var GLBufferAttribute = class {
  constructor(buffer3, type, itemSize, elementSize, count) {
    this.buffer = buffer3;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setBuffer(buffer3) {
    this.buffer = buffer3;
    return this;
  }
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  setCount(count) {
    this.count = count;
    return this;
  }
};
GLBufferAttribute.prototype.isGLBufferAttribute = true;
var Raycaster = class {
  constructor(origin, direction2, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction2);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction2) {
    this.ray.set(origin, direction2);
  }
  setFromCamera(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  intersectObject(object4, recursive = false, intersects2 = []) {
    intersectObject(object4, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = false, intersects2 = []) {
    for (let i2 = 0, l2 = objects.length; i2 < l2; i2++) {
      intersectObject(objects[i2], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
};
function ascSort(a2, b2) {
  return a2.distance - b2.distance;
}
function intersectObject(object4, raycaster, intersects2, recursive) {
  if (object4.layers.test(raycaster.layers)) {
    object4.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object4.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      intersectObject(children[i2], raycaster, intersects2, true);
    }
  }
}
var _vector$4 = new Vector2();
var Box2 = class {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box2.prototype.isBox2 = true;
var _startP = new Vector3();
var _startEnd = new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t2, target) {
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t2 = startEnd_startP / startEnd2;
    if (clampToLine) {
      t2 = clamp(t2, 0, 1);
    }
    return t2;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t2 = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var ImmediateRenderObject = class extends Object3D {
  constructor(material2) {
    super();
    this.material = material2;
    this.render = function() {
    };
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
  }
};
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
var _vector$3 = new Vector3();
var _vector$2 = new Vector3();
var _boneMatrix = new Matrix4();
var _matrixWorldInv = new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(object4) {
    const bones = getBoneList(object4);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material2 = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material2);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object4;
    this.bones = bones;
    this.matrix = object4.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j2 += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
function getBoneList(object4) {
  const boneList = [];
  if (object4 && object4.isBone) {
    boneList.push(object4);
  }
  for (let i2 = 0; i2 < object4.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object4.children[i2]));
  }
  return boneList;
}
var _vector$1 = new Vector3();
var _color1 = new Color();
var _color2 = new Color();
var GridHelper = class extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i2 = 0, j2 = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
      vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
      vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
      const color3 = i2 === center ? color1 : color2;
      color3.toArray(colors, j2);
      j2 += 3;
      color3.toArray(colors, j2);
      j2 += 3;
      color3.toArray(colors, j2);
      j2 += 3;
      color3.toArray(colors, j2);
      j2 += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material2 = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material2);
    this.type = "GridHelper";
  }
};
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var _vector = new Vector3();
var _camera = new Camera();
var _box = new Box3();
var _axis = new Vector3();
var AxesHelper = class extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material2 = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material2);
    this.type = "AxesHelper";
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color2 = new Color();
    const array4 = this.geometry.attributes.color.array;
    color2.set(xAxisColor);
    color2.toArray(array4, 0);
    color2.toArray(array4, 3);
    color2.set(yAxisColor);
    color2.toArray(array4, 6);
    color2.toArray(array4, 9);
    color2.set(zAxisColor);
    color2.toArray(array4, 12);
    color2.toArray(array4, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var _floatView = new Float32Array(1);
var _int32View = new Int32Array(_floatView.buffer);
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m2) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m2);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Matrix3.prototype.flattenToArrayOffset = function(array4, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array4, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m2) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m2);
};
Matrix4.prototype.flattenToArrayOffset = function(array4, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array4, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q2) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q2);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v2.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a2, b2, c2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a2, b2, c2, target);
};
Triangle.normal = function(a2, b2, c2, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a2, b2, c2, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options2) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options2);
};
Shape.prototype.makeGeometry = function(options2) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options2);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m2);
};
Vector3.prototype.getScaleFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m2);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m2) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m2);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name2) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name2);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name2, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name2, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name2 === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name2, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name2) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name2);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Uniform.prototype.onUpdate = function() {
  console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
  return this;
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    },
    set: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color2, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color2, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer3) {
    scope.setBuffer(buffer3);
  });
  return this;
};
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color2, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color2, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/miew/dist/miew.module.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  Object.defineProperty(subClass, "prototype", {
    value: Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    }),
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o2, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest();
}
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var defaults$1 = {
  lines: 12,
  length: 7,
  width: 5,
  radius: 10,
  scale: 1,
  corners: 1,
  color: "#000",
  fadeColor: "transparent",
  animation: "spinner-line-fade-default",
  rotate: 0,
  direction: 1,
  speed: 1,
  zIndex: 2e9,
  className: "spinner",
  top: "50%",
  left: "50%",
  shadow: "0 0 1px transparent",
  position: "absolute"
};
var Spinner = (
  /** @class */
  function() {
    function Spinner2(opts) {
      if (opts === void 0) {
        opts = {};
      }
      this.opts = __assign(__assign({}, defaults$1), opts);
    }
    Spinner2.prototype.spin = function(target) {
      this.stop();
      this.el = document.createElement("div");
      this.el.className = this.opts.className;
      this.el.setAttribute("role", "progressbar");
      css(this.el, {
        position: this.opts.position,
        width: 0,
        zIndex: this.opts.zIndex,
        left: this.opts.left,
        top: this.opts.top,
        transform: "scale(" + this.opts.scale + ")"
      });
      if (target) {
        target.insertBefore(this.el, target.firstChild || null);
      }
      drawLines(this.el, this.opts);
      return this;
    };
    Spinner2.prototype.stop = function() {
      if (this.el) {
        if (typeof requestAnimationFrame !== "undefined") {
          cancelAnimationFrame(this.animateId);
        } else {
          clearTimeout(this.animateId);
        }
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
        this.el = void 0;
      }
      return this;
    };
    return Spinner2;
  }()
);
function css(el, props) {
  for (var prop in props) {
    el.style[prop] = props[prop];
  }
  return el;
}
function getColor(color2, idx) {
  return typeof color2 == "string" ? color2 : color2[idx % color2.length];
}
function drawLines(el, opts) {
  var borderRadius = Math.round(opts.corners * opts.width * 500) / 1e3 + "px";
  var shadow = "none";
  if (opts.shadow === true) {
    shadow = "0 2px 4px #000";
  } else if (typeof opts.shadow === "string") {
    shadow = opts.shadow;
  }
  var shadows = parseBoxShadow(shadow);
  for (var i2 = 0; i2 < opts.lines; i2++) {
    var degrees = ~~(360 / opts.lines * i2 + opts.rotate);
    var backgroundLine = css(document.createElement("div"), {
      position: "absolute",
      top: -opts.width / 2 + "px",
      width: opts.length + opts.width + "px",
      height: opts.width + "px",
      background: getColor(opts.fadeColor, i2),
      borderRadius,
      transformOrigin: "left",
      transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)"
    });
    var delay2 = i2 * opts.direction / opts.lines / opts.speed;
    delay2 -= 1 / opts.speed;
    var line = css(document.createElement("div"), {
      width: "100%",
      height: "100%",
      background: getColor(opts.color, i2),
      borderRadius,
      boxShadow: normalizeShadow(shadows, degrees),
      animation: 1 / opts.speed + "s linear " + delay2 + "s infinite " + opts.animation
    });
    backgroundLine.appendChild(line);
    el.appendChild(backgroundLine);
  }
}
function parseBoxShadow(boxShadow) {
  var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
  var shadows = [];
  for (var _i = 0, _a = boxShadow.split(","); _i < _a.length; _i++) {
    var shadow = _a[_i];
    var matches = shadow.match(regex);
    if (matches === null) {
      continue;
    }
    var x2 = +matches[2];
    var y2 = +matches[5];
    var xUnits = matches[4];
    var yUnits = matches[7];
    if (x2 === 0 && !xUnits) {
      xUnits = yUnits;
    }
    if (y2 === 0 && !yUnits) {
      yUnits = xUnits;
    }
    if (xUnits !== yUnits) {
      continue;
    }
    shadows.push({
      prefix: matches[1] || "",
      x: x2,
      y: y2,
      xUnits,
      yUnits,
      end: matches[8]
    });
  }
  return shadows;
}
function normalizeShadow(shadows, degrees) {
  var normalized = [];
  for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
    var shadow = shadows_1[_i];
    var xy = convertOffset(shadow.x, shadow.y, degrees);
    normalized.push(shadow.prefix + xy[0] + shadow.xUnits + " " + xy[1] + shadow.yUnits + shadow.end);
  }
  return normalized.join(", ");
}
function convertOffset(x2, y2, degrees) {
  var radians = degrees * Math.PI / 180;
  var sin = Math.sin(radians);
  var cos = Math.cos(radians);
  return [
    Math.round((x2 * cos + y2 * sin) * 1e3) / 1e3,
    Math.round((-x2 * sin + y2 * cos) * 1e3) / 1e3
  ];
}
var Timer = function() {
  function Timer2() {
    _classCallCheck(this, Timer2);
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  _createClass(Timer2, [{
    key: "start",
    value: function start() {
      this.startTime = Timer2.now();
      this.oldTime = this.startTime;
      this.running = true;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.getElapsedTime();
      this.running = false;
    }
  }, {
    key: "getElapsedTime",
    value: function getElapsedTime() {
      this.update();
      return this.elapsedTime;
    }
  }, {
    key: "update",
    value: function update() {
      var delta = 0;
      if (this.running) {
        var newTime = Timer2.now();
        delta = 1e-3 * (newTime - this.oldTime);
        this.oldTime = newTime;
        this.elapsedTime += delta;
      }
      return delta;
    }
  }]);
  return Timer2;
}();
Timer.now = function() {
  var p2 = typeof window !== "undefined" && window.performance;
  return p2 && p2.now ? p2.now.bind(p2) : Date.now;
}();
var now = Timer.now;
function createElement$2(tag, id, css2) {
  var element = document.createElement(tag);
  element.id = id;
  element.style.cssText = css2;
  return element;
}
var Stats = function() {
  function Stats2() {
    _classCallCheck(this, Stats2);
    this.domElement = createElement$2("div", "stats", "padding:8px");
    this._text = createElement$2("p", "fps", "margin:0;color:silver;font-size:large");
    this.domElement.appendChild(this._text);
    this._startTime = now();
    this._prevTime = this._startTime;
    this._deltas = new Array(20);
    this._index = 0;
    this._total = 0;
    this._count = 0;
  }
  _createClass(Stats2, [{
    key: "end",
    value: function end() {
      var time = now();
      var delta = time - this._startTime;
      if (this._count < this._deltas.length) {
        this._count++;
      } else {
        this._total -= this._deltas[this._index];
      }
      this._total += delta;
      this._deltas[this._index] = delta;
      this._index = (this._index + 1) % this._deltas.length;
      this.ms = this._total / this._count;
      this.fps = 1e3 / this.ms;
      if (time > this._prevTime + 1e3) {
        this._text.textContent = this.fps.toPrecision(2);
        this._prevTime = time;
      }
      return time;
    }
  }, {
    key: "update",
    value: function update() {
      this._startTime = this.end();
    }
  }, {
    key: "show",
    value: function show(on2) {
      if (on2 === void 0) {
        on2 = true;
      }
      this.domElement.style.display = on2 ? "block" : "none";
    }
  }]);
  return Stats2;
}();
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _isNativeReflectConstruct$23() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$23()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2) _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function isUndefOrEqual(param, value) {
  return !param || param === value;
}
function EventDispatcher2() {
  this._handlers = {};
}
EventDispatcher2.prototype.addEventListener = function(type, callback, context) {
  var handlers = this._handlers[type];
  if (!handlers) {
    this._handlers[type] = [];
    handlers = this._handlers[type];
  }
  var params = [callback, context];
  function _checkPar(par) {
    return par[0] === params[0] && par[1] === params[1];
  }
  if ((0, import_lodash.find)(handlers, _checkPar) === void 0) {
    handlers.push(params);
  }
};
EventDispatcher2.prototype.removeEventListener = function(type, callback, context) {
  var self2 = this;
  (0, import_lodash.forEach)(self2._handlers, function(handler, ev) {
    (0, import_lodash.remove)(handler, function(values) {
      return isUndefOrEqual(type, ev) && isUndefOrEqual(callback, values[0]) && isUndefOrEqual(context, values[1] || self2);
    });
  });
  this._handlers = (0, import_lodash.omitBy)(self2._handlers, function(handler) {
    return handler.length === 0;
  });
};
EventDispatcher2.prototype.dispatchEvent = function(event) {
  var self2 = this;
  (0, import_lodash.forEach)(this._handlers[event.type], function(callback) {
    var context = callback[1] || self2;
    callback[0].apply(context, [event]);
  });
};
var priorities = {
  debug: 0,
  info: 1,
  report: 2,
  warn: 3,
  error: 4
};
function Logger() {
  EventDispatcher2.call(this);
  this.console = false;
  this._priority = priorities.warn;
}
Logger.prototype = Object.create(EventDispatcher2.prototype);
Logger.prototype.constructor = Logger;
Logger.prototype.instantiate = function() {
  return new Logger();
};
function verify(number) {
  if (!(0, import_lodash.isNumber)(number)) {
    throw new Error("Wrong log level specified!");
  }
  return number;
}
Object.defineProperty(Logger.prototype, "level", {
  get: function get2() {
    var _this = this;
    return (0, import_lodash.findKey)(priorities, function(value) {
      return value === _this._priority;
    });
  },
  set: function set2(level) {
    this._priority = verify(priorities[level]);
  }
});
Logger.prototype.levels = function() {
  return Object.keys(priorities);
};
Logger.prototype.message = function(level, message) {
  var priority = verify(priorities[level]);
  this._message(priority, message);
};
Logger.prototype.debug = function(message) {
  this._message(priorities.debug, message);
};
Logger.prototype.info = function(message) {
  this._message(priorities.info, message);
};
Logger.prototype.report = function(message) {
  this._message(priorities.report, message);
};
Logger.prototype.warn = function(message) {
  this._message(priorities.warn, message);
};
Logger.prototype.error = function(message) {
  this._message(priorities.error, message);
};
Logger.prototype._message = function(priority, message) {
  if (priority < this._priority) {
    return;
  }
  var level = (0, import_lodash.findKey)(priorities, function(value) {
    return value === priority;
  });
  message = String(message);
  if (this.console) {
    var output = "miew:".concat(level, ": ").concat(message);
    if (level === "error") {
      console.error(output);
    } else if (level === "warn") {
      console.warn(output);
    } else {
      console.log(output);
    }
  }
  this.dispatchEvent({
    type: "message",
    level,
    message
  });
};
var logger = new Logger();
function _createSuper$22(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$22();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$22() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var browserType = {
  DEFAULT: 0,
  SAFARI: 1
};
function encodeQueryComponent(text, excludeExp) {
  var encode = function encode2(code) {
    return String.fromCharCode(parseInt(code.substr(1), 16));
  };
  return encodeURIComponent(text).replace(excludeExp, encode).replace(/%20/g, "+");
}
function decodeQueryComponent(text) {
  return decodeURIComponent(text.replace(/\+/g, " "));
}
function getUrlParameters(url) {
  url = url || window.location.search;
  var query = url.substring(url.indexOf("?") + 1);
  var search = /([^&=]+)=?([^&]*)/g;
  var result = [];
  var match;
  while ((match = search.exec(query)) !== null) {
    result.push([decodeQueryComponent(match[1]), decodeQueryComponent(match[2])]);
  }
  return result;
}
function getUrlParametersAsDict(url) {
  var result = {};
  var a2 = getUrlParameters(url);
  for (var i2 = 0; i2 < a2.length; ++i2) {
    var _a$i = _slicedToArray(a2[i2], 2), key = _a$i[0], value = _a$i[1];
    result[key] = value;
  }
  return result;
}
function resolveURL(str) {
  if (typeof URL !== "undefined") {
    try {
      if (typeof window !== "undefined") {
        return new URL(str, window.location).href;
      }
      return new URL(str).href;
    } catch (error) {
    }
  }
  if (typeof document !== "undefined") {
    var anchor = document.createElement("a");
    anchor.href = str;
    return anchor.href;
  }
  return str;
}
function generateRegExp(symbolStr) {
  var symbolList = [];
  for (var i2 = 0, n2 = symbolStr.length; i2 < n2; ++i2) {
    symbolList[symbolList.length] = symbolStr[i2].charCodeAt(0).toString(16);
  }
  var listStr = symbolList.join("|");
  return new RegExp("%(?:".concat(listStr, ")"), "gi");
}
function createElement$1(tag, attrs, content) {
  var element = document.createElement(tag);
  var i2;
  var n2;
  if (attrs) {
    var keys2 = Object.keys(attrs);
    for (i2 = 0, n2 = keys2.length; i2 < n2; ++i2) {
      var key = keys2[i2];
      element.setAttribute(key, attrs[key]);
    }
  }
  if (content) {
    if (!(content instanceof Array)) {
      content = [content];
    }
    for (i2 = 0, n2 = content.length; i2 < n2; ++i2) {
      var child = content[i2];
      if (typeof child === "string") {
        element.appendChild(document.createTextNode(child));
      } else if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    }
  }
  return element;
}
function deriveClass(cls, base, members, statics) {
  cls.prototype = (0, import_lodash.assign)(Object.create(base.prototype), {
    constructor: cls
  }, members);
  if (statics) {
    (0, import_lodash.assign)(cls, statics);
  }
  return cls;
}
function deriveDeep(obj, needZeroOwnProperties) {
  var res = obj;
  var i2;
  var n2;
  if (obj instanceof Array) {
    res = new Array(obj.length);
    for (i2 = 0, n2 = obj.length; i2 < n2; ++i2) {
      res[i2] = deriveDeep(obj[i2]);
    }
  } else if (obj instanceof Object) {
    res = Object.create(obj);
    var keys2 = Object.keys(obj);
    for (i2 = 0, n2 = keys2.length; i2 < n2; ++i2) {
      var key = keys2[i2];
      var value = obj[key];
      var copy2 = deriveDeep(value);
      if (copy2 !== value) {
        res[key] = copy2;
      }
    }
    if (needZeroOwnProperties && Object.keys(res).length > 0) {
      res = Object.create(res);
    }
  }
  return res;
}
function hexColor(color2) {
  var hex = "0000000".concat(color2.toString(16)).substr(-6);
  return "#".concat(hex);
}
function DebugTracer(namespace) {
  var enabled = false;
  this.enable = function(on2) {
    enabled = on2;
  };
  var indent = 0;
  var methods = Object.keys(namespace);
  function wrap(method_, name_) {
    return function() {
      var spaces = DebugTracer.spaces.substr(0, indent * 2);
      if (enabled) {
        logger.debug("".concat(spaces + name_, " {"));
      }
      indent++;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var result = method_.apply(this, args);
      indent--;
      if (enabled) {
        logger.debug("".concat(spaces, "} // ").concat(name_));
      }
      return result;
    };
  }
  for (var i2 = 0, n2 = methods.length; i2 < n2; ++i2) {
    var name2 = methods[i2];
    var method = namespace[name2];
    if (method instanceof Function && name2 !== "constructor") {
      namespace[name2] = wrap(method, name2);
    }
  }
}
DebugTracer.spaces = "                                                                                          ";
var OutOfMemoryError = function(_Error) {
  _inherits(OutOfMemoryError2, _Error);
  var _super = _createSuper$22(OutOfMemoryError2);
  function OutOfMemoryError2(message) {
    var _this;
    _classCallCheck(this, OutOfMemoryError2);
    _this = _super.call(this);
    _this.name = "OutOfMemoryError";
    _this.message = message;
    return _this;
  }
  return _createClass(OutOfMemoryError2);
}(_wrapNativeSuper(Error));
function allocateTyped(TypedArrayName, size) {
  var result = null;
  try {
    result = new TypedArrayName(size);
  } catch (e2) {
    if (e2 instanceof RangeError) {
      throw new OutOfMemoryError(e2.message);
    } else {
      throw e2;
    }
  }
  return result;
}
function bytesToBase64(buffer3) {
  var bytes = new Uint8Array(buffer3);
  var binary = "";
  for (var i2 = 0; i2 < bytes.byteLength; i2++) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return window.btoa(binary);
}
function bytesFromBase64(str) {
  var binary = window.atob(str);
  var bytes = new Uint8Array(binary.length);
  for (var i2 = 0; i2 < bytes.length; ++i2) {
    bytes[i2] = binary[i2].charCodeAt(0);
  }
  return bytes.buffer;
}
function arrayToBase64(array4, TypedArrayClass) {
  return bytesToBase64(new TypedArrayClass(array4).buffer);
}
function arrayFromBase64(str, TypedArrayClass) {
  return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)));
}
function compareOptionsWithDefaults(opts, defOpts) {
  var optsStr = [];
  if (defOpts && opts) {
    var keys2 = Object.keys(opts);
    for (var p2 = 0; p2 < keys2.length; ++p2) {
      var key = keys2[p2];
      var value = opts[key];
      if (!(value instanceof Object) && typeof defOpts[key] !== "undefined" && defOpts[key] !== value) {
        optsStr.push("".concat(key, ":").concat(value));
      }
    }
    if (optsStr.length > 0) {
      return "!".concat(optsStr.join());
    }
  }
  return "";
}
function isAlmostPlainObject(o2) {
  if ((0, import_lodash.isPlainObject)(o2)) {
    return true;
  }
  var proto = o2 && Object.getPrototypeOf(o2);
  return !!proto && !proto.hasOwnProperty("constructor") && isAlmostPlainObject(proto);
}
function objectsDiff(src, dst) {
  var diff = {};
  (0, import_lodash.forIn)(src, function(srcValue, key) {
    var dstValue = dst[key];
    if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
      var deepDiff = objectsDiff(srcValue, dstValue);
      if (!(0, import_lodash.isEmpty)(deepDiff)) {
        diff[key] = deepDiff;
      }
    } else if (!(0, import_lodash.isEqual)(srcValue, dstValue)) {
      diff[key] = srcValue;
    }
  });
  return diff;
}
function forInRecursive(object4, callback) {
  function iterateThrough(obj, prefix2) {
    (0, import_lodash.forIn)(obj, function(value, key) {
      var newPref = prefix2 + (prefix2.length > 0 ? "." : "");
      if (value instanceof Object) {
        iterateThrough(value, newPref + key);
      } else if (value !== void 0) {
        callback(value, newPref + key);
      }
    });
  }
  iterateThrough(object4, "");
}
function enquoteString(value) {
  if ((0, import_lodash.isString)(value)) {
    return '"'.concat(value.replace(/"/g, '\\"'), '"');
  }
  return value;
}
function unquoteString(value) {
  if (!(0, import_lodash.isString)(value)) {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"') {
    value = value.slice(1, value.length - 1);
    return value.replace(/\\"/g, '"');
  }
  if (value[0] === "'" && value[value.length - 1] === "'") {
    value = value.slice(1, value.length - 1);
    return value.replace(/\\'/g, "'");
  }
  throw new SyntaxError("Incorrect string format, can't unqute it");
}
function getFileExtension(fileName) {
  return fileName.slice(Math.max(0, fileName.lastIndexOf(".")) || Infinity);
}
function splitFileName(fileName) {
  var ext = getFileExtension(fileName);
  var name2 = fileName.slice(0, fileName.length - ext.length);
  return [name2, ext];
}
function dataUrlToBlob(url) {
  var parts = url.split(/[:;,]/);
  var partsCount = parts.length;
  if (partsCount >= 3 && parts[partsCount - 2] === "base64") {
    return new Blob([bytesFromBase64(parts[partsCount - 1])]);
  }
  return null;
}
function getBrowser() {
  if (navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && navigator.userAgent.indexOf("CriOS") === -1 && navigator.userAgent.indexOf("FxiOS") === -1) {
    return browserType.SAFARI;
  }
  return browserType.DEFAULT;
}
function shotOpen(url) {
  if (typeof window !== "undefined") {
    window.open().document.write('<body style="margin:0"><img src="'.concat(url, '" /></body>'));
  }
}
function shotDownload(dataUrl, filename) {
  if (!dataUrl || dataUrl.substr(0, 5) !== "data:") {
    return;
  }
  if (!filename) {
    filename = ["screenshot-", +/* @__PURE__ */ new Date(), ".png"].join("");
  }
  if (typeof window !== "undefined" && window.navigator && window.navigator.msSaveBlob) {
    window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename);
  } else if (typeof document !== "undefined") {
    var link = document.createElement("a");
    link.download = filename;
    link.innerHTML = "download";
    link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl));
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}
function download(data, filename, type) {
  var blobData = new Blob([data]);
  if (!filename) {
    filename = ["data", +/* @__PURE__ */ new Date()].join("");
  }
  if (!type) {
    filename += blobData.type || ".bin";
  } else {
    filename += ".".concat(type);
  }
  if (typeof window !== "undefined" && window.navigator && window.navigator.msSaveBlob) {
    window.navigator.msSaveBlob(blobData, filename);
  } else if (typeof document !== "undefined") {
    var link = document.createElement("a");
    link.download = filename;
    link.innerHTML = "download";
    link.href = window.URL.createObjectURL(blobData);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}
function copySubArrays$2(src, dst, indices, itemSize) {
  for (var i2 = 0, n2 = indices.length; i2 < n2; ++i2) {
    for (var j2 = 0; j2 < itemSize; ++j2) {
      dst[i2 * itemSize + j2] = src[indices[i2] * itemSize + j2];
    }
  }
}
function shallowCloneNode(node) {
  var newNode = node.cloneNode(true);
  newNode.worldPos = node.worldPos;
  return newNode;
}
var unquotedStringRE = /^[a-zA-Z0-9_]*$/;
var enquoteHelper = ['"', "", '"'];
function correctSelectorIdentifier(value) {
  if (unquotedStringRE.test(value)) {
    return value;
  }
  enquoteHelper[1] = value;
  return enquoteHelper.join("");
}
function concatTypedArraysUnsafe(first, second) {
  var result = new first.constructor(first.length + second.length);
  result.set(first);
  result.set(second, first.length);
  return result;
}
function mergeTypedArraysUnsafe(array4) {
  if (array4.length <= 0) {
    return null;
  }
  var size = array4.reduce(function(acc, cur) {
    return acc + cur.length;
  }, 0);
  var result = new array4[0].constructor(size);
  for (var i2 = 0, start = 0; i2 < array4.length; i2++) {
    var count = array4[i2].length;
    result.set(array4[i2], start);
    start += count;
  }
  return result;
}
var utils = {
  browserType,
  encodeQueryComponent,
  decodeQueryComponent,
  getUrlParameters,
  getUrlParametersAsDict,
  resolveURL,
  generateRegExp,
  createElement: createElement$1,
  deriveClass,
  deriveDeep,
  hexColor,
  DebugTracer,
  OutOfMemoryError,
  allocateTyped,
  bytesFromBase64,
  bytesToBase64,
  arrayFromBase64,
  arrayToBase64,
  compareOptionsWithDefaults,
  objectsDiff,
  forInRecursive,
  enquoteString,
  unquoteString,
  getBrowser,
  shotOpen,
  shotDownload,
  copySubArrays: copySubArrays$2,
  shallowCloneNode,
  correctSelectorIdentifier,
  getFileExtension,
  splitFileName,
  download,
  concatTypedArraysUnsafe,
  mergeTypedArraysUnsafe
};
function _createSuper$21(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$21();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$21() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var JobHandle = function(_EventDispatcher) {
  _inherits(JobHandle2, _EventDispatcher);
  var _super = _createSuper$21(JobHandle2);
  function JobHandle2() {
    var _this;
    _classCallCheck(this, JobHandle2);
    _this = _super.call(this);
    _this._shouldCancel = false;
    return _this;
  }
  _createClass(JobHandle2, [{
    key: "cancel",
    value: function cancel2() {
      this._shouldCancel = true;
      this.dispatchEvent({
        type: "cancel"
      });
    }
  }, {
    key: "shouldCancel",
    value: function shouldCancel3() {
      return this._shouldCancel;
    }
  }, {
    key: "notify",
    value: function notify(event) {
      this.dispatchEvent({
        type: "notification",
        slaveEvent: event
      });
    }
  }]);
  return JobHandle2;
}(EventDispatcher2);
var VERSION = 0;
var defaults = {
  modes: {
    BS: {
      atom: 0.23,
      bond: 0.15,
      space: 0.5,
      multibond: true,
      aromrad: 0.1,
      showarom: true,
      polyComplexity: {
        poor: 3,
        low: 4,
        medium: 6,
        high: 12,
        ultra: 32
      }
    },
    VW: {
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 8,
        high: 16,
        ultra: 32
      }
    },
    LN: {
      multibond: true,
      showarom: true,
      offsarom: 0.2,
      chunkarom: 10,
      atom: 0.23,
      lineWidth: 2
    },
    LC: {
      bond: 0.2,
      space: 0,
      multibond: true,
      aromrad: 0.1,
      showarom: true,
      polyComplexity: {
        poor: 3,
        low: 4,
        medium: 6,
        high: 12,
        ultra: 32
      }
    },
    SA: {
      zClip: false,
      probeRadius: 1.5,
      subset: "",
      wireframe: false,
      polyComplexity: {
        poor: 6,
        low: 8,
        medium: 16,
        high: 30,
        ultra: 60
      }
    },
    SE: {
      zClip: false,
      probeRadius: 1.5,
      subset: "",
      wireframe: false,
      polyComplexity: {
        poor: 6,
        low: 8,
        medium: 16,
        high: 30,
        ultra: 60
      }
    },
    QS: {
      isoValue: 0.5,
      gaussLim: {
        poor: 1.5,
        low: 2,
        medium: 2.5,
        high: 3,
        ultra: 4
      },
      scale: 1,
      wireframe: false,
      gridSpacing: {
        poor: 2,
        low: 1.5,
        medium: 1,
        high: 0.5,
        ultra: 0.25
      },
      subset: "",
      zClip: false
    },
    CS: {
      probeRadius: 1.4,
      isoValue: 1.5,
      wireframe: false,
      probePositions: 30,
      polyComplexity: {
        poor: 0.5,
        low: 1,
        medium: 1.5,
        high: 1.75,
        ultra: 2
      },
      subset: "",
      zClip: false
    },
    TR: {
      radius: 0.3,
      polyComplexity: {
        poor: 12,
        low: 16,
        medium: 32,
        high: 64,
        ultra: 64
      }
    },
    TU: {
      radius: 0.3,
      heightSegmentsRatio: 1.5,
      tension: -0.7,
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 10,
        high: 18,
        ultra: 34
      }
    },
    CA: {
      radius: 0.3,
      depth: 0.25,
      ss: {
        helix: {
          width: 1,
          arrow: 2
        },
        strand: {
          width: 1,
          arrow: 2
        }
      },
      heightSegmentsRatio: 1.5,
      tension: -0.7,
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 10,
        high: 18,
        ultra: 34
      }
    },
    TX: {
      template: "{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}",
      horizontalAlign: "center",
      verticalAlign: "middle",
      dx: 0,
      dy: 0,
      dz: 1,
      fg: "none",
      bg: "0x202020",
      showBg: true
    },
    VD: {
      kSigma: 1,
      kSigmaMed: 2,
      kSigmaMax: 4,
      frame: true,
      isoMode: false,
      polyComplexity: {
        poor: 2,
        low: 3,
        medium: 4,
        high: 8,
        ultra: 10
      }
    }
  },
  colorers: {
    EL: {
      carbon: -1
    },
    UN: {
      color: 16777215
    },
    CO: {
      subset: "charged",
      color: 16711680,
      baseColor: 16777215
    },
    CB: {
      color: 9474192,
      factor: 0.6
    },
    SQ: {
      gradient: "rainbow"
    },
    TM: {
      gradient: "temp",
      min: 5,
      max: 40
    },
    OC: {
      gradient: "reds"
    },
    HY: {
      gradient: "blue-red"
    },
    MO: {
      gradient: "rainbow"
    }
  },
  antialias: true,
  camFov: 45,
  camNear: 0.5,
  camFar: 100,
  camDistance: 2.5,
  radiusToFit: 1,
  fogNearFactor: 0.5,
  fogFarFactor: 1,
  fogAlpha: 1,
  fogColor: 0,
  fogColorEnable: false,
  palette: "JM",
  resolution: "medium",
  autoResolution: false,
  autoPreset: true,
  preset: "default",
  presets: {
    default: [{
      mode: "BS",
      colorer: "EL",
      selector: "all",
      material: "SF"
    }],
    empty: [],
    wire: [{
      mode: "LN",
      colorer: "EL",
      selector: "all",
      material: "SF"
    }],
    small: [{
      mode: "BS",
      colorer: "EL",
      selector: "all",
      material: "SF"
    }],
    macro: [{
      mode: "CA",
      colorer: "SS",
      selector: "not hetatm",
      material: "SF"
    }, {
      mode: "BS",
      colorer: "EL",
      selector: "hetatm and not water",
      material: "SF"
    }]
  },
  objects: {
    line: {
      color: 4294967295,
      dashSize: 0.3,
      gapSize: 0.05
    }
  },
  bg: {
    color: 2105376,
    transparent: false
  },
  draft: {
    clipPlane: false,
    clipPlaneFactor: 0.5,
    clipPlaneSpeed: 3e-5
  },
  plugins: {},
  axes: true,
  fog: true,
  fps: true,
  zSprites: true,
  isoSurfaceFakeOpacity: true,
  suspendRender: true,
  nowater: false,
  autobuild: true,
  fxaa: true,
  outline: {
    on: false,
    color: 0,
    threshold: 0.1,
    thickness: 1
  },
  ao: false,
  shadow: {
    on: false,
    type: "random",
    radius: 1
  },
  autoRotation: 0,
  maxfps: 30,
  fbxprec: 4,
  autoRotationAxisFixed: true,
  zooming: true,
  picking: true,
  pick: "atom",
  editing: false,
  aromatic: false,
  singleUnit: true,
  stereo: "NONE",
  interpolateViews: true,
  transparency: "prepass",
  translationSpeed: 2,
  debug: {
    example: 3.5,
    text: "hello!",
    good: true,
    ssaoKernelRadius: 0.7,
    ssaoFactor: 0.7,
    stereoBarrel: 0.25
  },
  use: {
    multiFile: false
  }
};
function Settings() {
  EventDispatcher2.call(this);
  this.old = null;
  this.now = {};
  this._changed = {};
  this.reset();
}
utils.deriveClass(Settings, EventDispatcher2, {
  defaults,
  set: function set$1(path, value) {
    if ((0, import_lodash.isString)(path)) {
      var oldValue = (0, import_lodash.get)(this.now, path);
      if (oldValue !== value) {
        (0, import_lodash.set)(this.now, path, value);
        this._notifyChange(path, value);
      }
    } else {
      var diff = utils.objectsDiff(path, this.now);
      if (!(0, import_lodash.isEmpty)(diff)) {
        (0, import_lodash.merge)(this.now, diff);
        this._notifyChanges(diff);
      }
    }
  },
  get: function get$1(path, defaultValue) {
    return (0, import_lodash.get)(this.now, path, defaultValue);
  },
  reset: function reset() {
    var diff = utils.objectsDiff(defaults, this.now);
    this.now = (0, import_lodash.cloneDeep)(defaults);
    this.old = null;
    this._notifyChanges(diff);
    this._changed = {};
  },
  checkpoint: function checkpoint() {
    this.old = (0, import_lodash.cloneDeep)(this.now);
    this._changed = {};
  },
  _notifyChange: function _notifyChange(path, value) {
    this._changed[path] = true;
    this.dispatchEvent({
      type: "change:".concat(path),
      value
    });
  },
  _notifyChanges: function _notifyChanges(diff) {
    var _this = this;
    utils.forInRecursive(diff, function(deepValue, deepPath) {
      _this._notifyChange(deepPath, deepValue);
    });
  },
  changed: function changed() {
    if (!this.old) {
      return [];
    }
    var old = this.old, now2 = this.now;
    var keys2 = (0, import_lodash.filter)(Object.keys(this._changed), function(key) {
      return (0, import_lodash.get)(old, key) !== (0, import_lodash.get)(now2, key);
    });
    return keys2;
  },
  applyDiffs: function applyDiffs(diffs) {
    if (diffs.hasOwnProperty("VERSION") && diffs.VERSION !== VERSION) {
      throw new Error("Settings version does not match!");
    }
    delete diffs.VERSION;
    this.reset();
    this.set(diffs);
  },
  getDiffs: function getDiffs(versioned) {
    var diffs = utils.objectsDiff(this.now, defaults);
    if (versioned) {
      diffs.VERSION = VERSION;
    }
    return diffs;
  },
  setPluginOpts: function setPluginOpts(plugin, opts) {
    defaults.plugins[plugin] = (0, import_lodash.cloneDeep)(opts);
    this.now.plugins[plugin] = (0, import_lodash.cloneDeep)(opts);
  }
});
var settings$1 = new Settings();
var repIndex = 0;
function asBoolean(value) {
  return !(!value || value === "0" || (0, import_lodash.isString)(value) && value.toLowerCase() === "false");
}
var adapters = {
  string: String,
  number: Number,
  boolean: asBoolean
};
var cL1Ass = "=";
var cOptsSep = "!";
var cL2Ass = ":";
var cLSep = ",";
var cCommonIgnoreSymbols = "$;@/?";
function getLevel1ExcludedExpr() {
  var cLevel1Ignores = ":,";
  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores);
}
function getLevel2ExcludedExpr() {
  var cLevel2Ignores = " ";
  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores);
}
var cL1ExclExpr = getLevel1ExcludedExpr();
function encodeQueryComponentL1(value) {
  return utils.encodeQueryComponent(value, cL1ExclExpr);
}
var cL2ExclExpr = getLevel2ExcludedExpr();
function encodeQueryComponentL2(value) {
  return utils.encodeQueryComponent(value, cL2ExclExpr);
}
function ensureRepList(opts) {
  var reps = opts.reps;
  if (!reps) {
    var presets = settings$1.now.presets;
    var preset2 = opts.preset || settings$1.now.preset;
    reps = presets[preset2];
    if (!reps) {
      logger.warn('Unknown preset "'.concat(preset2, '"'));
      var _Object$keys = Object.keys(presets);
      var _Object$keys2 = _slicedToArray(_Object$keys, 1);
      preset2 = _Object$keys2[0];
      reps = presets[preset2];
    }
    opts.preset = preset2;
    opts.reps = utils.deriveDeep(reps, true);
  }
}
function ensureRepAssign(opts, prop, value) {
  ensureRepList(opts);
  var rep2 = opts.reps[repIndex];
  if (rep2.hasOwnProperty(prop)) {
    repIndex = opts.reps.length;
    opts.reps[repIndex] = utils.deriveDeep(rep2, true);
  }
  if (value !== void 0) {
    opts.reps[repIndex][prop] = value;
  }
}
function addObject(opts, params, options2) {
  if (opts._objects === void 0) {
    opts._objects = [];
  }
  var _options = _slicedToArray(options2, 2), type = _options[0], newOpts = _options[1];
  var newObj = {
    type,
    params
  };
  if (newOpts !== void 0) {
    newObj.opts = newOpts;
  }
  opts._objects[opts._objects.length] = newObj;
}
function parseParams(str, params) {
  var sep = str.indexOf(",");
  if (sep >= 0) {
    params.push(str.substr(sep + 1).split(","));
    return str.substr(0, sep);
  }
  return str;
}
function extractArgs(input, defaultsDict, params) {
  if (input) {
    var bang = input.indexOf(cOptsSep);
    var inputVal = parseParams(input.substr(0, bang >= 0 ? bang : void 0), params);
    if (bang >= 0) {
      var args = input.substr(bang + 1).split(cLSep);
      input = inputVal;
      if (defaultsDict) {
        var defaults2 = defaultsDict[input];
        var opts = utils.deriveDeep(defaults2, true);
        args.forEach(function(arg) {
          var pair = arg.split(cL2Ass, 2);
          var key = decodeURIComponent(pair[0]);
          var value = decodeURIComponent(pair[1]);
          var adapter = adapters[_typeof((0, import_lodash.get)(defaults2, key))];
          if (adapter) {
            (0, import_lodash.set)(opts, key, adapter(value));
          } else {
            logger.warn('Unknown argument "'.concat(key, '" for option "').concat(input, '"'));
          }
        });
        if (Object.keys(opts).length > 0) {
          input = [input, opts];
        }
      }
    } else {
      input = inputVal;
    }
  }
  return input;
}
var actions = {
  l: "load",
  load: String,
  t: "type",
  type: String,
  v: "view",
  view: String,
  u: "unit",
  unit: Number,
  menu: asBoolean,
  o: "object",
  object: function object(value, opts) {
    var params = [];
    var options2 = extractArgs(value, settings$1.defaults.objects, params);
    if (!Array.isArray(options2)) {
      options2 = [options2];
    }
    addObject(opts, params[0], options2);
  },
  p: "preset",
  preset: function preset(value, opts) {
    opts.preset = value;
    opts.reps = null;
    ensureRepList(opts);
  },
  r: "rep",
  rep: function rep(value, opts) {
    ensureRepList(opts);
    repIndex = Number(value);
    repIndex = repIndex <= opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length;
    if (repIndex === opts.reps.length) {
      opts.reps[repIndex] = repIndex > 0 ? utils.deriveDeep(opts.reps[repIndex - 1], true) : utils.deriveDeep(settings$1.defaults.presets.default[0], true);
    }
  },
  s: "select",
  select: function select(value, opts) {
    ensureRepAssign(opts, "selector", value);
  },
  m: "mode",
  mode: function mode(value, opts) {
    ensureRepAssign(opts, "mode", extractArgs(value, settings$1.defaults.modes));
  },
  c: "color",
  color: function color(value, opts) {
    ensureRepAssign(opts, "colorer", extractArgs(value, settings$1.defaults.colorers));
  },
  mt: "material",
  material: function material(value, opts) {
    ensureRepAssign(opts, "material", extractArgs(value, settings$1.defaults.materials));
  },
  dup: function dup(value, opts) {
    ensureRepList(opts);
    var reps = opts.reps;
    var rep2 = reps[repIndex];
    repIndex = reps.length;
    reps[repIndex] = utils.deriveDeep(rep2, true);
  },
  ar: "autoResolution"
};
function _fromArray(entries) {
  repIndex = 0;
  var opts = {};
  for (var i2 = 0, n2 = entries.length; i2 < n2; ++i2) {
    var entry = entries[i2];
    var key = entry[0];
    var value = entry[1];
    if (actions.hasOwnProperty(key)) {
      var action = actions[key];
      while ((0, import_lodash.isString)(action)) {
        key = action;
        action = actions[key];
      }
      if (typeof action === "function") {
        var result = action(value, opts);
        if (result !== void 0) opts[key] = result;
      }
    } else {
      var adapter = adapters[_typeof((0, import_lodash.get)(settings$1.defaults, key))];
      if (adapter) {
        (0, import_lodash.set)(opts, "settings.".concat(key), adapter(value));
      } else {
        logger.warn('Unknown option "'.concat(key, '"'));
      }
    }
  }
  return opts;
}
function fromAttr(attr) {
  return _fromArray(utils.getUrlParameters("?".concat(attr || "")));
}
function fromURL(url) {
  return _fromArray(utils.getUrlParameters(url));
}
function _processOptsForURL(opts) {
  var str = [];
  var i2 = 0;
  utils.forInRecursive(opts, function(value, key) {
    str[i2++] = encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value);
  });
  return str.join(cLSep);
}
function _processArgsForURL(args) {
  if (!(0, import_lodash.isArray)(args)) {
    return args;
  }
  if (args.length < 2) {
    return args[0];
  }
  return "".concat(args[0]).concat(cOptsSep).concat(_processOptsForURL(args[1]));
}
function _processObjForURL(objOpts) {
  if (!objOpts || !objOpts.type) {
    return void 0;
  }
  var res = objOpts.type;
  if ((0, import_lodash.isArray)(objOpts.params) && objOpts.params.length > 0) {
    res += ",".concat(objOpts.params.join(","));
  }
  if (objOpts.opts) {
    res += cOptsSep + _processOptsForURL(objOpts.opts);
  }
  return res;
}
function toURL(opts) {
  var stringList = [];
  var idx = 0;
  function checkAndAdd(prefix2, value) {
    if (value !== null && value !== void 0) {
      stringList[idx++] = encodeQueryComponentL1(prefix2) + cL1Ass + encodeQueryComponentL1(value);
    }
  }
  function addReps(repList) {
    if (!repList) {
      return;
    }
    for (var i2 = 0, n2 = repList.length; i2 < n2; ++i2) {
      if ((0, import_lodash.isEmpty)(repList[i2])) {
        continue;
      }
      checkAndAdd("r", i2);
      checkAndAdd("s", repList[i2].selector);
      checkAndAdd("m", _processArgsForURL(repList[i2].mode));
      checkAndAdd("c", _processArgsForURL(repList[i2].colorer));
      checkAndAdd("mt", _processArgsForURL(repList[i2].material));
    }
  }
  function addObjects(objList) {
    if (!objList) {
      return;
    }
    for (var i2 = 0, n2 = objList.length; i2 < n2; ++i2) {
      checkAndAdd("o", _processObjForURL(objList[i2]));
    }
  }
  checkAndAdd("l", opts.load);
  checkAndAdd("u", opts.unit);
  checkAndAdd("p", opts.preset);
  addReps(opts.reps);
  addObjects(opts._objects);
  checkAndAdd("v", opts.view);
  utils.forInRecursive(opts.settings, function(value, key) {
    if (key === "preset") {
      return;
    }
    checkAndAdd(key, value);
  });
  var url = "";
  if (typeof window !== "undefined") {
    var _window = window, location = _window.location;
    url = "".concat(location.protocol, "//").concat(location.host).concat(location.pathname);
  }
  if (stringList.length > 0) {
    url += "?".concat(stringList.join("&"));
  }
  return url;
}
function _processOptsForScript(opts) {
  var str = [];
  var i2 = 0;
  utils.forInRecursive(opts, function(value, key) {
    str[i2++] = "".concat(key, "=").concat(utils.enquoteString(value));
  });
  return str.join(" ");
}
function _processArgsForScript(args) {
  if (!(0, import_lodash.isArray)(args)) {
    return args;
  }
  if (args.length < 2) {
    return args[0];
  }
  return "".concat(args[0], " ").concat(_processOptsForScript(args[1]));
}
function _processObjForScript(objOpts) {
  if (!objOpts || !objOpts.type) {
    return void 0;
  }
  var res = objOpts.type;
  if ((0, import_lodash.isArray)(objOpts.params) && objOpts.params.length > 0) {
    res += " ".concat(objOpts.params.map(utils.enquoteString).join(" "));
  }
  if (objOpts.opts) {
    res += " ".concat(_processOptsForScript(objOpts.opts));
  }
  return res;
}
function _processRepsForScript(rep2, index) {
  var repString = [];
  var strIdx = 0;
  function localAdd(prefix2, value) {
    if (value !== null && value !== void 0) {
      repString[strIdx++] = prefix2 + value;
    }
  }
  if ((0, import_lodash.isEmpty)(rep2)) {
    return null;
  }
  localAdd("", index);
  localAdd("s=", utils.enquoteString(rep2.selector));
  localAdd("m=", _processArgsForScript(rep2.mode));
  localAdd("c=", _processArgsForScript(rep2.colorer));
  localAdd("mt=", _processArgsForScript(rep2.material));
  return repString.join(" ");
}
function toScript(opts) {
  var commandsList = [];
  var idx = 0;
  function checkAndAdd(command, value, saveQuotes) {
    if (value !== null && value !== void 0) {
      var quote = typeof value === "string" && saveQuotes ? '"' : "";
      commandsList[idx++] = "".concat(command, " ").concat(quote).concat(value).concat(quote).trim();
    }
  }
  function addReps(repList) {
    if (!repList) {
      return;
    }
    for (var i2 = 0, n2 = repList.length; i2 < n2; ++i2) {
      checkAndAdd("rep", _processRepsForScript(repList[i2], i2));
    }
  }
  function addObjects(objList) {
    if (!objList) {
      return;
    }
    for (var i2 = 0, n2 = objList.length; i2 < n2; ++i2) {
      checkAndAdd("", _processObjForScript(objList[i2]));
    }
  }
  checkAndAdd("set", "autobuild false");
  checkAndAdd("load", opts.load, true);
  checkAndAdd("unit", opts.unit);
  checkAndAdd("preset", opts.preset);
  addReps(opts.reps);
  addObjects(opts._objects);
  utils.forInRecursive(opts.settings, function(value, key) {
    if (key === "preset") {
      return;
    }
    checkAndAdd("set ".concat(key), value, true);
  });
  checkAndAdd("view", opts.view);
  checkAndAdd("set", "autobuild true");
  return commandsList.join("\n");
}
var options$1 = {
  fromURL,
  fromAttr,
  adapters,
  toURL,
  toScript
};
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Atom$2 = function() {
  function Atom2(residue2, name2, type, position, role, het, serial2, location, occupancy, temperature, charge) {
    _classCallCheck(this, Atom2);
    this.index = -1;
    this.residue = residue2;
    this.name = name2;
    this.element = type;
    this.position = position;
    this.role = role;
    this.mask = 1 | 0;
    this.het = het;
    this.serial = serial2;
    this.location = (location || " ").charCodeAt(0);
    this.occupancy = occupancy || 1;
    this.temperature = temperature;
    this.charge = charge;
    this.hydrogenCount = -1;
    this.radicalCount = 0;
    this.valence = -1;
    this.bonds = [];
    this.flags = 0;
    if (type.name === "H") {
      this.flags |= Atom2.Flags.HYDROGEN;
    } else if (type.name === "C") {
      this.flags |= Atom2.Flags.CARBON;
    }
  }
  _createClass(Atom2, [{
    key: "isHet",
    value: function isHet() {
      return this.het;
    }
  }, {
    key: "isHydrogen",
    value: function isHydrogen() {
      return this.element.number === 1;
    }
  }, {
    key: "getVisualName",
    value: function getVisualName() {
      var name2 = this.name;
      if (name2.length > 0) {
        return name2;
      }
      return this.element.name.trim();
    }
  }, {
    key: "forEachBond",
    value: function forEachBond(process2) {
      var bonds = this.bonds;
      for (var i2 = 0, n2 = bonds.length; i2 < n2; ++i2) {
        process2(bonds[i2]);
      }
    }
  }, {
    key: "getFullName",
    value: function getFullName() {
      var name2 = "";
      if (this.residue !== null) {
        if (this.residue._chain !== null) {
          name2 += "".concat(this.residue._chain.getName(), ".");
        }
        name2 += "".concat(this.residue._sequence, ".");
      }
      name2 += this.name;
      return name2;
    }
  }]);
  return Atom2;
}();
_defineProperty2(Atom$2, "Flags", {
  CARBON: 1,
  HYDROGEN: 8,
  NONPOLARH: 4104
});
var Element$a = _createClass(function Element(number, name2, fullName, weight, radius, radiusBonding, hValency) {
  _classCallCheck(this, Element);
  this.number = number;
  this.name = name2;
  this.fullName = fullName;
  this.weight = weight;
  this.radius = radius;
  this.radiusBonding = radiusBonding;
  this.hydrogenValency = hValency;
});
_defineProperty2(Element$a, "Constants", {
  U1: 1,
  Lead: 2,
  U2: 3,
  Wing: 4,
  U18: 18
});
_defineProperty2(Element$a, "Role", {
  N: Element$a.Constants.U1,
  CA: Element$a.Constants.Lead,
  C: Element$a.Constants.U2,
  O: Element$a.Constants.Wing,
  SG: Element$a.Constants.U18
});
_defineProperty2(Element$a, "ByAtomicNumber", [
  null,
  new Element$a(1, "H", "Hydrogen", 1.008, 1.2, 0.23, [1]),
  new Element$a(2, "HE", "Helium", 4.003, 1.4, 0.93, [0]),
  new Element$a(3, "LI", "Lithium", 6.941, 1.82, 0.68, [1]),
  new Element$a(4, "BE", "Beryllium", 9.012, 1.7, 0.35, [2]),
  new Element$a(5, "B", "Boron", 10.81, 2.08, 0.83, [3]),
  new Element$a(6, "C", "Carbon", 12.011, 1.95, 0.68, [4]),
  new Element$a(7, "N", "Nitrogen", 14.007, 1.85, 0.68, [3, 5]),
  new Element$a(8, "O", "Oxygen", 15.999, 1.7, 0.68, [2, 4]),
  new Element$a(9, "F", "Fluorine", 18.998, 1.73, 0.64, [1]),
  new Element$a(10, "NE", "Neon", 20.18, 1.54, 1.12, [0]),
  new Element$a(11, "NA", "Sodium", 22.99, 2.27, 0.97, [1]),
  new Element$a(12, "MG", "Magnesium", 24.305, 1.73, 1.1, [2]),
  new Element$a(13, "AL", "Aluminum", 26.981, 2.05, 1.35, [3]),
  new Element$a(14, "SI", "Silicon", 28.086, 2.1, 1.2, [4]),
  new Element$a(15, "P", "Phosphorus", 30.974, 2.08, 0.75, [3, 5]),
  new Element$a(16, "S", "Sulfur", 32.07, 2, 1.02, [2, 4, 6]),
  new Element$a(17, "CL", "Chlorine", 35.453, 1.97, 0.99, [1, 3, 5, 7]),
  new Element$a(18, "AR", "Argon", 39.948, 1.88, 1.57, [0]),
  new Element$a(19, "K", "Potassium", 39.1, 2.75, 1.33, [1]),
  new Element$a(20, "CA", "Calcium", 40.08, 1.973, 0.99, [2]),
  new Element$a(21, "SC", "Scandium", 44.956, 1.7, 1.44, [0]),
  new Element$a(22, "TI", "Titanium", 47.88, 1.7, 1.47, [0]),
  new Element$a(23, "V", "Vanadium", 50.941, 1.7, 1.33, [0]),
  new Element$a(24, "CR", "Chromium", 52, 1.7, 1.35, [0]),
  new Element$a(25, "MN", "Manganese", 54.938, 1.7, 1.35, [0]),
  new Element$a(26, "FE", "Iron", 55.847, 1.7, 1.34, [0]),
  new Element$a(27, "CO", "Cobalt", 58.93, 1.7, 1.33, [0]),
  new Element$a(28, "NI", "Nickel", 58.69, 1.63, 1.5, [0]),
  new Element$a(29, "CU", "Copper", 63.55, 1.4, 1.52, [0]),
  new Element$a(30, "ZN", "Zinc", 65.39, 1.39, 1.45, [0]),
  new Element$a(31, "GA", "Gallium", 69.72, 1.87, 1.22, [3]),
  new Element$a(32, "GE", "Germanium", 72.61, 1.7, 1.17, [4]),
  new Element$a(33, "AS", "Arsenic", 74.92, 1.85, 1.21, [3, 5]),
  new Element$a(34, "SE", "Selenium", 78.96, 1.9, 1.22, [2, 4, 6]),
  new Element$a(35, "BR", "Bromine", 79.9, 2.1, 1.21, [1, 3, 5, 7]),
  new Element$a(36, "KR", "Krypton", 83.8, 2.02, 1.91, [0]),
  new Element$a(37, "RB", "Rubidium", 85.47, 1.7, 1.47, [1]),
  new Element$a(38, "SR", "Strontium", 87.62, 1.7, 1.12, [2]),
  new Element$a(39, "Y", "Yttrium", 88.91, 1.7, 1.78, [0]),
  new Element$a(40, "ZR", "Zirconium", 91.22, 1.7, 1.56, [0]),
  new Element$a(41, "NB", "Niobium", 92.91, 1.7, 1.48, [0]),
  new Element$a(42, "MO", "Molybdenum", 95.94, 1.7, 1.47, [0]),
  new Element$a(43, "TC", "Technetium", 98.91, 1.7, 1.35, [0]),
  new Element$a(44, "RU", "Ruthenium", 101.07, 1.7, 1.4, [0]),
  new Element$a(45, "RH", "Rhodium", 102.91, 1.7, 1.45, [0]),
  new Element$a(46, "PD", "Palladium", 106.42, 1.63, 1.5, [0]),
  new Element$a(47, "AG", "Silver", 107.87, 1.72, 1.59, [0]),
  new Element$a(48, "CD", "Cadmium", 112.41, 1.58, 1.69, [0]),
  new Element$a(49, "IN", "Indium", 114.82, 1.93, 1.63, [3]),
  new Element$a(50, "SN", "Tin", 118.71, 2.17, 1.46, [2, 4]),
  new Element$a(51, "SB", "Antimony", 121.75, 2.2, 1.46, [3, 5]),
  new Element$a(52, "TE", "Tellurium", 127.6, 2.06, 1.47, [2, 4, 6]),
  new Element$a(53, "I", "Iodine", 126.91, 2.15, 1.4, [1, 3, 5, 7]),
  new Element$a(54, "XE", "Xenon", 131.29, 2.16, 1.98, [0]),
  new Element$a(55, "CS", "Cesium", 132.91, 1.7, 1.67, [1]),
  new Element$a(56, "BA", "Barium", 137.33, 1.7, 1.34, [2]),
  new Element$a(57, "LA", "Lanthanum", 138.91, 1.7, 1.87, [0]),
  new Element$a(58, "CE", "Cerium", 140.12, 1.7, 1.83, [0]),
  new Element$a(59, "PR", "Praseodymium", 140.91, 1.7, 1.82, [0]),
  new Element$a(60, "ND", "Neodymium", 144.24, 1.7, 1.81, [0]),
  new Element$a(61, "PM", "Promethium", 144.9, 1.7, 1.8, [0]),
  new Element$a(62, "SM", "Samarium", 150.36, 1.7, 1.8, [0]),
  new Element$a(63, "EU", "Europium", 151.96, 1.7, 1.99, [0]),
  new Element$a(64, "GD", "Gadolinium", 157.25, 1.7, 1.79, [0]),
  new Element$a(65, "TB", "Terbium", 158.93, 1.7, 1.76, [0]),
  new Element$a(66, "DY", "Dysprosium", 162.5, 1.7, 1.75, [0]),
  new Element$a(67, "HO", "Holmium", 164.93, 1.7, 1.74, [0]),
  new Element$a(68, "ER", "Erbium", 167.26, 1.7, 1.73, [0]),
  new Element$a(69, "TM", "Thulium", 168.93, 1.7, 1.72, [0]),
  new Element$a(70, "YB", "Ytterbium", 173.04, 1.7, 1.94, [0]),
  new Element$a(71, "LU", "Lutetium", 174.97, 1.7, 1.72, [0]),
  new Element$a(72, "HF", "Hafnium", 178.49, 1.7, 1.57, [0]),
  new Element$a(73, "TA", "Tantalum", 180.95, 1.7, 1.43, [0]),
  new Element$a(74, "W", "Tungsten", 183.85, 1.7, 1.37, [0]),
  new Element$a(75, "RE", "Rhenium", 186.21, 1.7, 1.35, [0]),
  new Element$a(76, "OS", "Osmium", 190.2, 1.7, 1.37, [0]),
  new Element$a(77, "IR", "Iridium", 192.22, 1.7, 1.32, [0]),
  new Element$a(78, "PT", "Platinum", 195.08, 1.72, 1.5, [0]),
  new Element$a(79, "AU", "Gold", 196.97, 1.66, 1.5, [0]),
  new Element$a(80, "HG", "Mercury", 200.59, 1.55, 1.7, [0]),
  new Element$a(81, "TL", "Thallium", 204.38, 1.96, 1.55, [1, 3]),
  new Element$a(82, "PB", "Lead", 207.2, 2.02, 1.54, [2, 4]),
  new Element$a(83, "BI", "Bismuth", 208.98, 1.7, 1.54, [3, 5]),
  new Element$a(84, "PO", "Polonium", 210, 1.7, 1.68, [2, 4, 6]),
  new Element$a(85, "AT", "Astatine", 210, 1.7, 1.7, [1, 3, 5, 7]),
  new Element$a(86, "RN", "Radon", 222, 1.7, 2.4, [0]),
  new Element$a(87, "FR", "Francium", 223, 1.7, 2, [1]),
  new Element$a(88, "RA", "Radium", 226.03, 1.7, 1.9, [2]),
  new Element$a(89, "AC", "Actinium", 227.03, 1.7, 1.88, [0]),
  new Element$a(90, "TH", "Thorium", 232.04, 1.7, 1.79, [0]),
  new Element$a(91, "PA", "Protactinium", 231.04, 1.7, 1.61, [0]),
  new Element$a(92, "U", "Uranium", 238.03, 1.86, 1.58, [0]),
  new Element$a(93, "NP", "Neptunium", 237.05, 1.7, 1.55, [0]),
  new Element$a(94, "PU", "Plutonium", 239.1, 1.7, 1.53, [0]),
  new Element$a(95, "AM", "Americium", 243.1, 1.7, 1.51, [0]),
  new Element$a(96, "CM", "Curium", 247.1, 1.7, 1.5, [0]),
  new Element$a(97, "BK", "Berkelium", 247.1, 1.7, 1.5, [0]),
  new Element$a(98, "CF", "Californium", 252.1, 1.7, 1.5, [0]),
  new Element$a(99, "ES", "Einsteinium", 252.1, 1.7, 1.5, [0]),
  new Element$a(100, "FM", "Fermium", 257.1, 1.7, 1.5, [0]),
  new Element$a(101, "MD", "Mendelevium", 256.1, 1.7, 1.5, [0]),
  new Element$a(102, "NO", "Nobelium", 259.1, 1.7, 1.5, [0]),
  new Element$a(103, "LR", "Lawrencium", 260.1, 1.7, 1.5, [0]),
  new Element$a(104, "RF", "Rutherfordium", 261, 1.7, 1.6, [0]),
  new Element$a(105, "DB", "Dubnium", 262, 1.7, 1.6, [0]),
  new Element$a(106, "SG", "Seaborgium", 263, 1.7, 1.6, [0]),
  new Element$a(107, "BH", "Bohrium", 262, 1.7, 1.6, [0]),
  new Element$a(108, "HS", "Hassium", 265, 1.7, 1.6, [0]),
  new Element$a(109, "MT", "Meitnerium", 268, 1.7, 1.6, [0])
]);
_defineProperty2(Element$a, "ByName", {
  D: new Element$a(1, "D", "Deuterium", 2.014, 1.2, 0.23, [1]),
  T: new Element$a(1, "T", "Tritium", 3.016, 1.2, 0.23, [1])
});
(function() {
  var byAtomicNumber = Element$a.ByAtomicNumber;
  var byName = Element$a.ByName;
  for (var i2 = 0, n2 = byAtomicNumber.length; i2 < n2; ++i2) {
    var element = byAtomicNumber[i2];
    if (element) {
      byName[element.name] = element;
    }
  }
})();
Element$a.getByName = function(element) {
  var type = Element$a.ByName[element];
  if (!type) {
    type = Element$a.ByName[element] = new Element$a(0, element, "Unknown", 0, 1, 0.01, [0]);
  }
  return type;
};
var cBondTypes = {
  UNKNOWN: 0,
  COVALENT: 1,
  AROMATIC: 2
};
function getAtomPos(atom) {
  return atom.position;
}
var Bond$5 = function() {
  function Bond2(left, right, order, type, fixed3) {
    _classCallCheck(this, Bond2);
    this._left = left;
    this._right = right;
    this._fixed = fixed3;
    this._index = -1;
    if (left > right) {
      throw new Error("In a bond atom indices must be in increasing order");
    }
    this._order = order;
    this._type = type;
  }
  _createClass(Bond2, [{
    key: "getLeft",
    value: function getLeft() {
      return this._left;
    }
  }, {
    key: "getRight",
    value: function getRight() {
      return this._right;
    }
  }, {
    key: "getOrder",
    value: function getOrder() {
      return this._order;
    }
  }, {
    key: "calcLength",
    value: function calcLength() {
      return this._left.position.distanceTo(this._right.position);
    }
  }, {
    key: "_forEachNeighbour",
    value: function _forEachNeighbour(currAtom, process2) {
      var bonds = currAtom.bonds;
      for (var i2 = 0, n2 = bonds.length; i2 < n2; ++i2) {
        process2(bonds[i2]._left !== currAtom ? bonds[i2]._left : bonds[i2]._right);
      }
    }
  }, {
    key: "forEachLevelOne",
    value: function forEachLevelOne(process2) {
      var left = this._left;
      var right = this._right;
      this._forEachNeighbour(left, function(atom) {
        if (atom === right) {
          return;
        }
        process2(atom);
      });
      this._forEachNeighbour(right, function(atom) {
        if (atom === left) {
          return;
        }
        process2(atom);
      });
    }
  }, {
    key: "forEachLevelTwo",
    value: function forEachLevelTwo(process2) {
      var left = this._left;
      var right = this._right;
      var self2 = this;
      self2._forEachNeighbour(left, function(atom) {
        if (atom === right) {
          return;
        }
        self2._forEachNeighbour(atom, function(l2Atom) {
          if (l2Atom === left) {
            return;
          }
          process2(l2Atom);
        });
      });
      self2._forEachNeighbour(right, function(atom) {
        if (atom === left) {
          return;
        }
        self2._forEachNeighbour(atom, function(l2Atom) {
          if (l2Atom === right) {
            return;
          }
          process2(l2Atom);
        });
      });
    }
  }, {
    key: "_fixDir",
    value: function _fixDir(refPoint, currDir, posGetter) {
      var rightCount = 0;
      var leftCount = 0;
      var tmpVec = refPoint.clone();
      function checkDir(atom) {
        tmpVec.copy(posGetter(atom));
        tmpVec.sub(refPoint);
        var dotProd = currDir.dot(tmpVec);
        if (dotProd > 0) {
          ++rightCount;
        } else {
          ++leftCount;
        }
      }
      function checkCarbon(atom) {
        if (atom.element.name === "C") {
          checkDir(atom);
        }
      }
      var stages = [[this.forEachLevelOne, checkCarbon], [this.forEachLevelOne, checkDir], [this.forEachLevelTwo, checkCarbon], [this.forEachLevelTwo, checkDir]];
      for (var stageId = 0; stageId < stages.length; ++stageId) {
        stages[stageId][0].call(this, stages[stageId][1]);
        if (leftCount > rightCount) {
          return currDir.multiplyScalar(-1);
        }
        if (leftCount < rightCount) {
          return currDir;
        }
      }
      return currDir;
    }
  }, {
    key: "calcNormalDir",
    value: function calcNormalDir(posGetter) {
      var left = this._left;
      var right = this._right;
      var first = left;
      var second = right;
      posGetter = posGetter === void 0 ? getAtomPos : posGetter;
      if (left.bonds.length > right.bonds.length) {
        first = right;
        second = left;
      }
      var third = first;
      var maxNeibs = 0;
      var _second = second, bonds = _second.bonds;
      for (var i2 = 0, n2 = bonds.length; i2 < n2; ++i2) {
        var another = bonds[i2]._left;
        if (bonds[i2]._left === second) {
          another = bonds[i2]._right;
        }
        if (another.bonds.length > maxNeibs && another !== first) {
          third = another;
          maxNeibs = another.bonds.length;
        }
      }
      var secondPos = posGetter(second);
      var firstV = posGetter(first).clone().sub(secondPos);
      var secondV = posGetter(third).clone().sub(secondPos);
      secondV.crossVectors(firstV, secondV);
      if (secondV.lengthSq() < 1e-4) {
        secondV.set(0, 1, 0);
      }
      firstV.normalize();
      secondV.normalize();
      firstV.crossVectors(secondV, firstV);
      if (firstV.lengthSq() < 1e-4) {
        firstV.set(0, 1, 0);
      }
      firstV.normalize();
      return this._fixDir(secondPos, firstV, posGetter);
    }
  }]);
  return Bond2;
}();
_defineProperty2(Bond$5, "BondType", cBondTypes);
Bond$5.prototype.BondType = cBondTypes;
var cNucleicControlNames = ["C3'", "C3*", "P", "H5T", "H3T"];
var cNucleicWing1Names = ["OP1", "O1P"];
var cNucleicWing2Names = ["OP2", "O2P"];
var cCylinderSource = ["C3'", "C3*", "C1", "C1'", "C1*", "P"];
var cCylinderTarget = [{
  types: ["A", "DA", "G", "DG"],
  atoms: ["N1"]
}, {
  types: ["C", "DC"],
  atoms: ["N3"]
}, {
  types: ["T", "DT", "U", "DU"],
  atoms: ["O4"]
}];
var Residue$1 = function() {
  function Residue2(chain2, type, sequence2, icode) {
    _classCallCheck(this, Residue2);
    this._chain = chain2;
    this._component = null;
    this._type = type;
    this._sequence = sequence2;
    this._icode = icode;
    this._mask = 1 | 0;
    this._index = -1;
    this._atoms = [];
    this._secondary = null;
    this._firstAtom = null;
    this._leadAtom = null;
    this._wingAtom = null;
    this._lastAtom = null;
    this._controlPoint = null;
    this._midPoint = null;
    this._wingVector = null;
    this._cylinders = null;
    this._isValid = true;
    this._het = false;
    this._molecule = null;
    this.temperature = null;
    this.occupancy = null;
  }
  _createClass(Residue2, [{
    key: "getChain",
    value: function getChain() {
      return this._chain;
    }
  }, {
    key: "getMolecule",
    value: function getMolecule() {
      return this._molecule;
    }
  }, {
    key: "getType",
    value: function getType() {
      return this._type;
    }
  }, {
    key: "getSequence",
    value: function getSequence() {
      return this._sequence;
    }
  }, {
    key: "getSecondary",
    value: function getSecondary() {
      return this._secondary;
    }
  }, {
    key: "getICode",
    value: function getICode() {
      return this._icode;
    }
  }, {
    key: "addAtom",
    value: function addAtom(name2, type, xyz, role, het, serial2, altLoc, occupancy, tempFactor, charge) {
      var atom = new Atom$2(this, name2, type, xyz, role, het, serial2, altLoc, occupancy, tempFactor, charge);
      var complex = this._chain.getComplex();
      complex.addAtom(atom);
      this._atoms.push(atom);
      this._het = this._het || het;
      return atom;
    }
  }, {
    key: "getAtomCount",
    value: function getAtomCount() {
      return this._atoms.length;
    }
  }, {
    key: "forEachAtom",
    value: function forEachAtom(process2) {
      var atoms = this._atoms;
      for (var i2 = 0, n2 = atoms.length; i2 < n2; ++i2) {
        if (process2(atoms[i2])) {
          break;
        }
      }
    }
  }, {
    key: "_findAtomByName",
    value: function _findAtomByName(name2) {
      var res = null;
      this.forEachAtom(function(atom) {
        if (atom.name === name2) {
          res = atom;
          return true;
        }
        return false;
      });
      return res;
    }
  }, {
    key: "_findFirstAtomInList",
    value: function _findFirstAtomInList(names) {
      var res = null;
      for (var i2 = 0; i2 < names.length; ++i2) {
        res = this._findAtomByName(names[i2]);
        if (res !== null) {
          return res;
        }
      }
      return res;
    }
  }, {
    key: "collectMask",
    value: function collectMask() {
      var mask = 4294967295;
      var atoms = this._atoms;
      for (var i2 = 0, n2 = atoms.length; i2 < n2; ++i2) {
        mask &= atoms[i2].mask;
      }
      this._mask = mask;
    }
  }, {
    key: "getCylinderTargetList",
    value: function getCylinderTargetList() {
      var type = this._type._name;
      for (var i2 = 0, n2 = cCylinderTarget.length; i2 < n2; ++i2) {
        for (var j2 = 0, m2 = cCylinderTarget[i2].types.length; j2 < m2; ++j2) {
          if (type === cCylinderTarget[i2].types[j2]) {
            return cCylinderTarget[i2].atoms;
          }
        }
      }
      return null;
    }
  }, {
    key: "_detectLeadWing",
    value: function _detectLeadWing(dst, next, getAtomPosition) {
      var leadAtom = this._findFirstAtomInList(cNucleicControlNames);
      var wingStart = this._findFirstAtomInList(cNucleicWing1Names);
      var wingEnd = this._findFirstAtomInList(cNucleicWing2Names);
      if (wingStart === null && next !== null) {
        wingStart = next._findFirstAtomInList(cNucleicWing1Names);
      }
      if (wingEnd === null && next !== null) {
        wingEnd = next._findFirstAtomInList(cNucleicWing2Names);
      }
      if (leadAtom === null || wingStart === null || wingEnd === null) {
        return;
      }
      dst._leadAtom = leadAtom;
      dst._controlPoint = getAtomPosition(leadAtom);
      dst._wingVector = getAtomPosition(wingEnd).clone().sub(getAtomPosition(wingStart));
      dst._isValid = true;
      var cylSource = this._findFirstAtomInList(cCylinderSource);
      var targetList = this.getCylinderTargetList();
      var cylTarget = targetList !== null ? this._findFirstAtomInList(targetList) : null;
      if (cylSource === null || cylTarget === null) {
        return;
      }
      dst._cylinders = [getAtomPosition(cylSource), getAtomPosition(cylTarget)];
    }
  }, {
    key: "calcWing",
    value: function calcWing(prevLeadPos, currLeadPos, prevWingPos, prevWing) {
      var vectorA = currLeadPos.clone().sub(prevLeadPos);
      var vectorB = prevLeadPos.clone().sub(prevWingPos);
      vectorB.crossVectors(vectorA, vectorB);
      vectorB.crossVectors(vectorA, vectorB).normalize();
      if (prevWing !== null && prevWing.length() > 1e-4) {
        var needToNegate = vectorB.length() > 1e-4 && Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2;
        if (needToNegate) {
          vectorB.negate();
        }
      }
      return vectorB;
    }
  }, {
    key: "_innerFinalize",
    value: function _innerFinalize(prevRes, prev, nextRes, dst, chainAsNucleic, getAtomPosition) {
      var bFirstInChain = prev === null;
      var lp = getAtomPosition(this._leadAtom);
      var currLeadPos = new Vector3(lp.x, lp.y, lp.z);
      if (chainAsNucleic) {
        this._detectLeadWing(dst, nextRes, getAtomPosition);
        return;
      }
      if (bFirstInChain) {
        dst._midPoint = getAtomPosition(this._firstAtom).clone();
      } else {
        var prevLeadPos = prev._controlPoint;
        dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5);
        dst._wingVector = this.calcWing(prevLeadPos, currLeadPos, getAtomPosition(prevRes._wingAtom), prev._wingVector);
      }
      dst._controlPoint = currLeadPos;
    }
  }, {
    key: "_finalize2",
    value: function _finalize2(prev, next, asNucleic) {
      this._innerFinalize(prev, prev, next, this, asNucleic, function(atom) {
        return atom.position;
      });
    }
  }, {
    key: "isConnected",
    value: function isConnected(anotherResidue) {
      if (this._chain !== anotherResidue._chain) {
        return false;
      }
      if (this === anotherResidue) {
        return true;
      }
      var res = false;
      this.forEachAtom(function(atom) {
        var bonds = atom.bonds;
        for (var i2 = 0, n2 = bonds.length; i2 < n2; ++i2) {
          var bond = bonds[i2];
          if (bond._left.residue === anotherResidue || bond._right.residue === anotherResidue) {
            res = true;
            return true;
          }
        }
        return false;
      });
      return res;
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      var self2 = this;
      var _this$_atoms = _slicedToArray(this._atoms, 1);
      this._firstAtom = _this$_atoms[0];
      this._lastAtom = this._atoms[this._atoms.length - 1];
      this._leadAtom = null;
      this._wingAtom = null;
      var tempCount = 0;
      var temperature = 0;
      var occupCount = 0;
      var occupancy = 0;
      this.forEachAtom(function(a2) {
        if (self2._leadAtom === null) {
          if (a2.role === Element$a.Constants.Lead) {
            self2._leadAtom = a2;
          }
        }
        if (self2._wingAtom === null) {
          if (a2.role === Element$a.Constants.Wing) {
            self2._wingAtom = a2;
          }
        }
        if (a2.temperature) {
          temperature += a2.temperature;
          tempCount++;
        }
        if (a2.occupancy) {
          occupancy += a2.occupancy;
          occupCount++;
        }
        return self2._leadAtom !== null && self2._wingAtom !== null;
      });
      if (tempCount > 0) {
        this.temperature = temperature / tempCount;
      }
      if (occupCount > 0) {
        this.occupancy = occupancy / occupCount;
      }
      if (this._leadAtom === null || this._wingAtom === null) {
        this._isValid = false;
      }
      if (this._leadAtom === null) {
        this._leadAtom = this._firstAtom;
      }
      if (this._wingAtom === null) {
        this._wingAtom = this._lastAtom;
      }
    }
  }]);
  return Residue2;
}();
var ResidueType$1 = function() {
  function ResidueType2(name2, fullName, letterCode) {
    _classCallCheck(this, ResidueType2);
    this._name = name2;
    this._fullName = fullName;
    this.letterCode = letterCode;
    this.flags = 0;
  }
  _createClass(ResidueType2, [{
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }]);
  return ResidueType2;
}();
_defineProperty2(ResidueType$1, "StandardTypes", {
  ALA: new ResidueType$1("ALA", "Alanine", "A"),
  ARG: new ResidueType$1("ARG", "Arginine", "R"),
  ASN: new ResidueType$1("ASN", "Asparagine", "N"),
  ASP: new ResidueType$1("ASP", "Aspartic Acid", "D"),
  CYS: new ResidueType$1("CYS", "Cysteine", "C"),
  GLN: new ResidueType$1("GLN", "Glutamine", "Q"),
  GLU: new ResidueType$1("GLU", "Glutamic Acid", "E"),
  GLY: new ResidueType$1("GLY", "Glycine", "G"),
  HIS: new ResidueType$1("HIS", "Histidine", "H"),
  ILE: new ResidueType$1("ILE", "Isoleucine", "I"),
  LEU: new ResidueType$1("LEU", "Leucine", "L"),
  LYS: new ResidueType$1("LYS", "Lysine", "K"),
  MET: new ResidueType$1("MET", "Methionine", "M"),
  PHE: new ResidueType$1("PHE", "Phenylalanine", "F"),
  PRO: new ResidueType$1("PRO", "Proline", "P"),
  PYL: new ResidueType$1("PYL", "Pyrrolysine", "O"),
  SEC: new ResidueType$1("SEC", "Selenocysteine", "U"),
  SER: new ResidueType$1("SER", "Serine", "S"),
  THR: new ResidueType$1("THR", "Threonine", "T"),
  TRP: new ResidueType$1("TRP", "Tryptophan", "W"),
  TYR: new ResidueType$1("TYR", "Tyrosine", "Y"),
  VAL: new ResidueType$1("VAL", "Valine", "V"),
  A: new ResidueType$1("A", "Adenine", "A"),
  C: new ResidueType$1("C", "Cytosine", "C"),
  G: new ResidueType$1("G", "Guanine", "G"),
  I: new ResidueType$1("I", "Inosine", "I"),
  T: new ResidueType$1("T", "Thymine", "T"),
  U: new ResidueType$1("U", "Uracil", "U"),
  DA: new ResidueType$1("DA", "Adenine", "A"),
  DC: new ResidueType$1("DC", "Cytosine", "C"),
  DG: new ResidueType$1("DG", "Guanine", "G"),
  DI: new ResidueType$1("DI", "Inosine", "I"),
  DT: new ResidueType$1("DT", "Thymine", "T"),
  DU: new ResidueType$1("DU", "Uracil", "U"),
  "+A": new ResidueType$1("+A", "Adenine", "A"),
  "+C": new ResidueType$1("+C", "Cytosine", "C"),
  "+G": new ResidueType$1("+G", "Guanine", "G"),
  "+I": new ResidueType$1("+I", "Inosine", "I"),
  "+T": new ResidueType$1("+T", "Thymine", "T"),
  "+U": new ResidueType$1("+U", "Uracil", "U"),
  WAT: new ResidueType$1("WAT", "Water", ""),
  H2O: new ResidueType$1("H2O", "Water", ""),
  HOH: new ResidueType$1("HOH", "Water", ""),
  DOD: new ResidueType$1("DOD", "Water", ""),
  UNK: new ResidueType$1("UNK", "Unknown", ""),
  UNL: new ResidueType$1("UNL", "Unknown Ligand", "")
});
_defineProperty2(ResidueType$1, "Flags", {
  PROTEIN: 1,
  BASIC: 2,
  ACIDIC: 4,
  POLAR: 8,
  NONPOLAR: 16,
  AROMATIC: 32,
  NUCLEIC: 256,
  PURINE: 512,
  PYRIMIDINE: 1024,
  DNA: 2048,
  RNA: 4096,
  WATER: 65536
});
function _addFlag(flag, list) {
  for (var i2 = 0, n2 = list.length; i2 < n2; ++i2) {
    var res = ResidueType$1.StandardTypes[list[i2]];
    if (res) {
      res.flags |= flag;
    }
  }
}
var Flags = ResidueType$1.Flags;
_addFlag(Flags.WATER, ["WAT", "H2O", "HOH", "DOD"]);
_addFlag(Flags.PROTEIN, ["ALA", "ARG", "ASN", "ASP", "CYS", "GLY", "GLU", "GLN", "HIS", "ILE", "LEU", "LYS", "MET", "PHE", "PRO", "PYL", "SEC", "SER", "THR", "TRP", "TYR", "VAL"]);
_addFlag(Flags.BASIC, ["ARG", "HIS", "LYS"]);
_addFlag(Flags.ACIDIC, ["ASP", "GLU"]);
_addFlag(Flags.POLAR, ["ASN", "CYS", "GLN", "SER", "THR", "TYR"]);
_addFlag(Flags.NONPOLAR, ["ALA", "ILE", "LEU", "MET", "PHE", "PRO", "TRP", "VAL", "GLY"]);
_addFlag(Flags.AROMATIC, ["PHE", "TRP", "TYR"]);
_addFlag(Flags.NUCLEIC, ["A", "G", "I", "DA", "DG", "DI", "+A", "+G", "+I", "C", "T", "U", "DC", "DT", "DU", "+C", "+T", "+U"]);
_addFlag(Flags.PURINE, ["A", "G", "I", "DA", "DG", "DI", "+A", "+G", "+I"]);
_addFlag(Flags.PYRIMIDINE, ["C", "T", "U", "DC", "DT", "DU", "+C", "+T", "+U"]);
_addFlag(Flags.DNA, ["DA", "DG", "DI", "DC", "DT", "DU"]);
_addFlag(Flags.RNA, ["A", "G", "I", "C", "T", "U"]);
var hydro = {
  ILE: 4.5,
  VAL: 4.2,
  LEU: 3.8,
  PHE: 2.8,
  CYS: 2.5,
  MET: 1.9,
  ALA: 1.8,
  GLY: -0.4,
  THR: -0.7,
  SER: -0.8,
  TRP: -0.9,
  TYR: -1.3,
  PRO: -1.6,
  HIS: -3.2,
  GLU: -3.5,
  GLN: -3.5,
  ASP: -3.5,
  ASN: -3.5,
  LYS: -3.9,
  ARG: -4.5
};
function _addParam(param, list) {
  var keys2 = Object.keys(list);
  for (var i2 = 0, n2 = keys2.length; i2 < n2; ++i2) {
    var key = keys2[i2];
    var value = list[key];
    ResidueType$1.StandardTypes[key][param] = value;
  }
}
_addParam("hydrophobicity", hydro);
var ChainType = {
  UNKNOWN: 0,
  PROTEIN: 1,
  NUCLEIC: 2
};
var Chain$2 = function() {
  function Chain2(complex, name2) {
    _classCallCheck(this, Chain2);
    this._complex = complex;
    this._name = name2;
    this._mask = 1 | 0;
    this._index = -1;
    this._residues = [];
    this.minSequence = Number.POSITIVE_INFINITY;
    this.maxSequence = Number.NEGATIVE_INFINITY;
  }
  _createClass(Chain2, [{
    key: "getComplex",
    value: function getComplex() {
      return this._complex;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }, {
    key: "getResidues",
    value: function getResidues() {
      return this._residues;
    }
  }, {
    key: "_determineType",
    value: function _determineType() {
      var residues = this._residues;
      var _ResidueType$Flags = ResidueType$1.Flags, PROTEIN = _ResidueType$Flags.PROTEIN, NUCLEIC = _ResidueType$Flags.NUCLEIC;
      this.type = ChainType.UNKNOWN;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        var flags = residues[i2]._type.flags;
        if ((flags & NUCLEIC) !== 0) {
          this.type = ChainType.NUCLEIC;
          break;
        } else if ((flags & PROTEIN) !== 0) {
          this.type = ChainType.PROTEIN;
          break;
        }
      }
    }
  }, {
    key: "findResidue",
    value: function findResidue(seqNum, iCode) {
      var residues = this._residues;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        var res = residues[i2];
        if (res._sequence === seqNum && res._icode === iCode) {
          return [res, i2];
        }
      }
      return null;
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      this._determineType();
      var residues = this._residues;
      var prev = null;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        var next = i2 + 1 < n2 ? residues[i2 + 1] : null;
        var curr = residues[i2];
        {
          curr._finalize2(prev, next, this.type === ChainType.NUCLEIC);
          prev = curr;
        }
      }
      if (residues.length > 1 && residues[1]._wingVector) {
        var p2 = residues[1]._wingVector;
        residues[0]._wingVector = new Vector3(p2.x, p2.y, p2.z);
      } else if (residues.length > 0) {
        residues[0]._wingVector = new Vector3(1, 0, 0);
      }
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var residues = this._residues;
      var prev = null;
      var prevData = null;
      var frameRes = frameData._residues;
      var n2 = residues.length;
      function getAtomPos2(atom) {
        return frameData.getAtomPos(atom.index);
      }
      for (var i2 = 0; i2 < n2; ++i2) {
        var curr = residues[i2];
        var currData = frameRes[curr._index];
        var nextRes = i2 + 1 < n2 ? residues[i2 + 1] : null;
        curr._innerFinalize(prev, prevData, nextRes, currData, this.type === ChainType.NUCLEIC, getAtomPos2);
        prev = curr;
        prevData = currData;
      }
      frameRes[residues[0]._index]._wingVector = n2 > 1 ? frameRes[residues[1]._index]._wingVector : new Vector3(1, 0, 0);
    }
  }, {
    key: "addResidue",
    value: function addResidue(name2, sequence2, iCode) {
      var type = this._complex.getResidueType(name2);
      if (type === null) {
        type = this._complex.addResidueType(name2);
      }
      var residue2 = new Residue$1(this, type, sequence2, iCode);
      this._complex.addResidue(residue2);
      this._residues.push(residue2);
      if (type.flags & (ResidueType$1.Flags.NUCLEIC | ResidueType$1.Flags.PROTEIN)) {
        if (this.maxSequence < sequence2) {
          this.maxSequence = sequence2;
        }
        if (this.minSequence > sequence2) {
          this.minSequence = sequence2;
        }
      }
      return residue2;
    }
  }, {
    key: "getResidueCount",
    value: function getResidueCount() {
      return this._residues.length;
    }
  }, {
    key: "forEachResidue",
    value: function forEachResidue(process2) {
      var residues = this._residues;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        process2(residues[i2]);
      }
    }
  }, {
    key: "collectMask",
    value: function collectMask() {
      var mask = 4294967295;
      var residues = this._residues;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        mask &= residues[i2]._mask;
      }
      this._mask = mask;
    }
  }]);
  return Chain2;
}();
var _StructuralElement$ge;
var StructuralElement = function() {
  function StructuralElement2(type, init2, term) {
    _classCallCheck(this, StructuralElement2);
    this.type = type;
    this.generic = StructuralElement2.genericByType[this.type] || "loop";
    this.init = init2;
    this.term = term;
  }
  _createClass(StructuralElement2, [{
    key: "_finalize",
    value: function _finalize(serialAtomMap, residueHash, complex) {
      if (this.init instanceof Residue$1 && this.term instanceof Residue$1) {
        return;
      }
      var start = complex.splitUnifiedSerial(this.init);
      var end = complex.splitUnifiedSerial(this.term);
      for (var chainId = start.chain; chainId <= end.chain; chainId++) {
        for (var serialId = start.serial; serialId <= end.serial; serialId++) {
          for (var iCode = start.iCode; iCode <= end.iCode; iCode++) {
            var hashCode = complex.getUnifiedSerial(chainId, serialId, iCode);
            if (residueHash[hashCode]) {
              residueHash[hashCode]._secondary = this;
            }
          }
        }
      }
      this.init = residueHash[this.init];
      this.term = residueHash[this.term];
    }
  }]);
  return StructuralElement2;
}();
StructuralElement.Type = {
  STRAND: "E",
  BRIDGE: "B",
  HELIX_310: "G",
  HELIX_ALPHA: "H",
  HELIX_PI: "I",
  HELIX: "X",
  TURN_310: "3",
  TURN_ALPHA: "4",
  TURN_PI: "5",
  TURN: "T",
  BEND: "S",
  COIL: "C"
};
StructuralElement.Generic = {
  STRAND: "strand",
  HELIX: "helix",
  LOOP: "loop"
};
var StructuralElementType$5 = StructuralElement.Type;
var StructuralElementGeneric = StructuralElement.Generic;
StructuralElement.genericByType = (_StructuralElement$ge = {}, _defineProperty2(_StructuralElement$ge, StructuralElementType$5.STRAND, StructuralElementGeneric.STRAND), _defineProperty2(_StructuralElement$ge, StructuralElementType$5.HELIX_310, StructuralElementGeneric.HELIX), _defineProperty2(_StructuralElement$ge, StructuralElementType$5.HELIX_ALPHA, StructuralElementGeneric.HELIX), _defineProperty2(_StructuralElement$ge, StructuralElementType$5.HELIX_PI, StructuralElementGeneric.HELIX), _defineProperty2(_StructuralElement$ge, StructuralElementType$5.HELIX, StructuralElementGeneric.HELIX), _StructuralElement$ge);
function _createSuper$20(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$20();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$20() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var StructuralElementType$4 = StructuralElement.Type;
var typeByPDBHelixClass = {
  1: StructuralElementType$4.HELIX_ALPHA,
  3: StructuralElementType$4.HELIX_PI,
  5: StructuralElementType$4.HELIX_310
};
var Helix$3 = function(_StructuralElement) {
  _inherits(Helix2, _StructuralElement);
  var _super = _createSuper$20(Helix2);
  function Helix2(helixClass, init2, term, serial2, name2, comment, length) {
    var _this;
    _classCallCheck(this, Helix2);
    _this = _super.call(this, typeByPDBHelixClass[helixClass] || StructuralElement.Type.HELIX, init2, term);
    _this.serial = serial2;
    _this.name = name2;
    _this.comment = comment;
    _this.length = length;
    return _this;
  }
  return _createClass(Helix2);
}(StructuralElement);
function _superPropBase(object4, property) {
  while (!Object.prototype.hasOwnProperty.call(object4, property)) {
    object4 = _getPrototypeOf(object4);
    if (object4 === null) break;
  }
  return object4;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _createSuper$1$(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1$() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Strand$3 = function(_StructuralElement) {
  _inherits(Strand2, _StructuralElement);
  var _super = _createSuper$1$(Strand2);
  function Strand2(sheet, init2, term, sense, atomCur, atomPrev) {
    var _this;
    _classCallCheck(this, Strand2);
    _this = _super.call(this, StructuralElement.Type.STRAND, init2, term);
    _this.sheet = sheet;
    _this.sense = sense;
    _this.atomCur = atomCur;
    _this.atomPrev = atomPrev;
    return _this;
  }
  _createClass(Strand2, [{
    key: "_finalize",
    value: function _finalize(serialAtomMap, residueHash, complex) {
      _get(_getPrototypeOf(Strand2.prototype), "_finalize", this).call(this, serialAtomMap, residueHash, complex);
      var as = this.atomCur;
      if (as !== null && !Number.isNaN(as)) {
        this.atomCur = serialAtomMap[as];
      }
      as = this.atomPrev;
      if (as !== null && !Number.isNaN(as)) {
        this.atomPrev = serialAtomMap[as];
      }
    }
  }]);
  return Strand2;
}(StructuralElement);
var Sheet$3 = function() {
  function Sheet2(name2, width) {
    _classCallCheck(this, Sheet2);
    this._name = name2;
    this._width = width;
    this._strands = [];
  }
  _createClass(Sheet2, [{
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this._width;
    }
  }, {
    key: "addStrand",
    value: function addStrand(strand) {
      this._strands.push(strand);
      this._width = this._strands.length;
    }
  }, {
    key: "addEmptyStrand",
    value: function addEmptyStrand() {
      this._strands.push(new Strand$3(null, null, null, null, null, null));
    }
  }, {
    key: "_finalize",
    value: function _finalize(serialAtomMap, residueHash, complex) {
      var s2 = this._strands;
      for (var i2 = 0, n2 = s2.length; i2 < n2; ++i2) {
        s2[i2]._finalize(serialAtomMap, residueHash, complex);
      }
      if (!this._width) {
        this._width = s2.length;
      }
      if (s2.length !== this._width) {
        throw new Error("Sheet ".concat(this._name, " is inconsistent."));
      }
    }
  }]);
  return Sheet2;
}();
var SGroup$1 = function() {
  function SGroup2(id, name2, position, atoms, saveNode) {
    _classCallCheck(this, SGroup2);
    this._id = id;
    this._name = name2;
    this._position = position || new Vector3();
    this._atoms = atoms || [];
    this._charge = 0;
    this._repeat = 1;
    this._center = null;
    this.xmlNodeRef = saveNode || null;
  }
  _createClass(SGroup2, [{
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return this._position;
    }
  }, {
    key: "getCentralPoint",
    value: function getCentralPoint() {
      return this._center;
    }
  }, {
    key: "_rebuildSGroupOnAtomChange",
    value: function _rebuildSGroupOnAtomChange() {
      var nLimon = 1e8;
      if (this._center === null) {
        return;
      }
      var bLow = new Vector3(nLimon, nLimon, nLimon);
      var bHight = new Vector3(-nLimon, -nLimon, -nLimon);
      for (var j2 = 0, n2 = this._atoms.length; j2 < n2; j2++) {
        var aPos = this._atoms[j2].position;
        bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
        bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
      }
      this._center.addVectors(bLow, bHight);
      this._center.multiplyScalar(0.5);
    }
  }]);
  return SGroup2;
}();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var parser$1 = function() {
  var o2 = function o3(k2, v2, _o, l2) {
    for (_o = _o || {}, l2 = k2.length; l2--; _o[k2[l2]] = v2) {
    }
    return _o;
  }, $V0 = [1, 4], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 8], $V5 = [1, 9], $V6 = [1, 11], $V7 = [1, 12], $V8 = [5, 7, 8, 11], $V9 = [1, 17], $Va = [1, 22], $Vb = [1, 20], $Vc = [1, 21], $Vd = [5, 7, 8, 11, 19];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: {
      error: 2,
      Program: 3,
      Expression: 4,
      EOF: 5,
      Selector: 6,
      OR: 7,
      AND: 8,
      NOT: 9,
      "(": 10,
      ")": 11,
      SELECTOR: 12,
      NAMED_SELECTOR: 13,
      SELECTOR_RANGED: 14,
      RangeList: 15,
      SELECTOR_NAMED: 16,
      NameList: 17,
      Range: 18,
      ",": 19,
      NUMBER: 20,
      ":": 21,
      Name: 22,
      IDENTIFIER: 23,
      STRING: 24,
      $accept: 0,
      $end: 1
    },
    terminals_: {
      2: "error",
      5: "EOF",
      7: "OR",
      8: "AND",
      9: "NOT",
      10: "(",
      11: ")",
      12: "SELECTOR",
      13: "NAMED_SELECTOR",
      14: "SELECTOR_RANGED",
      16: "SELECTOR_NAMED",
      19: ",",
      20: "NUMBER",
      21: ":",
      23: "IDENTIFIER",
      24: "STRING"
    },
    productions_: [0, [3, 2], [4, 1], [4, 3], [4, 3], [4, 2], [4, 3], [6, 1], [6, 1], [6, 2], [6, 2], [15, 1], [15, 3], [18, 1], [18, 3], [17, 1], [17, 3], [22, 1], [22, 1], [22, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
        case 3:
          this.$ = yy.keyword("or")($$[$0 - 2], $$[$0]);
          break;
        case 4:
          this.$ = yy.keyword("and")($$[$0 - 2], $$[$0]);
          break;
        case 5:
          this.$ = yy.keyword("not")($$[$0]);
          break;
        case 6:
          this.$ = $$[$0 - 1];
          break;
        case 7:
          this.$ = yy.keyword($$[$0])();
          break;
        case 8:
          this.$ = yy.GetSelector($$[$0].toLowerCase().slice(1, $$[$0].length));
          break;
        case 9:
        case 10:
          this.$ = yy.keyword($$[$0 - 1])($$[$0]);
          break;
        case 11:
          this.$ = new yy.RangeList($$[$0]);
          break;
        case 12:
        case 16:
          this.$ = $$[$0 - 2].append($$[$0]);
          break;
        case 13:
          this.$ = new yy.Range(Number($$[$0]));
          break;
        case 14:
          this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
          break;
        case 15:
          this.$ = new yy.ValueList($$[$0]);
          break;
      }
    },
    table: [{
      3: 1,
      4: 2,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, {
      1: [3]
    }, {
      5: [1, 10],
      7: $V6,
      8: $V7
    }, o2($V8, [2, 2]), {
      4: 13,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, {
      4: 14,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, o2($V8, [2, 7]), o2($V8, [2, 8]), {
      15: 15,
      18: 16,
      20: $V9
    }, {
      17: 18,
      20: $Va,
      22: 19,
      23: $Vb,
      24: $Vc
    }, {
      1: [2, 1]
    }, {
      4: 23,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, {
      4: 24,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, o2($V8, [2, 5]), {
      7: $V6,
      8: $V7,
      11: [1, 25]
    }, o2($V8, [2, 9], {
      19: [1, 26]
    }), o2($Vd, [2, 11]), o2($Vd, [2, 13], {
      21: [1, 27]
    }), o2($V8, [2, 10], {
      19: [1, 28]
    }), o2($Vd, [2, 15]), o2($Vd, [2, 17]), o2($Vd, [2, 18]), o2($Vd, [2, 19]), o2([5, 7, 11], [2, 3], {
      8: $V7
    }), o2($V8, [2, 4]), o2($V8, [2, 6]), {
      18: 29,
      20: $V9
    }, {
      20: [1, 30]
    }, {
      20: $Va,
      22: 31,
      23: $Vb,
      24: $Vc
    }, o2($Vd, [2, 12]), o2($Vd, [2, 14]), o2($Vd, [2, 16])],
    defaultActions: {
      10: [2, 1]
    },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self2 = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = {
        yy: {}
      };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token;
        token = tstack.pop() || lexer2.lex() || EOF;
        if (typeof token !== "number") {
          if (token instanceof Array) {
            tstack = token;
            token = tstack.pop();
          }
          token = self2.symbols_[token] || token;
        }
        return token;
      }
      var symbol5, state, action, r2, yyval = {}, p2, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol5 === null || typeof symbol5 == "undefined") {
            symbol5 = lex();
          }
          action = table[state] && table[state][symbol5];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p2 in table[state]) {
            if (this.terminals_[p2] && p2 > TERROR) {
              expected.push("'" + this.terminals_[p2] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol5] || symbol5) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol5 == EOF ? "end of input" : "'" + (this.terminals_[symbol5] || symbol5) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol5] || symbol5,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol5);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol5);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol5 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r2 = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
            if (typeof r2 !== "undefined") {
              return r2;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = /* @__PURE__ */ function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function setInput(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function input() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function unput(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r2 = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function more() {
        this._more = true;
        return this;
      },
      reject: function reject() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function less(n2) {
        this.unput(this.match.slice(n2));
      },
      pastInput: function pastInput() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function upcomingInput() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function showPosition() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function test_match(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function next() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i2 = 0; i2 < rules.length; i2++) {
          tempMatch = this._input.match(this.rules[rules[i2]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i2;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i2]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r2 = this.next();
        if (r2) {
          return r2;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n2 = this.conditionStack.length - 1;
        if (n2 > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n2) {
        n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
        if (n2 >= 0) {
          return this.conditionStack[n2];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {
        "case-insensitive": true
      },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 20;
          case 2:
            return 7;
          case 3:
            return 8;
          case 4:
            return 9;
          case 5:
            return 12;
          case 6:
            return 16;
          case 7:
            return 14;
          case 8:
            return 10;
          case 9:
            return 11;
          case 10:
            return 19;
          case 11:
            return 21;
          case 12:
            return "<=";
          case 13:
            return ">=";
          case 14:
            return "<";
          case 15:
            return ">";
          case 16:
            yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
            return 24;
          case 17:
            return 13;
          case 18:
            return 23;
          case 19:
            return 5;
          case 20:
            return "INVALID";
        }
      },
      rules: [/^(?:\s+)/i, /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i, /^(?:OR\b)/i, /^(?:AND\b)/i, /^(?:NOT\b)/i, /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i, /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i, /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i, /^(?:\()/i, /^(?:\))/i, /^(?:,)/i, /^(?::)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:(@[_A-Z0-9]+))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:.)/i],
      conditions: {
        INITIAL: {
          rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
          inclusive: true
        }
      }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
var SelectionParser = {
  parser: parser$1
};
function _createSuper$1_(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1_();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1_() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Range = function() {
  function Range2(min, max) {
    _classCallCheck(this, Range2);
    this.min = min;
    this.max = typeof max === "undefined" ? min : max;
  }
  _createClass(Range2, [{
    key: "includes",
    value: function includes(value) {
      return this.min <= value && value <= this.max;
    }
  }, {
    key: "toString",
    value: function toString3() {
      var min = this.min, max = this.max;
      return min === max ? String(min) : [min, max].join(":");
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      return [this.min, this.max];
    }
  }]);
  return Range2;
}();
var List = function() {
  function List2(arg) {
    _classCallCheck(this, List2);
    if (arg instanceof this.constructor) {
      return arg;
    }
    if (arg instanceof Array) {
      this._values = arg.slice(0);
    } else if (arg) {
      this._values = [arg];
    } else {
      this._values = [];
    }
  }
  _createClass(List2, [{
    key: "append",
    value: function append(value) {
      var values = this._values;
      values[values.length] = value;
      return this;
    }
  }, {
    key: "remove",
    value: function remove3(value) {
      var values = this._values;
      var index = values.indexOf(value);
      if (index >= 0) {
        values.splice(index, 1);
      }
      return this;
    }
  }, {
    key: "toString",
    value: function toString3() {
      return this._values.join(",");
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      var values = this._values;
      var result = [];
      for (var i2 = 0, n2 = values.length; i2 < n2; ++i2) {
        var value = values[i2];
        result[i2] = value.toJSON ? value.toJSON() : value;
      }
      return result;
    }
  }]);
  return List2;
}();
var RangeList = function(_List) {
  _inherits(RangeList2, _List);
  var _super = _createSuper$1_(RangeList2);
  function RangeList2() {
    _classCallCheck(this, RangeList2);
    return _super.apply(this, arguments);
  }
  _createClass(RangeList2, [{
    key: "includes",
    value: function includes(value) {
      var list = this._values;
      for (var i2 = 0, n2 = list.length; i2 < n2; ++i2) {
        if (list[i2].includes(value)) {
          return true;
        }
      }
      return false;
    }
  }]);
  return RangeList2;
}(List);
var valuesArray = [];
var ValueList = function(_List2) {
  _inherits(ValueList2, _List2);
  var _super2 = _createSuper$1_(ValueList2);
  function ValueList2(arg, upperOnly) {
    var _this;
    _classCallCheck(this, ValueList2);
    var list = _this = _super2.call(this, arg);
    if (upperOnly) {
      _this.upperOnly = true;
      var values = list._values;
      for (var i2 = 0, n2 = values.length; i2 < n2; ++i2) {
        var value = values[i2];
        if (typeof value === "string") {
          values[i2] = value.toUpperCase();
        }
      }
    } else {
      _this.upperOnly = false;
    }
    return _possibleConstructorReturn(_this, list);
  }
  _createClass(ValueList2, [{
    key: "includes",
    value: function includes(value) {
      return this._values.indexOf(value) !== -1;
    }
  }, {
    key: "toString",
    value: function toString3() {
      var values = this._values;
      valuesArray.length = 0;
      for (var i2 = 0, n2 = values.length; i2 < n2; ++i2) {
        valuesArray[i2] = utils.correctSelectorIdentifier(String(values[i2]));
      }
      return valuesArray.join(",");
    }
  }, {
    key: "_validate",
    value: function _validate(value) {
      return this.upperOnly && typeof value === "string" ? value.toUpperCase() : value;
    }
  }, {
    key: "append",
    value: function append(value) {
      _get(_getPrototypeOf(ValueList2.prototype), "append", this).call(this, this._validate(value));
      return this;
    }
  }, {
    key: "remove",
    value: function remove3(value) {
      _get(_getPrototypeOf(ValueList2.prototype), "remove", this).call(this, this._validate(value));
      return this;
    }
  }]);
  return ValueList2;
}(List);
function _createSuper$1Z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1Z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1Z() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Selector = function() {
  function Selector2() {
    _classCallCheck(this, Selector2);
  }
  _createClass(Selector2, [{
    key: "toString",
    value: function toString3() {
      return this.keyword;
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      return [this.name];
    }
  }]);
  return Selector2;
}();
Selector.prototype.name = "Error";
Selector.prototype.keyword = "error";
var ListSelector = function(_Selector) {
  _inherits(ListSelector2, _Selector);
  var _super = _createSuper$1Z(ListSelector2);
  function ListSelector2(list) {
    var _this;
    _classCallCheck(this, ListSelector2);
    _this = _super.call(this);
    _this.list = list;
    return _this;
  }
  _createClass(ListSelector2, [{
    key: "toString",
    value: function toString3() {
      return "".concat(this.keyword, " ").concat(this.list);
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      return [this.name, this.list.toJSON()];
    }
  }]);
  return ListSelector2;
}(Selector);
var RangeListSelector = function(_ListSelector) {
  _inherits(RangeListSelector2, _ListSelector);
  var _super2 = _createSuper$1Z(RangeListSelector2);
  function RangeListSelector2(arg) {
    _classCallCheck(this, RangeListSelector2);
    return _super2.call(this, new RangeList(arg));
  }
  return _createClass(RangeListSelector2);
}(ListSelector);
var ValueListSelector = function(_ListSelector2) {
  _inherits(ValueListSelector2, _ListSelector2);
  var _super3 = _createSuper$1Z(ValueListSelector2);
  function ValueListSelector2(arg, caseSensitive) {
    _classCallCheck(this, ValueListSelector2);
    return _super3.call(this, new ValueList(arg, !caseSensitive));
  }
  return _createClass(ValueListSelector2);
}(ListSelector);
var NoneSelector = function(_Selector2) {
  _inherits(NoneSelector2, _Selector2);
  var _super4 = _createSuper$1Z(NoneSelector2);
  function NoneSelector2() {
    _classCallCheck(this, NoneSelector2);
    return _super4.apply(this, arguments);
  }
  _createClass(NoneSelector2, [{
    key: "includesAtom",
    value: function includesAtom(_atom) {
      return false;
    }
  }]);
  return NoneSelector2;
}(Selector);
NoneSelector.prototype.name = "None";
NoneSelector.prototype.keyword = "none";
var AllSelector = function(_Selector3) {
  _inherits(AllSelector2, _Selector3);
  var _super5 = _createSuper$1Z(AllSelector2);
  function AllSelector2() {
    _classCallCheck(this, AllSelector2);
    return _super5.apply(this, arguments);
  }
  _createClass(AllSelector2, [{
    key: "includesAtom",
    value: function includesAtom(_atom) {
      return true;
    }
  }]);
  return AllSelector2;
}(Selector);
AllSelector.prototype.name = "All";
AllSelector.prototype.keyword = "all";
function _createSuper$1Y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1Y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1Y() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var none = new NoneSelector();
var PrefixOperator = function(_Selector) {
  _inherits(PrefixOperator2, _Selector);
  var _super = _createSuper$1Y(PrefixOperator2);
  function PrefixOperator2(rhs) {
    var _this;
    _classCallCheck(this, PrefixOperator2);
    _this = _super.call(this);
    _this.rhs = rhs || none;
    return _this;
  }
  _createClass(PrefixOperator2, [{
    key: "toString",
    value: function toString3() {
      var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
      return "".concat(this.keyword, " ").concat(rhs);
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      return [this.name, this.rhs.toJSON()];
    }
  }]);
  return PrefixOperator2;
}(Selector);
PrefixOperator.prototype.priority = 1;
var InfixOperator = function(_Selector2) {
  _inherits(InfixOperator2, _Selector2);
  var _super2 = _createSuper$1Y(InfixOperator2);
  function InfixOperator2(lhs, rhs) {
    var _this2;
    _classCallCheck(this, InfixOperator2);
    _this2 = _super2.call(this);
    _this2.lhs = lhs || none;
    _this2.rhs = rhs || none;
    return _this2;
  }
  _createClass(InfixOperator2, [{
    key: "toString",
    value: function toString3() {
      var lhs = this.lhs.priority && this.lhs.priority > this.priority ? "(".concat(this.lhs, ")") : this.lhs;
      var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
      return "".concat(lhs, " ").concat(this.keyword, " ").concat(rhs);
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      return [this.name, this.lhs.toJSON(), this.rhs.toJSON()];
    }
  }]);
  return InfixOperator2;
}(Selector);
InfixOperator.prototype.priority = 1e3;
function _createSuper$1X(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1X();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1X() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var keywords = {};
function defineSelector(name2, SelectorClass) {
  var keyword = name2.toLowerCase();
  SelectorClass.prototype.keyword = keyword;
  SelectorClass.prototype.name = name2;
  var factory = function factory2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _construct(SelectorClass, args);
  };
  factory.SelectorClass = SelectorClass;
  keywords[keyword] = factory;
  return SelectorClass;
}
defineSelector("Serial", function(_RangeListSelector) {
  _inherits(SerialSelector, _RangeListSelector);
  var _super = _createSuper$1X(SerialSelector);
  function SerialSelector() {
    _classCallCheck(this, SerialSelector);
    return _super.apply(this, arguments);
  }
  _createClass(SerialSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.serial);
    }
  }]);
  return SerialSelector;
}(RangeListSelector));
defineSelector("Name", function(_ValueListSelector) {
  _inherits(NameSelector, _ValueListSelector);
  var _super2 = _createSuper$1X(NameSelector);
  function NameSelector() {
    _classCallCheck(this, NameSelector);
    return _super2.apply(this, arguments);
  }
  _createClass(NameSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.name);
    }
  }]);
  return NameSelector;
}(ValueListSelector));
defineSelector("AltLoc", function(_ValueListSelector2) {
  _inherits(AltLocSelector, _ValueListSelector2);
  var _super3 = _createSuper$1X(AltLocSelector);
  function AltLocSelector() {
    _classCallCheck(this, AltLocSelector);
    return _super3.apply(this, arguments);
  }
  _createClass(AltLocSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(String.fromCharCode(atom.location));
    }
  }]);
  return AltLocSelector;
}(ValueListSelector));
defineSelector("Elem", function(_ValueListSelector3) {
  _inherits(ElemSelector, _ValueListSelector3);
  var _super4 = _createSuper$1X(ElemSelector);
  function ElemSelector() {
    _classCallCheck(this, ElemSelector);
    return _super4.apply(this, arguments);
  }
  _createClass(ElemSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.element.name);
    }
  }]);
  return ElemSelector;
}(ValueListSelector));
defineSelector("Residue", function(_ValueListSelector4) {
  _inherits(ResidueSelector, _ValueListSelector4);
  var _super5 = _createSuper$1X(ResidueSelector);
  function ResidueSelector() {
    _classCallCheck(this, ResidueSelector);
    return _super5.apply(this, arguments);
  }
  _createClass(ResidueSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.residue._type._name);
    }
  }]);
  return ResidueSelector;
}(ValueListSelector));
defineSelector("Sequence", function(_RangeListSelector2) {
  _inherits(SequenceSelector, _RangeListSelector2);
  var _super6 = _createSuper$1X(SequenceSelector);
  function SequenceSelector() {
    _classCallCheck(this, SequenceSelector);
    return _super6.apply(this, arguments);
  }
  _createClass(SequenceSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.residue._sequence);
    }
  }]);
  return SequenceSelector;
}(RangeListSelector));
defineSelector("ICode", function(_ValueListSelector5) {
  _inherits(ICodeSelector, _ValueListSelector5);
  var _super7 = _createSuper$1X(ICodeSelector);
  function ICodeSelector(arg) {
    _classCallCheck(this, ICodeSelector);
    return _super7.call(this, arg, true);
  }
  _createClass(ICodeSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.residue._icode);
    }
  }]);
  return ICodeSelector;
}(ValueListSelector));
defineSelector("ResIdx", function(_RangeListSelector3) {
  _inherits(ResIdxSelector, _RangeListSelector3);
  var _super8 = _createSuper$1X(ResIdxSelector);
  function ResIdxSelector() {
    _classCallCheck(this, ResIdxSelector);
    return _super8.apply(this, arguments);
  }
  _createClass(ResIdxSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.residue._index);
    }
  }]);
  return ResIdxSelector;
}(RangeListSelector));
defineSelector("Chain", function(_ValueListSelector6) {
  _inherits(ChainSelector, _ValueListSelector6);
  var _super9 = _createSuper$1X(ChainSelector);
  function ChainSelector(arg) {
    _classCallCheck(this, ChainSelector);
    return _super9.call(this, arg, true);
  }
  _createClass(ChainSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.list.includes(atom.residue._chain._name);
    }
  }]);
  return ChainSelector;
}(ValueListSelector));
defineSelector("Hetatm", function(_Selector) {
  _inherits(HetatmSelector, _Selector);
  var _super10 = _createSuper$1X(HetatmSelector);
  function HetatmSelector() {
    _classCallCheck(this, HetatmSelector);
    return _super10.apply(this, arguments);
  }
  _createClass(HetatmSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return atom.het;
    }
  }]);
  return HetatmSelector;
}(Selector));
defineSelector("PolarH", function(_Selector2) {
  _inherits(PolarHSelector, _Selector2);
  var _super11 = _createSuper$1X(PolarHSelector);
  function PolarHSelector() {
    _classCallCheck(this, PolarHSelector);
    return _super11.apply(this, arguments);
  }
  _createClass(PolarHSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return (atom.flags & Atom$2.Flags.NONPOLARH) === Atom$2.Flags.HYDROGEN;
    }
  }]);
  return PolarHSelector;
}(Selector));
defineSelector("NonPolarH", function(_Selector3) {
  _inherits(NonPolarHSelector, _Selector3);
  var _super12 = _createSuper$1X(NonPolarHSelector);
  function NonPolarHSelector() {
    _classCallCheck(this, NonPolarHSelector);
    return _super12.apply(this, arguments);
  }
  _createClass(NonPolarHSelector, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return (atom.flags & Atom$2.Flags.NONPOLARH) === Atom$2.Flags.NONPOLARH;
    }
  }]);
  return NonPolarHSelector;
}(Selector));
defineSelector("All", AllSelector);
defineSelector("None", NoneSelector);
var NULL_SELECTOR = keywords.none();
function defineOperator(name2, priority, OperatorClass) {
  OperatorClass.prototype.priority = priority;
  return defineSelector(name2, OperatorClass);
}
defineOperator("Not", 1, function(_PrefixOperator) {
  _inherits(NotOperator, _PrefixOperator);
  var _super13 = _createSuper$1X(NotOperator);
  function NotOperator() {
    _classCallCheck(this, NotOperator);
    return _super13.apply(this, arguments);
  }
  _createClass(NotOperator, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return !this.rhs.includesAtom(atom);
    }
  }]);
  return NotOperator;
}(PrefixOperator));
defineOperator("And", 2, function(_InfixOperator) {
  _inherits(AndOperator, _InfixOperator);
  var _super14 = _createSuper$1X(AndOperator);
  function AndOperator() {
    _classCallCheck(this, AndOperator);
    return _super14.apply(this, arguments);
  }
  _createClass(AndOperator, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom);
    }
  }]);
  return AndOperator;
}(InfixOperator));
defineOperator("Or", 3, function(_InfixOperator2) {
  _inherits(OrOperator, _InfixOperator2);
  var _super15 = _createSuper$1X(OrOperator);
  function OrOperator() {
    _classCallCheck(this, OrOperator);
    return _super15.apply(this, arguments);
  }
  _createClass(OrOperator, [{
    key: "includesAtom",
    value: function includesAtom(atom) {
      return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom);
    }
  }]);
  return OrOperator;
}(InfixOperator));
function byResidueTypeFlag(flag, name2) {
  return defineSelector(name2, function(_Selector4) {
    _inherits(_class, _Selector4);
    var _super16 = _createSuper$1X(_class);
    function _class() {
      _classCallCheck(this, _class);
      return _super16.apply(this, arguments);
    }
    _createClass(_class, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return (atom.residue._type.flags & flag) !== 0;
      }
    }]);
    return _class;
  }(Selector));
}
byResidueTypeFlag(ResidueType$1.Flags.PROTEIN, "Protein");
byResidueTypeFlag(ResidueType$1.Flags.BASIC, "Basic");
byResidueTypeFlag(ResidueType$1.Flags.ACIDIC, "Acidic");
byResidueTypeFlag(ResidueType$1.Flags.BASIC | ResidueType$1.Flags.ACIDIC, "Charged");
byResidueTypeFlag(ResidueType$1.Flags.POLAR, "Polar");
byResidueTypeFlag(ResidueType$1.Flags.NONPOLAR, "NonPolar");
byResidueTypeFlag(ResidueType$1.Flags.AROMATIC, "Aromatic");
byResidueTypeFlag(ResidueType$1.Flags.NUCLEIC, "Nucleic");
byResidueTypeFlag(ResidueType$1.Flags.PURINE, "Purine");
byResidueTypeFlag(ResidueType$1.Flags.PYRIMIDINE, "Pyrimidine");
byResidueTypeFlag(ResidueType$1.Flags.WATER, "Water");
var selectors$5 = Object.create(keywords);
selectors$5.Selector = Selector;
selectors$5.RangeListSelector = RangeListSelector;
selectors$5.ValueListSelector = ValueListSelector;
selectors$5.Range = Range;
selectors$5.RangeList = RangeList;
selectors$5.ValueList = ValueList;
selectors$5.PrefixOperator = PrefixOperator;
selectors$5.InfixOperator = InfixOperator;
selectors$5.Context = /* @__PURE__ */ Object.create({});
selectors$5.GetSelector = function(key) {
  if (!selectors$5.Context.hasOwnProperty(key)) {
    var exc = {
      message: "selector ".concat(key, " is not registered")
    };
    throw exc;
  }
  return selectors$5.Context[key] || NULL_SELECTOR;
};
selectors$5.ClearContext = function() {
  Object.keys(selectors$5.Context).forEach(function(k2) {
    delete selectors$5.Context[k2];
  });
};
selectors$5.keyword = function(key) {
  return keywords[key.toLowerCase()] || keywords.none;
};
selectors$5.parse = function(str) {
  var res = {};
  try {
    res.selector = SelectionParser.parser.parse(str);
  } catch (e2) {
    res.selector = NULL_SELECTOR;
    res.error = e2.message;
  }
  return res;
};
SelectionParser.parser.yy = selectors$5;
SelectionParser.parser.yy.parseError = SelectionParser.parser.parseError;
var BiologicalUnit = function() {
  function BiologicalUnit2(complex) {
    _classCallCheck(this, BiologicalUnit2);
    this._complex = complex;
    this._selector = selectors$5.keyword("All")();
    this._boundaries = {
      boundingBox: new Box3(),
      boundingSphere: new Sphere()
    };
  }
  _createClass(BiologicalUnit2, [{
    key: "computeBoundaries",
    value: function computeBoundaries() {
      var atoms = this._complex._atoms;
      var n2 = atoms.length;
      var selector = this._selector;
      var boundingBox = this._boundaries.boundingBox;
      boundingBox.makeEmpty();
      if (n2 === 1) {
        boundingBox.expandByPoint(atoms[0].position);
        var bbc = new Vector3();
        boundingBox.getCenter(bbc);
        var s2 = 2 * atoms[0].element.radius;
        boundingBox.setFromCenterAndSize(bbc, new Vector3(s2, s2, s2));
      } else {
        for (var i2 = 0; i2 < n2; ++i2) {
          if (selector.includesAtom(atoms[i2])) {
            boundingBox.expandByPoint(atoms[i2].position);
          }
        }
      }
      var radiusSquared = 0;
      var center = new Vector3();
      boundingBox.getCenter(center);
      if (n2 === 1) {
        this._boundaries.boundingSphere.set(center, atoms[0].element.radius);
      } else {
        for (var _i = 0; _i < n2; ++_i) {
          if (!selector.includesAtom(atoms[_i])) {
            continue;
          }
          var pos = atoms[_i].position;
          var lengthSquared = center.distanceToSquared(pos);
          if (radiusSquared < lengthSquared) {
            radiusSquared = lengthSquared;
          }
        }
        this._boundaries.boundingSphere.set(center, Math.sqrt(radiusSquared));
      }
    }
  }, {
    key: "getTransforms",
    value: function getTransforms() {
      return [];
    }
  }, {
    key: "getSelector",
    value: function getSelector() {
      return this._selector;
    }
  }, {
    key: "getBoundaries",
    value: function getBoundaries() {
      return this._boundaries;
    }
  }, {
    key: "finalize",
    value: function finalize() {
    }
  }]);
  return BiologicalUnit2;
}();
function _createSuper$1W(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1W();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1W() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Assembly$3 = function(_BiologicalUnit) {
  _inherits(Assembly2, _BiologicalUnit);
  var _super = _createSuper$1W(Assembly2);
  function Assembly2(complex) {
    var _this;
    _classCallCheck(this, Assembly2);
    _this = _super.call(this, complex);
    _this.chains = [];
    _this.matrices = [];
    return _this;
  }
  _createClass(Assembly2, [{
    key: "computeBoundaries",
    value: function computeBoundaries() {
      _get(_getPrototypeOf(Assembly2.prototype), "computeBoundaries", this).call(this);
      var matrices = this.matrices;
      var oldCenter = this._boundaries.boundingSphere.center;
      var oldRad = this._boundaries.boundingSphere.radius;
      var boundingBox = this._boundaries.boundingBox = new Box3();
      boundingBox.makeEmpty();
      for (var i2 = 0, n2 = matrices.length; i2 < n2; ++i2) {
        boundingBox.expandByPoint(oldCenter.clone().applyMatrix4(matrices[i2]));
      }
      var newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad;
      var center = new Vector3();
      boundingBox.getCenter(center);
      this._boundaries.boundingSphere = new Sphere().set(center, newRad);
      boundingBox.max.addScalar(oldRad);
      boundingBox.min.subScalar(oldRad);
    }
  }, {
    key: "addChain",
    value: function addChain(chain2) {
      this.chains[this.chains.length] = chain2;
    }
  }, {
    key: "addMatrix",
    value: function addMatrix(matrix) {
      this.matrices[this.matrices.length] = matrix;
    }
  }, {
    key: "getTransforms",
    value: function getTransforms() {
      return this.matrices;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      if (this.chains.length > 0) {
        this._selector = selectors$5.keyword("Chain")(this.chains);
      } else {
        this._selector = selectors$5.keyword("None")();
      }
    }
  }]);
  return Assembly2;
}(BiologicalUnit);
var Component = function() {
  function Component2(complex) {
    _classCallCheck(this, Component2);
    this._complex = complex;
    this._index = -1;
    this._residueIndices = [];
    this._cycles = [];
    this._subDivs = [];
    this._residueCount = 0;
  }
  _createClass(Component2, [{
    key: "getResidues",
    value: function getResidues() {
      return this._complex._residues;
    }
  }, {
    key: "getResidueCount",
    value: function getResidueCount() {
      return this._residueCount;
    }
  }, {
    key: "forEachResidue",
    value: function forEachResidue(process2) {
      var residues = this._complex._residues;
      var resIdc = this._residueIndices;
      for (var idIdc = 0, idCount = resIdc.length; idIdc < idCount; ++idIdc) {
        for (var idx = resIdc[idIdc].start, last = resIdc[idIdc].end; idx <= last; ++idx) {
          process2(residues[idx]);
        }
      }
    }
  }, {
    key: "setSubDivs",
    value: function setSubDivs(subDivs) {
      this._subDivs = subDivs;
      var curr = 0;
      var resIdc = [];
      var resCnt = 0;
      for (var i2 = 0, n2 = subDivs.length; i2 < n2; ++i2) {
        if (i2 === n2 - 1 || subDivs[i2].end + 1 !== subDivs[i2 + 1].start) {
          var start = subDivs[curr].start;
          var end = subDivs[i2].end;
          resIdc[resIdc.length] = {
            start,
            end
          };
          resCnt += end - start + 1;
          curr = i2 + 1;
        }
      }
      this._residueIndices = resIdc;
      this._residueCount = resCnt;
    }
  }, {
    key: "getComplex",
    value: function getComplex() {
      return this._complex;
    }
  }, {
    key: "forEachBond",
    value: function forEachBond(process2) {
      var bonds = this._complex._bonds;
      for (var i2 = 0, n2 = bonds.length; i2 < n2; ++i2) {
        var bond = bonds[i2];
        if (bond._left.residue._component === this) {
          process2(bond);
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      this.forEachCycle(function(cycle) {
        cycle.update();
      });
    }
  }, {
    key: "forEachAtom",
    value: function forEachAtom(process2) {
      this.forEachResidue(function(residue2) {
        residue2.forEachAtom(process2);
      });
    }
  }, {
    key: "addCycle",
    value: function addCycle(cycle) {
      this._cycles.push(cycle);
    }
  }, {
    key: "forEachCycle",
    value: function forEachCycle(process2) {
      var cycles = this._cycles;
      for (var i2 = 0, n2 = cycles.length; i2 < n2; ++i2) {
        process2(cycles[i2]);
      }
    }
  }, {
    key: "markResidues",
    value: function markResidues() {
      var self2 = this;
      self2.forEachResidue(function(residue2) {
        residue2._component = self2;
      });
    }
  }, {
    key: "_forEachSubChain",
    value: function _forEachSubChain(mask, process2) {
      var residues = this._complex._residues;
      var subs = this._subDivs;
      for (var i2 = 0, n2 = subs.length; i2 < n2; ++i2) {
        for (var idx = subs[i2].start, last = subs[i2].end; idx <= last; ++idx) {
          var currRes = residues[idx];
          if (mask & currRes._mask && currRes._isValid) {
            var end = idx + 1;
            for (; end <= last; ++end) {
              var endRes = residues[end];
              if (!(mask & endRes._mask && endRes._isValid)) {
                break;
              }
            }
            process2(i2, idx, end - 1);
            idx = end;
          }
        }
      }
    }
  }, {
    key: "getMaskedSequences",
    value: function getMaskedSequences(mask) {
      var subs = [];
      var idx = 0;
      this._forEachSubChain(mask, function(_subIdx, start, end) {
        subs[idx++] = {
          start,
          end
        };
      });
      return subs;
    }
  }, {
    key: "getMaskedSubdivSequences",
    value: function getMaskedSubdivSequences(mask) {
      var subs = [];
      var currIdx = -1;
      var lastSubIdx = -1;
      var subDivs = this._subDivs;
      this._forEachSubChain(mask, function(subIdx, start, end) {
        if (lastSubIdx !== subIdx) {
          ++currIdx;
          subs[currIdx] = {
            arr: [],
            boundaries: subDivs[subIdx]
          };
          lastSubIdx = subIdx;
        }
        subs[currIdx].arr[subs[currIdx].arr.length] = {
          start,
          end
        };
      });
      return subs;
    }
  }]);
  return Component2;
}();
var cMaxPairsForHashCode = 32;
var cHashTableSize = 1024 * 1024;
var cNumbersPerPair = 4;
var cMaxNeighbours = 14;
var cInvalidVal = -1;
var cBigPrime = 89237;
var AtomPairs = function() {
  function AtomPairs2(maxPairsEstimate) {
    _classCallCheck(this, AtomPairs2);
    this.numPairs = 0;
    this.numMaxPairs = maxPairsEstimate;
    this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);
    for (var i2 = 0; i2 < maxPairsEstimate * cNumbersPerPair; i2++) {
      this.intBuffer[i2] = cInvalidVal;
    }
    this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);
    for (var _i = 0; _i < cHashTableSize * cMaxPairsForHashCode; _i++) {
      this.hashBuffer[_i] = cInvalidVal;
    }
  }
  _createClass(AtomPairs2, [{
    key: "destroy",
    value: function destroy() {
      this.intBuffer = null;
      this.hashBuffer = null;
    }
  }, {
    key: "addPair",
    value: function addPair(indexA, indexB) {
      var ia = indexA < indexB ? indexA : indexB;
      var ib = indexA > indexB ? indexA : indexB;
      var codeToAdd = ia + (ib << cMaxNeighbours);
      var hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
      var j2 = hashCode * cMaxPairsForHashCode;
      var apI = 0;
      for (; apI < cMaxPairsForHashCode; apI++) {
        var code = this.hashBuffer[j2 + apI];
        if (code === cInvalidVal) {
          break;
        }
        if (code === codeToAdd) {
          return false;
        }
      }
      if (apI >= cMaxPairsForHashCode) {
        throw new Error("addPair: increase cMaxPairsForHashCode");
      }
      this.hashBuffer[j2 + apI] = codeToAdd;
      if (this.numPairs >= this.numMaxPairs) {
        throw new Error("addPair: increase num pairs");
      }
      j2 = this.numPairs * cNumbersPerPair;
      this.intBuffer[j2] = ia;
      this.intBuffer[j2 + 1] = ib;
      this.intBuffer[j2 + 2] = codeToAdd;
      this.numPairs++;
      return true;
    }
  }]);
  return AtomPairs2;
}();
var cEstBondsMultiplier = 4;
var cSpaceCode = 32;
var cBondTolerance = 0.45;
var cEpsilon = 1e-3;
function _getBondingRadius(atom) {
  var element = atom.element;
  if (element) {
    return element.radiusBonding;
  }
  throw new Error("_getBondingRadius: Logic error.");
}
function _isAtomEligible(atom) {
  return !atom.isHet() || atom.bonds && atom.bonds.length === 0;
}
var AutoBond = function() {
  function AutoBond2(complex) {
    _classCallCheck(this, AutoBond2);
    this._complex = complex;
    this._maxRad = 1.8;
    var bBox = this._complex.getDefaultBoundaries().boundingBox;
    this._vBoxMin = bBox.min.clone();
    this._vBoxMax = bBox.max.clone();
    this._pairCollection = null;
  }
  _createClass(AutoBond2, [{
    key: "_addExistingPairs",
    value: function _addExistingPairs() {
      var atoms = this._complex.getAtoms();
      var numAtoms = atoms.length;
      var aInd = 0;
      var collection = this._pairCollection;
      for (; aInd < numAtoms; aInd++) {
        var bonds = atoms[aInd].bonds;
        var numBondsForAtom = bonds.length;
        for (var bInd = 0; bInd < numBondsForAtom; bInd++) {
          var bond = bonds[bInd];
          var indTo = bond._left.index;
          if (indTo === aInd) {
            collection.addPair(aInd, bond._right.index);
          }
        }
      }
      return 0;
    }
  }, {
    key: "_findPairs",
    value: function _findPairs() {
      var vw = this._complex.getVoxelWorld();
      if (vw === null) {
        return;
      }
      var atoms = this._complex._atoms;
      var atomsNum = atoms.length;
      var self2 = this;
      var rA;
      var isHydrogenA;
      var posA;
      var locationA;
      var atomA;
      var processAtom = function processAtom2(atomB) {
        if (isHydrogenA && atomB.isHydrogen()) {
          return;
        }
        var locationB = atomB.location;
        if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
          return;
        }
        var dist2 = posA.distanceToSquared(atomB.position);
        var rB = atomB.element.radiusBonding;
        var maxAcceptable = rA + rB + cBondTolerance;
        if (dist2 > maxAcceptable * maxAcceptable) {
          return;
        }
        if (dist2 < cEpsilon) {
          return;
        }
        self2._pairCollection.addPair(atomA.index, atomB.index);
      };
      for (var i2 = 0; i2 < atomsNum; ++i2) {
        atomA = atoms[i2];
        if (!_isAtomEligible(atomA)) {
          continue;
        }
        rA = atomA.element.radiusBonding;
        isHydrogenA = atomA.isHydrogen();
        posA = atomA.position;
        locationA = atomA.location;
        vw.forEachAtomWithinRadius(posA, 2 * this._maxRad + cBondTolerance, processAtom);
      }
    }
  }, {
    key: "_addPairs",
    value: function _addPairs() {
      var atoms = this._complex._atoms;
      for (var i2 = 0, k2 = 0; i2 < this._pairCollection.numPairs; i2++, k2 += 4) {
        var iA = this._pairCollection.intBuffer[k2];
        var iB = this._pairCollection.intBuffer[k2 + 1];
        this._addPair(atoms[iA], atoms[iB]);
      }
    }
  }, {
    key: "_addPair",
    value: function _addPair(atomA, atomB) {
      var bondsA = atomA.bonds;
      var indexA = atomA.index;
      var indexB = atomB.index;
      for (var j2 = 0, numBonds = bondsA.length; j2 < numBonds; ++j2) {
        var bond = bondsA[j2];
        if (bond._left.index === indexB || bond._right.index === indexB) {
          return;
        }
      }
      var left = indexA < indexB ? atomA : atomB;
      var right = indexA < indexB ? atomB : atomA;
      var newBond = this._complex.addBond(left, right, 0, Bond$5.BondType.UNKNOWN, false);
      bondsA.push(newBond);
      atomB.bonds.push(newBond);
    }
  }, {
    key: "build",
    value: function build() {
      this._buildInner();
    }
  }, {
    key: "_buildInner",
    value: function _buildInner() {
      var atoms = this._complex._atoms;
      if (atoms.length < 2) {
        return;
      }
      if (atoms[0].index < 0) {
        throw new Error("AutoBond: Atoms in complex were not indexed.");
      }
      this._calcBoundingBox();
      this._pairCollection = new AtomPairs(atoms.length * cEstBondsMultiplier);
      this._addExistingPairs();
      this._findPairs();
      this._addPairs();
    }
  }, {
    key: "_calcBoundingBox",
    value: function _calcBoundingBox() {
      var atoms = this._complex._atoms;
      var nAtoms = atoms.length;
      var maxRad = _getBondingRadius(atoms[0]);
      for (var i2 = 1; i2 < nAtoms; ++i2) {
        maxRad = Math.max(maxRad, _getBondingRadius(atoms[i2]));
      }
      this._vBoxMax.addScalar(maxRad);
      this._vBoxMin.addScalar(-maxRad);
      this._maxRad = maxRad * 1.2;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._pairCollection) {
        this._pairCollection.destroy();
      }
    }
  }]);
  return AutoBond2;
}();
var cCrossThresh = 0.1;
var cAromaticType = Bond$5.BondType.AROMATIC;
var cAromaticAtoms = [
  Element$a.ByName.C.number,
  Element$a.ByName.N.number
];
var _coDirVectors = function() {
  var v1Tmp = new Vector3();
  var v2Tmp = new Vector3();
  var cp = new Vector3();
  return function(v1, v2) {
    v1Tmp.copy(v1).normalize();
    v2Tmp.copy(v2).normalize();
    cp.crossVectors(v1Tmp, v2Tmp);
    if (cp.length() > cCrossThresh) {
      return false;
    }
    return v1Tmp.dot(v2Tmp) >= 0;
  };
}();
function _insertAscending(arr, val) {
  var idx = 0;
  while (idx < arr.length && arr[idx] < val) {
    ++idx;
  }
  arr.splice(idx, 0, val);
}
function _anotherAtom(bond, currAtom) {
  return bond._left === currAtom ? bond._right : bond._left;
}
function _cosBetween(v1, v2) {
  var theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
  return MathUtils.clamp(theta, -1, 1);
}
function _markAromatic(bond) {
  bond._type = cAromaticType;
}
var Cycle = function() {
  function Cycle2(atomsList) {
    _classCallCheck(this, Cycle2);
    this.atoms = atomsList;
    this.update();
  }
  _createClass(Cycle2, [{
    key: "update",
    value: function update() {
      var atoms = this.atoms;
      var center = new Vector3();
      var nA = atoms.length;
      for (var j2 = 0; j2 < nA; ++j2) {
        center.add(atoms[j2].position);
      }
      center.multiplyScalar(1 / nA);
      this.center = center;
      this.radius = center.distanceTo(atoms[0].position.clone().lerp(atoms[1].position, 0.5));
    }
  }, {
    key: "forEachBond",
    value: function forEachBond(process2) {
      var atoms = this.atoms;
      var nA = atoms.length;
      var currAtom = atoms[0];
      var nextAtom;
      function checkBond(bond) {
        if (bond._left === nextAtom || bond._right === nextAtom) {
          process2(bond);
        }
      }
      for (var i2 = 0; i2 < nA; ++i2) {
        nextAtom = atoms[(i2 + 1) % nA];
        currAtom.forEachBond(checkBond);
        currAtom = nextAtom;
      }
    }
  }]);
  return Cycle2;
}();
function _isAromatic(bond) {
  return bond._type === cAromaticType;
}
function _isPossibleAromatic(bond) {
  if (bond.type === cAromaticType) {
    return true;
  }
  var rightIdx = cAromaticAtoms.indexOf(bond._right.element.number);
  var leftIdx = cAromaticAtoms.indexOf(bond._left.element.number);
  return rightIdx !== -1 && leftIdx !== -1;
}
function _checkCycleSimple(cycle) {
  return cycle.length > 3;
}
function _checkCycleComplex(cycle) {
  console.assert(cycle.length > 2);
  return true;
}
var AromaticLoopsMarker = function() {
  function AromaticLoopsMarker2(complex) {
    _classCallCheck(this, AromaticLoopsMarker2);
    this._complex = complex;
    var bondsData = new Array(complex._bonds.length);
    var bondMarks = new Array(complex._bonds.length);
    for (var i2 = 0, n2 = bondsData.length; i2 < n2; ++i2) {
      bondsData[i2] = [];
      bondMarks[i2] = false;
    }
    this._bondsData = bondsData;
    this._bondMarks = bondMarks;
    this._resetCycles();
  }
  _createClass(AromaticLoopsMarker2, [{
    key: "_resetCycles",
    value: function _resetCycles() {
      this._cycles = [];
      this._currIdx = -1;
    }
  }, {
    key: "_haveSameCycle",
    value: function _haveSameCycle(bondsData, bond1, bond2) {
      var arr1 = bondsData[bond1._index];
      var arr2 = bondsData[bond2._index];
      var n1 = arr1.length;
      var n2 = arr2.length;
      var i1 = 0;
      var i2 = 0;
      while (i1 < n1 && i2 < n2) {
        if (arr1[i1] === arr2[i2]) {
          return true;
        }
        if (arr1[i1] > arr2[i2]) {
          ++i2;
        } else {
          ++i1;
        }
      }
      return false;
    }
  }, {
    key: "_tryBond",
    value: function _tryBond(prevBond, currRight, currDir) {
      var bondsOrder = [];
      var bondsData = this._bondsData;
      var currLeft = _anotherAtom(prevBond, currRight);
      var currVec = currRight.position.clone().sub(currLeft.position);
      var startAtomRef = this._currStart;
      var self2 = this;
      var bondMarks = this._bondMarks;
      var checkAromatic = this._checkBond;
      bondMarks[prevBond._index] = true;
      checkAromatic = checkAromatic === void 0 ? _isAromatic : checkAromatic;
      currRight.forEachBond(function(newBond) {
        if (!checkAromatic(newBond) || newBond === prevBond || bondMarks[newBond._index] || self2._haveSameCycle(bondsData, prevBond, newBond)) {
          return;
        }
        var anotherAtom = _anotherAtom(newBond, currRight);
        var anotherVec = anotherAtom.position.clone().sub(currRight.position);
        var val = anotherAtom === startAtomRef ? -2 : 1 - _cosBetween(currVec, anotherVec);
        var newDir = anotherVec.cross(currVec);
        if (!_coDirVectors(newDir, currDir)) {
          return;
        }
        var idx = 0;
        while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
          ++idx;
        }
        bondsOrder.splice(idx, 0, {
          bond: newBond,
          val,
          dir: newDir
        });
      });
      for (var i2 = 0, n2 = bondsOrder.length; i2 < n2; ++i2) {
        var bond = bondsOrder[i2].bond;
        var newRight = bond._left === currRight ? bond._right : bond._left;
        if (newRight === startAtomRef) {
          ++this._currIdx;
          this._cycles.push([currRight]);
          bondMarks[prevBond._index] = false;
          return true;
        }
        if (this._tryBond(bond, newRight, bondsOrder[i2].dir)) {
          _insertAscending(bondsData[bond._index], this._currIdx);
          this._cycles[this._currIdx].push(currRight);
          bondMarks[prevBond._index] = false;
          return true;
        }
      }
      bondMarks[prevBond._index] = false;
      return false;
    }
  }, {
    key: "_startCycle",
    value: function _startCycle(bond) {
      this._currStart = bond._left;
      if (this._tryBond(bond, bond._right, new Vector3())) {
        _insertAscending(this._bondsData[bond._index], this._currIdx);
        this._cycles[this._currIdx].push(bond._left);
      }
    }
  }, {
    key: "_findLoops",
    value: function _findLoops(checkBond, checkCycle) {
      this._checkBond = checkBond;
      var complex = this._complex;
      var self2 = this;
      complex.forEachComponent(function(component) {
        self2._resetCycles();
        component.forEachBond(function(bond) {
          if (checkBond(bond)) {
            self2._startCycle(bond);
          }
        });
        var cycles = self2._cycles;
        for (var i2 = 0, n2 = cycles.length; i2 < n2; ++i2) {
          var cycle = cycles[i2];
          if (!checkCycle(cycle)) {
            continue;
          }
          var newCycle = new Cycle(cycle);
          newCycle.forEachBond(_markAromatic);
          component.addCycle(newCycle);
        }
      });
    }
  }, {
    key: "markCycles",
    value: function markCycles() {
      this._findLoops(_isAromatic, _checkCycleSimple);
    }
  }, {
    key: "detectCycles",
    value: function detectCycles() {
      this._findLoops(_isPossibleAromatic, _checkCycleComplex);
    }
  }]);
  return AromaticLoopsMarker2;
}();
function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
  var dzMin = zMin - center.z;
  var dzMax = zMax - center.z;
  var rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0));
  var rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0));
  var rMin = Math.min(rzMin, rzMax);
  var rMax;
  if (zMin <= center.z && zMax >= center.z) {
    rMax = radius;
  } else {
    rMax = Math.max(rzMin, rzMax);
  }
  return [rMin, rMax];
}
function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
  var dyMin = yMin - center.y;
  var dyMax = yMax - center.y;
  var ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0));
  var ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0));
  var rMin = Math.min(ryMin, ryMax);
  var rMax;
  if (yMin <= center.y && yMax >= center.y) {
    rMax = radius;
  } else {
    rMax = Math.max(ryMin, ryMax);
  }
  return [rMin, rMax];
}
var VoxelWorld = function() {
  function VoxelWorld2(box, vCellSizeHint) {
    _classCallCheck(this, VoxelWorld2);
    this._box = box.clone();
    var size = new Vector3();
    box.getSize(size);
    this._count = size.clone().divide(vCellSizeHint).floor().max(new Vector3(1, 1, 1));
    this._last = this._count.clone().subScalar(1);
    this._cellSize = size.clone().divide(this._count);
    this._cellInnerR = 0.5 * Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z);
    this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize));
    var numVoxels = this._count.x * this._count.y * this._count.z;
    this._voxels = utils.allocateTyped(Int32Array, numVoxels);
    for (var i2 = 0; i2 < numVoxels; ++i2) {
      this._voxels[i2] = -1;
    }
    this._atoms = [];
  }
  _createClass(VoxelWorld2, [{
    key: "addAtoms",
    value: function addAtoms(complex) {
      var self2 = this;
      var idx = this._atoms.length;
      this._atoms.length += 2 * complex.getAtomCount();
      complex.forEachAtom(function(atom) {
        var voxelIdx = self2._findVoxel(atom.position);
        self2._atoms[idx] = atom;
        self2._atoms[idx + 1] = self2._voxels[voxelIdx];
        self2._voxels[voxelIdx] = idx;
        idx += 2;
      });
    }
  }, {
    key: "_findVoxel",
    value: function _findVoxel(point) {
      var zero = VoxelWorld2._zero;
      var voxel = VoxelWorld2._voxel;
      voxel.copy(point).sub(this._box.min).divide(this._cellSize).floor().clamp(zero, this._last);
      return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z);
    }
  }, {
    key: "_forEachAtomInVoxel",
    value: function _forEachAtomInVoxel(voxel, process2) {
      for (var i2 = this._voxels[voxel]; i2 >= 0; i2 = this._atoms[i2 + 1]) {
        process2(this._atoms[i2]);
      }
    }
  }, {
    key: "_forEachVoxelWithinRadius",
    value: function _forEachVoxelWithinRadius(center, radius, process2) {
      var xRange = VoxelWorld2._xRange;
      var yRange = VoxelWorld2._yRange;
      var zRange = VoxelWorld2._zRange;
      if (radius / this._cellInnerR < 10) {
        this._forEachVoxelWithinRadiusSimple(center, radius, process2);
        return;
      }
      var rRangeXY;
      var rRangeX;
      var xVal;
      var yVal;
      var zVal;
      var isInsideX;
      var isInsideY;
      var isInsideZ;
      zRange.set(center.z - radius, center.z + radius);
      zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0, this._count.z - 1);
      for (var z2 = zRange.x; z2 <= zRange.y; ++z2) {
        zVal = [this._box.min.z + z2 * this._cellSize.z, this._box.min.z + (z2 + 1) * this._cellSize.z];
        isInsideZ = center.z - radius <= zVal[0] && zVal[1] <= center.z + radius;
        rRangeXY = _getSphereSliceRadiusRange(center, radius, zVal[0], zVal[1]);
        yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1]);
        yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0, this._count.y - 1);
        for (var y2 = yRange.x; y2 <= yRange.y; ++y2) {
          yVal = [this._box.min.y + y2 * this._cellSize.y, this._box.min.y + (y2 + 1) * this._cellSize.y];
          isInsideY = center.y - rRangeXY[0] <= yVal[0] && yVal[1] <= center.y + rRangeXY[0];
          rRangeX = _getCircleSliceRadiusRange(center, rRangeXY[1], yVal[0], yVal[1]);
          xRange.set(center.x - rRangeX[1], center.x + rRangeX[1]);
          xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0, this._count.x - 1);
          for (var x2 = xRange.x; x2 <= xRange.y; ++x2) {
            xVal = [this._box.min.x + x2 * this._cellSize.x, this._box.min.x + (x2 + 1) * this._cellSize.x];
            isInsideX = center.x - rRangeX[0] <= xVal[0] && xVal[1] <= center.x + rRangeX[0];
            process2(x2 + this._count.x * (y2 + this._count.y * z2), isInsideX && isInsideY && isInsideZ);
          }
        }
      }
    }
  }, {
    key: "_forEachVoxelWithinRadiusSimple",
    value: function _forEachVoxelWithinRadiusSimple(center, radius, process2) {
      var xRange = VoxelWorld2._xRange;
      var yRange = VoxelWorld2._yRange;
      var zRange = VoxelWorld2._zRange;
      var vCenter = VoxelWorld2._vCenter;
      var distTouch2 = (radius + this._cellOuterR) * (radius + this._cellOuterR);
      var distInside2 = -1;
      if (radius > this._cellOuterR) {
        distInside2 = (radius - this._cellOuterR) * (radius - this._cellOuterR);
      }
      xRange.set(center.x - radius, center.x + radius);
      xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor();
      xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1);
      xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1);
      yRange.set(center.y - radius, center.y + radius);
      yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor();
      yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1);
      yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1);
      zRange.set(center.z - radius, center.z + radius);
      zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor();
      zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1);
      zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1);
      for (var z2 = zRange.x; z2 <= zRange.y; ++z2) {
        var zVal = [this._box.min.z + z2 * this._cellSize.z, this._box.min.z + (z2 + 1) * this._cellSize.z];
        vCenter.z = 0.5 * (zVal[0] + zVal[1]);
        for (var y2 = yRange.x; y2 <= yRange.y; ++y2) {
          var yVal = [this._box.min.y + y2 * this._cellSize.y, this._box.min.y + (y2 + 1) * this._cellSize.y];
          vCenter.y = 0.5 * (yVal[0] + yVal[1]);
          for (var x2 = xRange.x; x2 <= xRange.y; ++x2) {
            var xVal = [this._box.min.x + x2 * this._cellSize.x, this._box.min.x + (x2 + 1) * this._cellSize.x];
            vCenter.x = 0.5 * (xVal[0] + xVal[1]);
            var d2 = center.distanceToSquared(vCenter);
            if (d2 <= distTouch2) {
              process2(x2 + this._count.x * (y2 + this._count.y * z2), d2 <= distInside2);
            }
          }
        }
      }
    }
  }, {
    key: "forEachAtomWithinRadius",
    value: function forEachAtomWithinRadius(center, radius, process2) {
      var self2 = this;
      var r2 = radius * radius;
      self2._forEachVoxelWithinRadius(center, radius, function(voxel, isInside) {
        if (isInside) {
          self2._forEachAtomInVoxel(voxel, process2);
        } else {
          self2._forEachAtomInVoxel(voxel, function(atom) {
            if (center.distanceToSquared(atom.position) <= r2) {
              process2(atom);
            }
          });
        }
      });
    }
  }, {
    key: "forEachAtomWithinDistFromMasked",
    value: function forEachAtomWithinDistFromMasked(complex, mask, dist, process2) {
      this._forEachAtomWithinDistFromGroup(function(atomProc) {
        complex.forEachAtom(function(atom) {
          if ((atom.mask & mask) !== 0) {
            atomProc(atom);
          }
        });
      }, dist, process2);
    }
  }, {
    key: "forEachAtomWithinDistFromSelected",
    value: function forEachAtomWithinDistFromSelected(complex, selector, dist, process2) {
      this._forEachAtomWithinDistFromGroup(function(atomProc) {
        complex.forEachAtom(function(atom) {
          if (selector.includesAtom(atom)) {
            atomProc(atom);
          }
        });
      }, dist, process2);
    }
  }, {
    key: "_forEachAtomWithinDistFromGroup",
    value: function _forEachAtomWithinDistFromGroup(forEachAtom, dist, process2) {
      var self2 = this;
      var r2 = dist * dist;
      var voxels = [];
      var atoms = [];
      var idx = 0;
      forEachAtom(function(atom) {
        self2._forEachVoxelWithinRadius(atom.position, dist, function(voxel2, isInside) {
          if (isInside) {
            voxels[voxel2] = -1;
          } else if (typeof voxels[voxel2] === "undefined") {
            atoms.push(atom);
            atoms.push(-1);
            voxels[voxel2] = idx;
            idx += 2;
          } else if (voxels[voxel2] !== -1) {
            atoms.push(atom);
            atoms.push(voxels[voxel2]);
            voxels[voxel2] = idx;
            idx += 2;
          }
        });
      });
      var voxel;
      var processIfWithin = function processIfWithin2(atom) {
        if (typeof voxels[voxel] === "undefined") {
          return;
        }
        idx = voxels[voxel];
        if (idx === -1) {
          process2(atom);
          return;
        }
        for (; idx >= 0; idx = atoms[idx + 1]) {
          if (atom.position.distanceToSquared(atoms[idx].position) < r2) {
            process2(atom);
            break;
          }
        }
      };
      for (voxel in voxels) {
        if (voxels.hasOwnProperty(voxel)) {
          self2._forEachAtomInVoxel(voxel, processIfWithin);
        }
      }
    }
  }]);
  return VoxelWorld2;
}();
_defineProperty2(VoxelWorld, "_zero", new Vector3(0, 0, 0));
_defineProperty2(VoxelWorld, "_voxel", new Vector3());
_defineProperty2(VoxelWorld, "_xRange", new Vector2());
_defineProperty2(VoxelWorld, "_yRange", new Vector2());
_defineProperty2(VoxelWorld, "_zRange", new Vector2());
_defineProperty2(VoxelWorld, "_vCenter", new Vector3());
var MINIMAL_DISTANCE = 0.5;
var MIN_HBOND_ENERGY = -9.9;
var MAX_HBOND_ENERGY = -0.5;
var COUPLING_CONSTANT = -27.888;
var MAX_COUPLING_DISTANCE = 5;
var MAX_RESIDUES_THRESHOLD = 1e3;
var HBondInfo = function() {
  function HBondInfo2(complex) {
    _classCallCheck(this, HBondInfo2);
    this._complex = complex;
    this._hbonds = [];
    if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
      this._buildVW();
    } else {
      this._build();
    }
  }
  _createClass(HBondInfo2, [{
    key: "isBond",
    value: function isBond(from, to) {
      if (this._hbonds[from]) {
        var _this$_hbonds$from$ac = _slicedToArray(this._hbonds[from].acceptor, 2), acc0 = _this$_hbonds$from$ac[0], acc1 = _this$_hbonds$from$ac[1];
        if (acc0 && acc0.residue === to && acc0.energy < MAX_HBOND_ENERGY) {
          return true;
        }
        if (acc1 && acc1.residue === to && acc1.energy < MAX_HBOND_ENERGY) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_build",
    value: function _build() {
      var self2 = this;
      for (var i2 = 0; i2 < this._complex._residues.length - 1; ++i2) {
        var ri = this._complex._residues[i2];
        if ((ri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
          continue;
        }
        var preri = null;
        if (i2 > 0 && this._complex._residues[i2 - 1].getType().flags & ResidueType$1.Flags.PROTEIN && ri._sequence === this._complex._residues[i2 - 1]._sequence + 1) {
          preri = this._complex._residues[i2 - 1];
        }
        for (var j2 = i2 + 1; j2 < this._complex._residues.length; ++j2) {
          var rj = this._complex._residues[j2];
          if ((rj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
            continue;
          }
          var prerj = null;
          if (this._complex._residues[j2 - 1].getType().flags & ResidueType$1.Flags.PROTEIN && rj._sequence === this._complex._residues[j2 - 1]._sequence + 1) {
            prerj = this._complex._residues[j2 - 1];
          }
          self2._calcHBondEnergy(preri, ri, rj);
          if (j2 !== i2 + 1) {
            self2._calcHBondEnergy(prerj, rj, ri);
          }
        }
      }
    }
  }, {
    key: "_buildVW",
    value: function _buildVW() {
      var self2 = this;
      var residues = this._complex._residues;
      var ri;
      var preri;
      var vw = this._complex.getVoxelWorld();
      if (vw === null) {
        return;
      }
      var pairs = new AtomPairs(this._complex._residues.length * this._complex._residues.length / 2);
      function processAtom(atom) {
        var rj = atom.residue;
        if (rj._index === ri._index) {
          return;
        }
        if ((rj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
          return;
        }
        if (!pairs.addPair(ri._index, rj._index)) {
          return;
        }
        var prerj = rj._index > 0 ? residues[rj._index - 1] : null;
        if (prerj && ((prerj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0 || rj._sequence !== prerj._sequence + 1)) {
          prerj = null;
        }
        self2._calcHBondEnergy(preri, ri, rj);
        if (rj._index !== ri._index + 1) {
          self2._calcHBondEnergy(prerj, rj, ri);
        }
      }
      for (var i2 = 0; i2 < residues.length - 1; ++i2) {
        ri = residues[i2];
        if ((ri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
          continue;
        }
        preri = i2 > 0 ? residues[i2 - 1] : null;
        if (preri && ((preri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0 || ri._sequence !== preri._sequence + 1)) {
          preri = null;
        }
        vw.forEachAtomWithinRadius(this._residueGetCAlpha(ri), MAX_COUPLING_DISTANCE, processAtom);
      }
    }
  }, {
    key: "_residueGetCAlpha",
    value: function _residueGetCAlpha(res) {
      for (var i2 = 0; i2 < res._atoms.length; ++i2) {
        var name2 = res._atoms[i2].name;
        if (name2 === "CA" || name2 === "C1") {
          return res._atoms[i2].position;
        }
      }
      return null;
    }
  }, {
    key: "_residueGetCO",
    value: function _residueGetCO(res) {
      var c2 = null;
      var o2 = null;
      res.forEachAtom(function(a2) {
        if (a2.name === "C") {
          c2 = a2.position;
        } else if (a2.name === "O") {
          o2 = a2.position;
        }
      });
      return [c2, o2];
    }
  }, {
    key: "_residueGetNH",
    value: function _residueGetNH(prev, res) {
      var _this$_residueGetCO = this._residueGetCO(prev), _this$_residueGetCO2 = _slicedToArray(_this$_residueGetCO, 2), c2 = _this$_residueGetCO2[0], o2 = _this$_residueGetCO2[1];
      var n2;
      res.forEachAtom(function(a2) {
        if (a2.name === "N") {
          n2 = a2.position;
        }
      });
      if (c2 && o2 && n2) {
        var h2 = c2.clone();
        h2.sub(o2);
        h2.multiplyScalar(1 / h2.length());
        h2.add(n2);
        return [n2, h2];
      }
      return [null, null];
    }
  }, {
    key: "_calcHBondEnergy",
    value: function _calcHBondEnergy(predonor, donor, acceptor) {
      var result = 0;
      if (predonor === null) {
        return result;
      }
      if (donor.getType().getName() !== "PRO") {
        var _this$_residueGetNH = this._residueGetNH(predonor, donor), _this$_residueGetNH2 = _slicedToArray(_this$_residueGetNH, 2), n2 = _this$_residueGetNH2[0], h2 = _this$_residueGetNH2[1];
        var _this$_residueGetCO3 = this._residueGetCO(acceptor), _this$_residueGetCO4 = _slicedToArray(_this$_residueGetCO3, 2), c2 = _this$_residueGetCO4[0], o2 = _this$_residueGetCO4[1];
        if (n2 === null || h2 === null || c2 === null || o2 === null) {
          return result;
        }
        var distanceHO = h2.distanceTo(o2);
        var distanceHC = h2.distanceTo(c2);
        var distanceNC = n2.distanceTo(c2);
        var distanceNO = n2.distanceTo(o2);
        if (distanceHO < MINIMAL_DISTANCE || distanceHC < MINIMAL_DISTANCE || distanceNC < MINIMAL_DISTANCE || distanceNO < MINIMAL_DISTANCE) {
          result = MIN_HBOND_ENERGY;
        } else {
          result = COUPLING_CONSTANT / distanceHO - COUPLING_CONSTANT / distanceHC + COUPLING_CONSTANT / distanceNC - COUPLING_CONSTANT / distanceNO;
        }
        result = Math.round(result * 1e3) / 1e3;
        if (result < MIN_HBOND_ENERGY) {
          result = MIN_HBOND_ENERGY;
        }
      }
      if (typeof this._hbonds[donor._index] === "undefined") {
        this._hbonds[donor._index] = {
          donor: [],
          acceptor: []
        };
      }
      var donorInfo = this._hbonds[donor._index];
      if (donorInfo.acceptor.length < 2) {
        donorInfo.acceptor.push({
          residue: acceptor._index,
          energy: result
        });
      }
      if (donorInfo.acceptor.length > 1) {
        if (result < donorInfo.acceptor[0].energy) {
          donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue;
          donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy;
          donorInfo.acceptor[0].residue = acceptor._index;
          donorInfo.acceptor[0].energy = result;
        } else if (result < donorInfo.acceptor[1].energy) {
          donorInfo.acceptor[1].residue = acceptor._index;
          donorInfo.acceptor[1].energy = result;
        }
      }
      if (typeof this._hbonds[acceptor._index] === "undefined") {
        this._hbonds[acceptor._index] = {
          donor: [],
          acceptor: []
        };
      }
      var accInfo = this._hbonds[acceptor._index];
      if (accInfo.donor.length < 2) {
        accInfo.donor.push({
          residue: donor._index,
          energy: result
        });
      }
      if (accInfo.donor.length > 1) {
        if (result < accInfo.donor[0].energy) {
          accInfo.donor[1].residue = accInfo.donor[0].residue;
          accInfo.donor[1].energy = accInfo.donor[0].energy;
          accInfo.donor[0].residue = donor._index;
          accInfo.donor[0].energy = result;
        } else if (result < accInfo.donor[1].energy) {
          accInfo.donor[1].residue = donor._index;
          accInfo.donor[1].energy = result;
        }
      }
      return result;
    }
  }]);
  return HBondInfo2;
}();
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it) o2 = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o2.length) return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o2);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var BridgeType = Object.freeze({
  NO_BRIDGE: 0,
  PARALLEL: 1,
  ANTI_PARALLEL: 2
});
var HelixFlag = Object.freeze({
  START: 1,
  MIDDLE: 2,
  END: 3,
  START_AND_END: 4
});
var StructureType$1 = Object.freeze({
  STRAND: "E",
  BRIDGE: "B",
  HELIX_310: "G",
  HELIX_ALPHA: "H",
  HELIX_PI: "I",
  TURN: "T",
  BEND: "S",
  LOOP: " "
});
var SecondaryStructureMap = function() {
  function SecondaryStructureMap2(complex) {
    _classCallCheck(this, SecondaryStructureMap2);
    this._complex = complex;
    this._build();
  }
  _createClass(SecondaryStructureMap2, [{
    key: "_build",
    value: function _build() {
      var self2 = this;
      this._hbonds = new HBondInfo(this._complex);
      this._ss = [];
      this._sheet = [];
      this._betaPartners = [];
      this._bend = [];
      for (var i2 = 0; i2 < this._complex.getResidues().length; ++i2) {
        this._betaPartners[i2] = [];
      }
      this._helixFlags = [];
      this._helixFlags[3] = [];
      this._helixFlags[4] = [];
      this._helixFlags[5] = [];
      this._chainLengths = [];
      for (var _i = 0; _i < this._complex._chains.length; ++_i) {
        var chain2 = this._complex._chains[_i].getResidues();
        var len = 0;
        for (; len < chain2.length; ++len) {
          if ((chain2[len].getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
            break;
          }
        }
        this._chainLengths[_i] = len;
      }
      this._buildBetaSheets();
      for (var _i2 = 0; _i2 < this._complex._chains.length; ++_i2) {
        self2._buildAlphaHelices(this._complex._chains[_i2].getResidues(), this._chainLengths[_i2], false);
      }
    }
  }, {
    key: "_buildAlphaHelices",
    value: function _buildAlphaHelices(inResidues, chainLength, inPreferPiHelices) {
      for (var stride = 3; stride <= 5; ++stride) {
        if (inResidues.length < stride) {
          break;
        }
        for (var i2 = 0; i2 + stride < chainLength; ++i2) {
          if (this._hbonds.isBond(inResidues[i2 + stride]._index, inResidues[i2]._index)) {
            this._helixFlags[stride][inResidues[i2 + stride]._index] = HelixFlag.END;
            for (var j2 = i2 + 1; j2 < i2 + stride; ++j2) {
              if (typeof this._helixFlags[stride][inResidues[j2]._index] === "undefined") {
                this._helixFlags[stride][inResidues[j2]._index] = HelixFlag.MIDDLE;
              }
            }
            if (this._helixFlags[stride][inResidues[i2]._index] === HelixFlag.END) {
              this._helixFlags[stride][inResidues[i2]._index] = HelixFlag.START_AND_END;
            } else {
              this._helixFlags[stride][inResidues[i2]._index] = HelixFlag.START;
            }
          }
        }
      }
      for (var _i3 = 2; _i3 < chainLength - 2; ++_i3) {
        var kappa = this._kappa(inResidues[_i3 - 2], inResidues[_i3], inResidues[_i3 + 2]);
        this._bend[inResidues[_i3]._index] = kappa !== 360 && kappa > 70;
      }
      for (var _i4 = 1; _i4 + 4 < chainLength; ++_i4) {
        if (this._isHelixStart(inResidues[_i4]._index, 4) && this._isHelixStart(inResidues[_i4 - 1]._index, 4)) {
          for (var _j = _i4; _j <= _i4 + 3; ++_j) {
            this._ss[inResidues[_j]._index] = StructureType$1.HELIX_ALPHA;
          }
        }
      }
      for (var _i5 = 1; _i5 + 3 < chainLength; ++_i5) {
        if (this._isHelixStart(inResidues[_i5]._index, 3) && this._isHelixStart(inResidues[_i5 - 1]._index, 3)) {
          var empty = true;
          for (var _j2 = _i5; empty && _j2 <= _i5 + 2; ++_j2) {
            empty = typeof this._ss[inResidues[_j2]._index] === "undefined" || this._ss[inResidues[_j2]._index] === StructureType$1.HELIX_310;
          }
          if (empty) {
            for (var _j3 = _i5; _j3 <= _i5 + 2; ++_j3) {
              this._ss[inResidues[_j3]._index] = StructureType$1.HELIX_310;
            }
          }
        }
      }
      for (var _i6 = 1; _i6 + 5 < chainLength; ++_i6) {
        if (this._isHelixStart(inResidues[_i6]._index, 5) && this._isHelixStart(inResidues[_i6 - 1]._index, 5)) {
          var _empty = true;
          for (var _j4 = _i6; _empty && _j4 <= _i6 + 4; ++_j4) {
            _empty = typeof this._ss[inResidues[_j4]._index] === "undefined" || this._ss[inResidues[_j4]._index] === StructureType$1.HELIX_PI || inPreferPiHelices && this._ss[inResidues[_j4]._index] === StructureType$1.HELIX_ALPHA;
          }
          if (_empty) {
            for (var _j5 = _i6; _j5 <= _i6 + 4; ++_j5) {
              this._ss[inResidues[_j5]._index] = StructureType$1.HELIX_PI;
            }
          }
        }
      }
      for (var _i7 = 1; _i7 + 1 < chainLength; ++_i7) {
        if (typeof this._ss[inResidues[_i7]._index] === "undefined") {
          var isTurn = false;
          for (var _stride = 3; _stride <= 5 && !isTurn; ++_stride) {
            for (var k2 = 1; k2 < _stride && !isTurn; ++k2) {
              isTurn = _i7 >= k2 && this._isHelixStart(inResidues[_i7 - k2]._index, _stride);
            }
          }
          if (isTurn) {
            this._ss[inResidues[_i7]._index] = StructureType$1.TURN;
          } else if (this._bend[inResidues[_i7]._index]) {
            this._ss[inResidues[_i7]._index] = StructureType$1.BEND;
          }
        }
      }
    }
  }, {
    key: "_residueGetCAlpha",
    value: function _residueGetCAlpha(res) {
      for (var i2 = 0; i2 < res._atoms.length; ++i2) {
        var name2 = res._atoms[i2].name;
        if (name2 === "CA" || name2 === "C1") {
          return res._atoms[i2].position;
        }
      }
      return null;
    }
  }, {
    key: "_cosinusAngle",
    value: function _cosinusAngle(p1, p2, p3, p4) {
      var v12 = p1.clone().sub(p2);
      var v34 = p3.clone().sub(p4);
      var result = 0;
      var x2 = v12.dot(v12) * v34.dot(v34);
      if (x2 > 0) {
        result = v12.dot(v34) / Math.sqrt(x2);
      }
      return result;
    }
  }, {
    key: "_kappa",
    value: function _kappa(prevPrev, res, nextNext) {
      var curCA = this._residueGetCAlpha(res);
      var ppCA = this._residueGetCAlpha(prevPrev);
      var nnCA = this._residueGetCAlpha(nextNext);
      if (curCA === null || ppCA === null || nnCA === null) {
        return 180;
      }
      var ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA);
      var skap = Math.sqrt(1 - ckap * ckap);
      return Math.atan2(skap, ckap) * 180 / Math.PI;
    }
  }, {
    key: "_isHelixStart",
    value: function _isHelixStart(res, stride) {
      return this._helixFlags[stride][res] === HelixFlag.START || this._helixFlags[stride][res] === HelixFlag.START_AND_END;
    }
  }, {
    key: "_buildBetaSheets",
    value: function _buildBetaSheets() {
      var bridges = [];
      for (var a2 = 0; a2 < this._complex._chains.length; ++a2) {
        var lenA = this._chainLengths[a2];
        if (lenA <= 4) {
          continue;
        }
        var chainA = this._complex._chains[a2].getResidues();
        for (var b2 = a2; b2 < this._complex._chains.length; ++b2) {
          var lenB = this._chainLengths[b2];
          if (lenB <= 4) {
            continue;
          }
          var chainB = this._complex._chains[b2].getResidues();
          for (var i2 = 1; i2 + 1 < lenA; ++i2) {
            var ri = chainA[i2];
            var j2 = 1;
            if (b2 === a2) {
              j2 = i2 + 3;
            }
            for (; j2 + 1 < lenB; ++j2) {
              var rj = chainB[j2];
              var type = this._testBridge(chainA, i2, chainB, j2);
              if (type === BridgeType.NO_BRIDGE) {
                continue;
              }
              var found = false;
              var _iterator = _createForOfIteratorHelper(bridges), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var bridge = _step.value;
                  if (type !== bridge.type || ri._index !== bridge.i[bridge.i.length - 1] + 1) {
                    continue;
                  }
                  if (type === BridgeType.PARALLEL && bridge.j[bridge.j.length - 1] + 1 === rj._index) {
                    bridge.i.push(ri._index);
                    bridge.j.push(rj._index);
                    found = true;
                    break;
                  }
                  if (type === BridgeType.ANTI_PARALLEL && bridge.j[0] - 1 === rj._index) {
                    bridge.i.push(ri._index);
                    bridge.j.unshift(rj._index);
                    found = true;
                    break;
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              if (!found) {
                bridges.push({
                  type,
                  i: [ri._index],
                  chainI: ri.getChain()._index,
                  j: [rj._index],
                  chainJ: rj.getChain()._index
                });
              }
            }
          }
        }
      }
      bridges.sort(function(a3, b3) {
        if (a3.chainI < b3.chainI || a3.chainI === b3.chainI && a3.i[0] < b3.i[0]) {
          return -1;
        }
        return 1;
      });
      for (var _i8 = 0; _i8 < bridges.length; ++_i8) {
        for (var _j6 = _i8 + 1; _j6 < bridges.length; ++_j6) {
          var ibi = bridges[_i8].i[0];
          var iei = bridges[_i8].i[bridges[_i8].i.length - 1];
          var jbi = bridges[_i8].j[0];
          var jei = bridges[_i8].j[bridges[_i8].j.length - 1];
          var ibj = bridges[_j6].i[0];
          var iej = bridges[_j6].i[bridges[_j6].i.length - 1];
          var jbj = bridges[_j6].j[0];
          var jej = bridges[_j6].j[bridges[_j6].j.length - 1];
          if (bridges[_i8].type !== bridges[_j6].type || this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) || this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) || ibj - iei >= 6 || iei >= ibj && ibi <= iej) {
            continue;
          }
          var bulge = false;
          if (bridges[_i8].type === BridgeType.PARALLEL) {
            bulge = jbj - jei < 6 && ibj - iei < 3 || jbj - jei < 3;
          } else {
            bulge = jbi - jej < 6 && ibj - iei < 3 || jbi - jej < 3;
          }
          if (bulge) {
            bridges[_i8].i = bridges[_i8].i.concat(bridges[_j6].i);
            if (bridges[_i8].type === BridgeType.PARALLEL) {
              bridges[_i8].j = bridges[_i8].j.concat(bridges[_j6].j);
            } else {
              bridges[_i8].j = bridges[_j6].j.concat(bridges[_i8].j);
            }
            bridges.splice(_j6--, 1);
          }
        }
      }
      var ladderset = /* @__PURE__ */ new Set();
      for (var _i9 = 0; _i9 < bridges.length; ++_i9) {
        ladderset.add(bridges[_i9]);
      }
      var sheet = 1;
      var ladder = 0;
      while (ladderset.size > 0) {
        var _bridge = ladderset.values().next().value;
        ladderset.delete(_bridge);
        var sheetset = /* @__PURE__ */ new Set();
        sheetset.add(_bridge);
        var toMove = void 0;
        do {
          toMove = /* @__PURE__ */ new Set();
          var _iterator2 = _createForOfIteratorHelper(sheetset.values()), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _a = _step2.value;
              var _iterator4 = _createForOfIteratorHelper(ladderset.values()), _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                  var _b = _step4.value;
                  if (this._areBridgesLinked(_a, _b)) {
                    toMove.add(_b);
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          var _iterator3 = _createForOfIteratorHelper(toMove.values()), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              _bridge = _step3.value;
              sheetset.add(_bridge);
              ladderset.delete(_bridge);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        } while (toMove.size > 0);
        var _iterator5 = _createForOfIteratorHelper(sheetset.values()), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            _bridge = _step5.value;
            _bridge.ladder = ladder;
            _bridge.sheet = sheet;
            _bridge.link = sheetset;
            ++ladder;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        ++sheet;
      }
      for (var _i10 = 0; _i10 < bridges.length; ++_i10) {
        var _bridge2 = bridges[_i10];
        var betai = 0;
        var betaj = 0;
        for (var l2 = 0; l2 < _bridge2.i.length; ++l2) {
          if (this._betaPartners[_bridge2.i[l2]][0]) {
            betai = 1;
            break;
          }
        }
        for (var _l = 0; _l < _bridge2.j.length; ++_l) {
          if (this._betaPartners[_bridge2.j[_l]][0]) {
            betaj = 1;
            break;
          }
        }
        var ss = StructureType$1.BRIDGE;
        if (_bridge2.i.length > 1) {
          ss = StructureType$1.STRAND;
        }
        if (_bridge2.type === BridgeType.PARALLEL) {
          var _j7 = 0;
          for (var k2 = 0; k2 < _bridge2.i.length; ++k2) {
            this._betaPartners[_bridge2.i[k2]][betai] = {
              residue: _bridge2.j[_j7++],
              ladder: _bridge2.ladder,
              parallel: true
            };
          }
          _j7 = 0;
          for (var _k = 0; _k < _bridge2.j.length; ++_k) {
            this._betaPartners[_bridge2.j[_k]][betaj] = {
              residue: _bridge2.i[_j7++],
              ladder: _bridge2.ladder,
              parallel: true
            };
          }
        } else {
          var _j8 = _bridge2.j.length - 1;
          for (var _k2 = 0; _k2 < _bridge2.i.length; ++_k2) {
            this._betaPartners[_bridge2.i[_k2]][betai] = {
              residue: _bridge2.j[_j8--],
              ladder: _bridge2.ladder,
              parallel: false
            };
          }
          _j8 = _bridge2.i.length - 1;
          for (var _k3 = 0; _k3 < _bridge2.j.length; ++_k3) {
            this._betaPartners[_bridge2.j[_k3]][betaj] = {
              residue: _bridge2.i[_j8--],
              ladder: _bridge2.ladder,
              parallel: false
            };
          }
        }
        for (var _k4 = _bridge2.i[0]; _k4 <= _bridge2.i[_bridge2.i.length - 1]; ++_k4) {
          if (this._ss[_k4] !== StructureType$1.STRAND) {
            this._ss[_k4] = ss;
            this._sheet[_k4] = _bridge2.sheet;
          }
        }
        for (var _k5 = _bridge2.j[0]; _k5 <= _bridge2.j[_bridge2.j.length - 1]; ++_k5) {
          if (this._ss[_k5] !== StructureType$1.STRAND) {
            this._ss[_k5] = ss;
            this._sheet[_k5] = _bridge2.sheet;
          }
        }
      }
    }
  }, {
    key: "_testBridge",
    value: function _testBridge(chainA, from, chainB, to) {
      var result = BridgeType.NO_BRIDGE;
      var a2 = chainA[from - 1]._index;
      var b2 = chainA[from]._index;
      var c2 = chainA[from + 1]._index;
      var d2 = chainB[to - 1]._index;
      var e2 = chainB[to]._index;
      var f2 = chainB[to + 1]._index;
      var isBond = this._hbonds.isBond.bind(this._hbonds);
      if (isBond(c2, e2) && isBond(e2, a2) || isBond(f2, b2) && isBond(b2, d2)) {
        result = BridgeType.PARALLEL;
      } else if (isBond(c2, d2) && isBond(f2, a2) || isBond(e2, b2) && isBond(b2, e2)) {
        result = BridgeType.ANTI_PARALLEL;
      }
      return result;
    }
  }, {
    key: "_areBridgesLinked",
    value: function _areBridgesLinked(a2, b2) {
      var ai = new Set(a2.i);
      var aj = new Set(a2.j);
      var _iterator6 = _createForOfIteratorHelper(b2.i), _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          var i2 = _step6.value;
          if (ai.has(i2) || aj.has(i2)) {
            return true;
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      var _iterator7 = _createForOfIteratorHelper(b2.j), _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
          var _i11 = _step7.value;
          if (ai.has(_i11) || aj.has(_i11)) {
            return true;
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return false;
    }
  }, {
    key: "_hasChainBreak",
    value: function _hasChainBreak(from, to) {
      for (var i2 = from + 1; i2 <= to; ++i2) {
        if (this._complex._residues[i2]._sequence !== this._complex._residues[i2 - 1]._sequence + 1) {
          return true;
        }
      }
      return false;
    }
  }]);
  return SecondaryStructureMap2;
}();
SecondaryStructureMap.StructureType = StructureType$1;
var _helixClassMap;
var _loopMap;
var VOXEL_SIZE = 5;
var StructureType = SecondaryStructureMap.StructureType;
var StructuralElementType$3 = StructuralElement.Type;
var helixClassMap = (_helixClassMap = {}, _defineProperty2(_helixClassMap, StructureType.HELIX_ALPHA, 1), _defineProperty2(_helixClassMap, StructureType.HELIX_PI, 3), _defineProperty2(_helixClassMap, StructureType.HELIX_310, 5), _helixClassMap);
var loopMap = (_loopMap = {}, _defineProperty2(_loopMap, StructureType.BRIDGE, StructuralElementType$3.BRIDGE), _defineProperty2(_loopMap, StructureType.TURN, StructuralElementType$3.TURN), _defineProperty2(_loopMap, StructureType.BEND, StructuralElementType$3.BEND), _defineProperty2(_loopMap, StructureType.LOOP, StructuralElementType$3.COIL), _loopMap);
var Complex$9 = function() {
  function Complex2() {
    _classCallCheck(this, Complex2);
    this._chains = [];
    this._components = [];
    this._helices = [];
    this._sheets = [];
    this.structures = [];
    this._residueTypes = Object.create(ResidueType$1.StandardTypes);
    this._atoms = [];
    this._residues = [];
    this._bonds = [];
    this._sgroups = [];
    this._molecules = [];
    this._maskNeedsUpdate = false;
    this.metadata = {};
    this.symmetry = [];
    this.units = [new BiologicalUnit(this)];
    this._currentUnit = 0;
  }
  _createClass(Complex2, [{
    key: "addAtom",
    value: function addAtom(atom) {
      var index = this._atoms.length;
      this._atoms.push(atom);
      return index;
    }
  }, {
    key: "addSheet",
    value: function addSheet(sheet) {
      var index = this._sheets.length;
      this._sheets.push(sheet);
      return index;
    }
  }, {
    key: "addHelix",
    value: function addHelix(helix) {
      var index = this._helices.length;
      this._helices.push(helix);
      return index;
    }
  }, {
    key: "getAtoms",
    value: function getAtoms() {
      return this._atoms;
    }
  }, {
    key: "getBonds",
    value: function getBonds() {
      return this._bonds;
    }
  }, {
    key: "getAtomCount",
    value: function getAtomCount() {
      return this._atoms.length;
    }
  }, {
    key: "addResidue",
    value: function addResidue(residue2) {
      var index = this._residues.length;
      this._residues.push(residue2);
      return index;
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      this.forEachChain(function(chain2) {
        chain2.updateToFrame(frameData);
      });
    }
  }, {
    key: "addResidueType",
    value: function addResidueType(resName) {
      var rt = this._residueTypes[resName] = new ResidueType$1(resName, "Unknown", "");
      return rt;
    }
  }, {
    key: "getResidueCount",
    value: function getResidueCount() {
      return this._residues.length;
    }
  }, {
    key: "getResidues",
    value: function getResidues() {
      return this._residues;
    }
  }, {
    key: "getSGroupCount",
    value: function getSGroupCount() {
      return this._sgroups.length;
    }
  }, {
    key: "getSGroups",
    value: function getSGroups() {
      return this._sgroups;
    }
  }, {
    key: "getAtomByFullname",
    value: function getAtomByFullname(fullName) {
      var parts = fullName.split(".");
      if (parts.length !== 3) {
        return null;
      }
      var chainName = parts[0];
      var resId = parseInt(parts[1], 10);
      if (Number.isNaN(resId)) {
        return null;
      }
      var atomName = parts[2].toUpperCase();
      var currAtom = null;
      this.forEachChain(function(chain2) {
        if (currAtom) {
          return;
        }
        if (chain2._name.localeCompare(chainName) === 0) {
          chain2.forEachResidue(function(residue2) {
            if (currAtom) {
              return;
            }
            if (residue2._sequence === resId) {
              residue2.forEachAtom(function(atom) {
                if (currAtom) {
                  return;
                }
                if (atomName.localeCompare(atom.name) === 0) {
                  currAtom = atom;
                }
              });
            }
          });
        }
      });
      return currAtom;
    }
  }, {
    key: "addChain",
    value: function addChain(name2) {
      var result = new Chain$2(this, name2);
      this._chains.push(result);
      return result;
    }
  }, {
    key: "getChain",
    value: function getChain(name2) {
      for (var i2 = 0, n2 = this._chains.length; i2 < n2; ++i2) {
        var chain2 = this._chains[i2];
        if (chain2.getName() === name2) {
          return chain2;
        }
      }
      return null;
    }
  }, {
    key: "getChainCount",
    value: function getChainCount() {
      return this._chains.length;
    }
  }, {
    key: "getMolecules",
    value: function getMolecules() {
      return this._molecules;
    }
  }, {
    key: "getMoleculeCount",
    value: function getMoleculeCount() {
      return this._molecules.length;
    }
  }, {
    key: "forEachAtom",
    value: function forEachAtom(process2) {
      var atoms = this._atoms;
      for (var i2 = 0, n2 = atoms.length; i2 < n2; ++i2) {
        process2(atoms[i2]);
      }
    }
  }, {
    key: "forEachBond",
    value: function forEachBond(process2) {
      var bonds = this._bonds;
      for (var i2 = 0, n2 = bonds.length; i2 < n2; ++i2) {
        process2(bonds[i2]);
      }
    }
  }, {
    key: "forEachResidue",
    value: function forEachResidue(process2) {
      var residues = this._residues;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        process2(residues[i2]);
      }
    }
  }, {
    key: "forEachChain",
    value: function forEachChain(process2) {
      var chains = this._chains;
      for (var i2 = 0, n2 = chains.length; i2 < n2; ++i2) {
        process2(chains[i2]);
      }
    }
  }, {
    key: "forEachMolecule",
    value: function forEachMolecule(process2) {
      var molecules = this._molecules;
      var n2 = molecules.length;
      for (var i2 = 0; i2 < n2; ++i2) {
        process2(molecules[i2]);
      }
    }
  }, {
    key: "forEachSGroup",
    value: function forEachSGroup(process2) {
      var groups2 = this._sgroups;
      for (var i2 = 0, n2 = groups2.length; i2 < n2; ++i2) {
        process2(groups2[i2]);
      }
    }
  }, {
    key: "forEachComponent",
    value: function forEachComponent(process2) {
      var components = this._components;
      for (var i2 = 0, n2 = components.length; i2 < n2; ++i2) {
        process2(components[i2]);
      }
    }
  }, {
    key: "forEachVisibleComponent",
    value: function forEachVisibleComponent(process2) {
      var components = this._components;
      for (var i2 = 0, n2 = components.length; i2 < n2; ++i2) {
        process2(components[i2]);
      }
    }
  }, {
    key: "addBond",
    value: function addBond(left, right, order, type, fixed3) {
      var bond = new Bond$5(left, right, order, type, fixed3);
      this._bonds.push(bond);
      return bond;
    }
  }, {
    key: "getBondCount",
    value: function getBondCount() {
      return this._bonds.length;
    }
  }, {
    key: "getResidueType",
    value: function getResidueType(name2) {
      return this._residueTypes[name2] || null;
    }
  }, {
    key: "getUnifiedSerial",
    value: function getUnifiedSerial(chain2, serial2, iCode) {
      var maxSerial = 65536;
      var chainShift = maxSerial * 256;
      return serial2 + iCode * maxSerial + chain2 * chainShift;
    }
  }, {
    key: "splitUnifiedSerial",
    value: function splitUnifiedSerial(uniSerial) {
      var maxSerial = 65536;
      var chainShift = maxSerial * 256;
      var chainId = Math.floor(uniSerial / chainShift);
      var remnant = uniSerial - chainId * chainShift;
      var insCode = Math.floor(remnant / maxSerial);
      var ser = remnant - insCode * maxSerial;
      return {
        chain: chainId,
        serial: ser,
        iCode: insCode
      };
    }
  }, {
    key: "_fillCmpEdit",
    value: function _fillCmpEdit() {
      var self2 = this;
      var components = this._components;
      function addComp() {
        var comp = new Component(self2);
        comp._index = components.length;
        components[comp._index] = comp;
        return comp;
      }
      this.forEachChain(function(chain2) {
        var residues = chain2._residues;
        var resCount = residues.length;
        if (resCount < 1) {
          return;
        }
        var comp = addComp();
        var currStart = residues[0]._index;
        for (var i2 = 0; i2 < resCount; ++i2) {
          var currRes = residues[i2];
          currRes._component = comp;
          var nextRes = i2 === resCount - 1 ? null : residues[i2 + 1];
          if (!nextRes || !currRes.isConnected(nextRes) || currRes._index !== nextRes._index - 1) {
            comp.setSubDivs([{
              start: currStart,
              end: currRes._index
            }]);
            if (nextRes) {
              currStart = nextRes._index;
              comp = addComp();
            }
          }
        }
      });
    }
  }, {
    key: "_fillCmpNoedit",
    value: function _fillCmpNoedit() {
      var comp = new Component(this);
      comp._index = 0;
      var residues = this._residues;
      var resCount = residues.length;
      if (resCount === 0) {
        return;
      }
      var currSubDivs = [];
      var currStart = 0;
      for (var i2 = 0; i2 < resCount; ++i2) {
        var currRes = residues[i2];
        currRes._component = comp;
        var nextRes = i2 === resCount - 1 ? null : residues[i2 + 1];
        if (!nextRes || !currRes.isConnected(nextRes)) {
          currSubDivs[currSubDivs.length] = {
            start: currStart,
            end: i2
          };
          if (nextRes) {
            currStart = i2 + 1;
          }
        }
      }
      comp.setSubDivs(currSubDivs);
      this._components[comp._index] = comp;
    }
  }, {
    key: "_fillComponents",
    value: function _fillComponents(enableEditing) {
      if (enableEditing) {
        this._fillCmpEdit();
      } else {
        this._fillCmpNoedit();
      }
    }
  }, {
    key: "getCurrentUnit",
    value: function getCurrentUnit() {
      return this._currentUnit;
    }
  }, {
    key: "getDefaultBoundaries",
    value: function getDefaultBoundaries() {
      return this.units[0].getBoundaries();
    }
  }, {
    key: "getBoundaries",
    value: function getBoundaries() {
      return this.units[this._currentUnit].getBoundaries();
    }
  }, {
    key: "getTransforms",
    value: function getTransforms() {
      return this.units[this._currentUnit].getTransforms();
    }
  }, {
    key: "getSelector",
    value: function getSelector() {
      return this.units[this._currentUnit].getSelector();
    }
  }, {
    key: "resetCurrentUnit",
    value: function resetCurrentUnit() {
      this._currentUnit = 0;
      this.setCurrentUnit(1);
    }
  }, {
    key: "setCurrentUnit",
    value: function setCurrentUnit(newUnit) {
      if (newUnit !== null && newUnit !== void 0 && newUnit !== this._currentUnit && newUnit >= 0 && newUnit < this.units.length) {
        this._currentUnit = newUnit;
        return true;
      }
      return false;
    }
  }, {
    key: "_computeBounds",
    value: function _computeBounds() {
      var units = this.units;
      for (var i2 = 0, n2 = units.length; i2 < n2; ++i2) {
        units[i2].computeBoundaries();
      }
    }
  }, {
    key: "onAtomPositionChanged",
    value: function onAtomPositionChanged() {
      this.forEachChain(function(a2) {
        a2._finalize();
      });
      this.forEachComponent(function(c2) {
        c2.update();
      });
      this._computeBounds();
      this._finalizeBonds();
      this.forEachSGroup(function(s2) {
        s2._rebuildSGroupOnAtomChange();
      });
    }
  }, {
    key: "update",
    value: function update() {
      if (this._maskNeedsUpdate) {
        this.updateStructuresMask();
        this._maskNeedsUpdate = false;
      }
    }
  }, {
    key: "_finalizeBonds",
    value: function _finalizeBonds() {
      var bonds = this.getBonds();
      var n2 = bonds.length;
      for (var i2 = 0; i2 < n2; ++i2) {
        bonds[i2]._index = i2;
      }
    }
  }, {
    key: "finalize",
    value: function finalize(opts) {
      opts = opts || {};
      var bonds = this._bonds;
      var i2;
      var n2;
      for (i2 = bonds.length - 1; i2 >= 0; i2--) {
        var bond = bonds[i2];
        if (bond._left === null || bond._right === null) {
          bonds.splice(i2, 1);
        } else {
          bond._left.bonds.push(bond);
          bond._right.bonds.push(bond);
        }
      }
      var residues = this._residues;
      for (i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        residues[i2]._finalize();
      }
      this.forEachChain(function(a2) {
        a2._finalize();
      });
      var units = this.units;
      for (i2 = 0, n2 = units.length; i2 < n2; ++i2) {
        units[i2].finalize();
      }
      this.setCurrentUnit(1);
      var residueHash = {};
      for (i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        var res = residues[i2];
        residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
      }
      var structures = this.structures;
      for (i2 = 0, n2 = structures.length; i2 < n2; ++i2) {
        structures[i2]._finalize(opts.serialAtomMap, residueHash, this);
      }
      var helices = this._helices;
      for (i2 = 0, n2 = helices.length; i2 < n2; ++i2) {
        helices[i2]._finalize(opts.serialAtomMap, residueHash, this);
      }
      var sheets = this._sheets;
      for (i2 = 0, n2 = sheets.length; i2 < n2; ++i2) {
        sheets[i2]._finalize(opts.serialAtomMap, residueHash, this);
      }
      this._computeBounds();
      var atoms = this._atoms;
      for (i2 = 0, n2 = atoms.length; i2 < n2; ++i2) {
        var currAtom = atoms[i2];
        currAtom.index = i2;
      }
      if (opts.needAutoBonding) {
        var autoConnector = new AutoBond(this);
        autoConnector.build();
        autoConnector.destroy();
      }
      var chains = this._chains;
      for (i2 = 0, n2 = chains.length; i2 < n2; ++i2) {
        chains[i2]._index = i2;
      }
      for (i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        residues[i2]._index = i2;
      }
      for (i2 = 0, n2 = atoms.length; i2 < n2; ++i2) {
        var atom = atoms[i2];
        if (atom.flags & Atom$2.Flags.HYDROGEN && atom.bonds.length === 1) {
          var _bond = atom.bonds[0];
          var other = _bond._left !== atom && _bond._left || _bond._right;
          if (other.flags & Atom$2.Flags.CARBON) {
            atom.flags |= Atom$2.Flags.NONPOLARH;
          }
        }
      }
      this._finalizeBonds();
      this._fillComponents(opts.enableEditing);
      var marker = new AromaticLoopsMarker(this);
      marker.markCycles();
      if (opts.detectAromaticLoops) {
        marker.detectCycles();
      }
      this._finalizeMolecules();
    }
  }, {
    key: "_finalizeMolecules",
    value: function _finalizeMolecules() {
      for (var i2 = 0; i2 < this._molecules.length; i2++) {
        var molecule = this._molecules[i2];
        var count = molecule.residues.length;
        for (var j2 = 0; j2 < count; j2++) {
          var residue2 = molecule.residues[j2];
          residue2._molecule = molecule;
        }
      }
    }
  }, {
    key: "updateStructuresMask",
    value: function updateStructuresMask() {
      var updater = function updater2(structure) {
        return structure.collectMask();
      };
      this.forEachResidue(updater);
      this.forEachChain(updater);
      this.forEachMolecule(updater);
    }
  }, {
    key: "countAtomsByMask",
    value: function countAtomsByMask(mask) {
      var count = 0;
      this.forEachAtom(function(atom) {
        if ((atom.mask & mask) !== 0) {
          count++;
        }
      });
      return count;
    }
  }, {
    key: "getNumAtomsBySelector",
    value: function getNumAtomsBySelector(selector) {
      var count = 0;
      this.forEachAtom(function(atom) {
        if (selector.includesAtom(atom)) {
          count++;
        }
      });
      return count;
    }
  }, {
    key: "resetAtomMask",
    value: function resetAtomMask(mask) {
      this.forEachAtom(function(atom) {
        atom.mask = mask;
      });
    }
  }, {
    key: "markAtoms",
    value: function markAtoms(selector, mask) {
      var setMask = mask;
      var clearMask = ~setMask;
      var count = 0;
      var totalSelector = selectors$5.keyword("And")(selector, this.getSelector());
      this.forEachAtom(function(atom) {
        if (totalSelector.includesAtom(atom)) {
          atom.mask |= setMask;
          count++;
        } else {
          atom.mask &= clearMask;
        }
      });
      this._maskNeedsUpdate = true;
      return count;
    }
  }, {
    key: "markAtomsAdditionally",
    value: function markAtomsAdditionally(selector, mask) {
      var setMask = mask;
      var count = 0;
      this.forEachAtom(function(atom) {
        if (selector.includesAtom(atom) && (atom.mask & mask) !== mask) {
          atom.mask |= setMask;
          count++;
        }
      });
      return count;
    }
  }, {
    key: "clearAtomBits",
    value: function clearAtomBits(mask) {
      var clearMask = ~mask;
      this.forEachAtom(function(atom) {
        atom.mask &= clearMask;
      });
      var reseter = function reseter2(a2) {
        a2._mask &= clearMask;
      };
      this.forEachAtom(reseter);
      this.forEachResidue(reseter);
      this.forEachChain(reseter);
      this.forEachMolecule(reseter);
    }
  }, {
    key: "getAtomNames",
    value: function getAtomNames() {
      if (this.hasOwnProperty("_atomNames")) {
        return this._atomNames;
      }
      var dict = {};
      this.forEachAtom(function(atom) {
        dict[atom.name] = 1;
      });
      this._atomNames = Object.keys(dict);
      return this._atomNames;
    }
  }, {
    key: "getElements",
    value: function getElements() {
      if (this.hasOwnProperty("_elements")) {
        return this._elements;
      }
      var dict = {};
      this.forEachAtom(function(atom) {
        dict[atom.element.name] = 1;
      });
      this._elements = Object.keys(dict);
      return this._elements;
    }
  }, {
    key: "getResidueNames",
    value: function getResidueNames() {
      if (this.hasOwnProperty("_residueNames")) {
        return this._residueNames;
      }
      var dict = {};
      this.forEachResidue(function(res) {
        dict[res._type._name] = 1;
      });
      this._residueNames = Object.keys(dict);
      return this._residueNames;
    }
  }, {
    key: "getChainNames",
    value: function getChainNames() {
      if (this.hasOwnProperty("_chainNames")) {
        return this._chainNames;
      }
      var dict = {};
      this.forEachChain(function(chain2) {
        dict[chain2._name] = 1;
      });
      this._chainNames = Object.keys(dict);
      return this._chainNames;
    }
  }, {
    key: "getAltLocNames",
    value: function getAltLocNames() {
      if (this.hasOwnProperty("_altlocNames")) {
        return this._altlocNames;
      }
      var dict = {};
      this.forEachAtom(function(atom) {
        dict[String.fromCharCode(atom.location)] = 1;
      });
      this._altlocNames = Object.keys(dict);
      return this._altlocNames;
    }
  }, {
    key: "getVoxelWorld",
    value: function getVoxelWorld() {
      if (!this.hasOwnProperty("_voxelWorld")) {
        try {
          this._voxelWorld = new VoxelWorld(this.getDefaultBoundaries().boundingBox, new Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE));
          this._voxelWorld.addAtoms(this);
        } catch (e2) {
          logger.warn("Unable to create voxel world");
          this._voxelWorld = null;
        }
      }
      return this._voxelWorld;
    }
  }, {
    key: "addElement",
    value: function addElement(srcArray, dstArray, param, functor) {
      var length = srcArray.length;
      for (var i2 = 0; i2 < length; ++i2) {
        var elem2 = srcArray[i2];
        functor(elem2, param);
        dstArray.push(elem2);
      }
    }
  }, {
    key: "joinComplexes",
    value: function joinComplexes(complexes) {
      this._chains = [];
      this._components = [];
      this._helices = [];
      this._sheets = [];
      this.structures = [];
      this._atoms = [];
      this._residues = [];
      this._bonds = [];
      this._sgroups = [];
      var self2 = this;
      var atomBias = 0;
      var bondBias = 0;
      var residueBias = 0;
      var chainBias = 0;
      var componentBias = 0;
      function processAtom(atom, bias) {
        atom.serial += bias;
        atom.index += bias;
      }
      function processBond(bond, bias) {
        bond._index += bias;
      }
      function processResidue(residue2, bias) {
        residue2._index += bias;
      }
      function processChain(chain2, bias) {
        chain2._complex = self2;
        chain2._index += bias;
      }
      function processComponent(component, bias) {
        component._complex = self2;
        component._index += bias;
      }
      function doNothing() {
      }
      for (var i2 = 0; i2 < complexes.length; ++i2) {
        var c2 = complexes[i2];
        this.addElement(c2._atoms, this._atoms, atomBias, processAtom);
        this.addElement(c2._bonds, this._bonds, bondBias, processBond);
        this.addElement(c2._residues, this._residues, residueBias, processResidue);
        this.addElement(c2._chains, this._chains, chainBias, processChain);
        this.addElement(c2._sheets, this._sheets, 0, doNothing);
        this.addElement(c2._helices, this._helices, 0, doNothing);
        this.addElement(c2._sgroups, this._sgroups, 0, doNothing);
        this.addElement(c2._components, this._components, componentBias, processComponent);
        this.addElement(c2.structures, this.structures, 0, doNothing);
        for (var rt in c2._residueTypes) {
          if (c2._residueTypes.hasOwnProperty(rt)) {
            this._residueTypes[rt] = c2._residueTypes[rt];
          }
        }
        atomBias += c2._atoms.length;
        bondBias += c2._bonds.length;
        residueBias += c2._residues.length;
        chainBias += c2._chains.length;
        componentBias += c2._components.length;
      }
      this._computeBounds();
    }
  }, {
    key: "dssp",
    value: function dssp() {
      var ssMap = new SecondaryStructureMap(this);
      var structures = this.structures = [];
      var helices = this._helices = [];
      var sheets = this._sheets = [];
      var getSheet = function getSheet2(index) {
        var item = sheets[index];
        if (!item) {
          item = sheets[index] = new Sheet$3(String(index), 0);
        }
        return item;
      };
      var lastCode;
      var lastSheetIndex;
      var lastHelixIndex = 0;
      var curStructure = null;
      for (var i2 = 0, n2 = this._residues.length; i2 < n2; ++i2) {
        var curCode = ssMap._ss[i2];
        var curResidue = this._residues[i2];
        var curSheetIndex = ssMap._sheet[i2];
        if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
          curResidue._secondary = curStructure;
          if (curStructure) {
            curStructure.term = curResidue;
          }
          if (curStructure instanceof Helix$3) {
            curStructure.length++;
          }
          continue;
        }
        var helixClass = helixClassMap[curCode];
        var loopType = loopMap[curCode];
        if (curCode === StructureType.STRAND) {
          var curSheet = getSheet(curSheetIndex);
          curStructure = new Strand$3(curSheet, curResidue, curResidue, 0, null, null);
          curSheet.addStrand(curStructure);
        } else if (helixClass !== void 0) {
          lastHelixIndex++;
          curStructure = new Helix$3(helixClass, curResidue, curResidue, lastHelixIndex, String(lastHelixIndex), "", 1);
          helices.push(curStructure);
        } else if (loopType !== void 0) {
          curStructure = new StructuralElement(loopType, curResidue, curResidue);
        } else {
          curStructure = null;
        }
        if (curStructure) {
          structures.push(curStructure);
        }
        curResidue._secondary = curStructure;
        lastCode = curCode;
        lastSheetIndex = curSheetIndex;
      }
      this._sheets = sheets.filter(function(_sheet) {
        return true;
      });
    }
  }]);
  return Complex2;
}();
Complex$9.prototype.id = "Complex";
Complex$9.prototype.name = "";
function pow2ceil(v2) {
  var p2 = 2;
  v2 = v2 - 1 >> 1;
  while (v2) {
    p2 <<= 1;
    v2 >>= 1;
  }
  return p2;
}
var Volume$2 = function() {
  function Volume2(type, dimensions, box, vecSize, data, volumeInfo) {
    _classCallCheck(this, Volume2);
    this._box = box.clone();
    this._dimVec = Math.max(Math.floor(vecSize || 1), 1);
    this._volumeInfo = volumeInfo;
    if (dimensions instanceof Array) {
      var _dimensions = _slicedToArray(dimensions, 3);
      this._dimX = _dimensions[0];
      this._dimY = _dimensions[1];
      this._dimZ = _dimensions[2];
    } else {
      this._dimX = dimensions.x;
      this._dimY = dimensions.y;
      this._dimZ = dimensions.z;
    }
    this._dimX = Math.max(Math.floor(this._dimX), 1);
    this._dimY = Math.max(Math.floor(this._dimY), 1);
    this._dimZ = Math.max(Math.floor(this._dimZ), 1);
    this._rowElements = this._dimVec * this._dimX;
    this._planeElements = this._rowElements * this._dimY;
    this._totalElements = this._planeElements * this._dimZ;
    this._data = data || utils.allocateTyped(type, this._totalElements);
    switch (this._dimVec) {
      case 1:
        break;
      case 2:
        this.getValue = function(x2, y2, z2) {
          var idx = x2 * this._dimVec + y2 * this._rowElements + z2 * this._planeElements;
          return [this._data[idx], this._data[idx + 1]];
        };
        this.setValue = function(x2, y2, z2, a2, b2) {
          var idx = x2 * this._dimVec + y2 * this._rowElements + z2 * this._planeElements;
          this._data[idx] = a2;
          this._data[idx + 1] = b2;
        };
        this.addValue = function(x2, y2, z2, a2, b2) {
          var idx = x2 * this._dimVec + y2 * this._rowElements + z2 * this._planeElements;
          this._data[idx] += a2;
          this._data[idx + 1] += b2;
        };
        break;
      case 3:
        this.getValue = function(x2, y2, z2) {
          var idx = x2 * this._dimVec + y2 * this._rowElements + z2 * this._planeElements;
          return [this._data[idx], this._data[idx + 1], this._data[idx + 2]];
        };
        this.setValue = function(x2, y2, z2, a2, b2, c2) {
          var idx = x2 * this._dimVec + y2 * this._rowElements + z2 * this._planeElements;
          this._data[idx] = a2;
          this._data[idx + 1] = b2;
          this._data[idx + 2] = c2;
        };
        this.addValue = function(x2, y2, z2, a2, b2, c2) {
          var idx = x2 * this._dimVec + y2 * this._rowElements + z2 * this._planeElements;
          this._data[idx] += a2;
          this._data[idx + 1] += b2;
          this._data[idx + 2] += c2;
        };
        break;
      default:
        throw new Error("Volume: invalid vector dimension");
    }
  }
  _createClass(Volume2, [{
    key: "getValue",
    value: function getValue(x2, y2, z2) {
      return this._data[x2 + y2 * this._rowElements + z2 * this._planeElements];
    }
  }, {
    key: "setValue",
    value: function setValue(x2, y2, z2, val) {
      this._data[x2 + y2 * this._rowElements + z2 * this._planeElements] = val;
    }
  }, {
    key: "addValue",
    value: function addValue(x2, y2, z2, val) {
      this._data[x2 + y2 * this._rowElements + z2 * this._planeElements] += val;
    }
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return [this._dimX, this._dimY, this._dimZ];
    }
  }, {
    key: "getBox",
    value: function getBox() {
      return this._box;
    }
  }, {
    key: "getVolumeInfo",
    value: function getVolumeInfo() {
      return this._volumeInfo;
    }
  }, {
    key: "getCellSize",
    value: function getCellSize() {
      var boxSize = new Vector3();
      this._box.getSize(boxSize);
      var res = new Vector3();
      res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0;
      res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0;
      res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0;
      return res;
    }
  }, {
    key: "computeGradient",
    value: function computeGradient() {
      if (this._dimVec !== 1) {
        return null;
      }
      var gradient = new Volume2(Float32Array, [this._dimX, this._dimY, this._dimZ], this._box, 3);
      var vl = this.getCellSize();
      var vs = new Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z);
      function clamp3(val, min, max) {
        return Math.min(max, Math.max(min, val));
      }
      var xSize = this._dimX;
      var ySize = this._dimY;
      var zSize = this._dimZ;
      var volMap = this._data;
      function _voxelValue(x2, y2, z2) {
        return volMap[z2 * xSize * ySize + y2 * xSize + x2];
      }
      for (var zi = 0; zi < zSize; ++zi) {
        var zm = clamp3(zi - 1, 0, zSize - 1);
        var zp = clamp3(zi + 1, 0, zSize - 1);
        for (var yi = 0; yi < ySize; ++yi) {
          var ym = clamp3(yi - 1, 0, ySize - 1);
          var yp = clamp3(yi + 1, 0, ySize - 1);
          for (var xi = 0; xi < xSize; ++xi) {
            var xm = clamp3(xi - 1, 0, xSize - 1);
            var xp = clamp3(xi + 1, 0, xSize - 1);
            gradient.setValue(xi, yi, zi, (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x, (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y, (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z);
          }
        }
      }
      return gradient;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var data = this._data;
      var min = data[0];
      var max = data[0];
      for (var i2 = 1; i2 < data.length; ++i2) {
        min = Math.min(min, data[i2]);
        max = Math.max(max, data[i2]);
      }
      var d2 = 1 / (max - min);
      if (d2 === 0) {
        return;
      }
      for (var _i = 0; _i < data.length; ++_i) {
        data[_i] = d2 * (data[_i] - min);
      }
    }
  }, {
    key: "getTiledTextureStride",
    value: function getTiledTextureStride() {
      return [this._dimX + 2, this._dimY + 2];
    }
  }, {
    key: "buildTiledTexture",
    value: function buildTiledTexture() {
      var tilesX = Math.ceil(Math.sqrt(this._dimZ * this._dimY / this._dimX));
      var width = tilesX * (this._dimX + 2) - 1;
      width = pow2ceil(width);
      tilesX = Math.floor(width / (this._dimX + 2));
      var tilesY = Math.ceil(this._dimZ / tilesX);
      var height = tilesY * (this._dimY + 2) - 1;
      height = pow2ceil(height);
      var data = new Uint8Array(width * height);
      var src;
      var dst;
      for (var tileRow = 0; tileRow < tilesY; ++tileRow) {
        for (var row = 0; row < this._dimY; ++row) {
          src = tileRow * tilesX * this._planeElements + row * this._rowElements;
          dst = width * (tileRow * (this._dimY + 2) + row);
          for (var t2 = 0; t2 < tilesX; ++t2) {
            for (var x2 = 0; x2 < this._dimX; ++x2) {
              data[dst++] = 255 * this._data[src++];
            }
            data[dst++] = 255 * this._data[src - 1];
            if (t2 < tilesX - 1) {
              src += this._planeElements - this._rowElements;
              data[dst++] = 255 * this._data[src];
            }
          }
        }
      }
      for (var _tileRow = 0; _tileRow < tilesY; ++_tileRow) {
        src = width * (_tileRow * (this._dimY + 2) + this._dimY - 1);
        dst = src + width;
        for (var _x2 = 0; _x2 < width; ++_x2) {
          data[dst++] = data[src++];
        }
        if (_tileRow < tilesY - 1) {
          src = width * (_tileRow + 1) * (this._dimY + 2);
          dst = src - width;
          for (var _x22 = 0; _x22 < width; ++_x22) {
            data[dst++] = data[src++];
          }
        }
      }
      var texture = new DataTexture(data, width, height, LuminanceFormat, UnsignedByteType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter);
      texture.needsUpdate = true;
      return texture;
    }
  }, {
    key: "getData",
    value: function getData() {
      return this._data;
    }
  }, {
    key: "getDirectIdx",
    value: function getDirectIdx(x2, y2, z2) {
      return x2 * this._dimVec + y2 * this._rowElements + z2 * this._planeElements;
    }
  }, {
    key: "getStrideX",
    value: function getStrideX() {
      return this._dimVec;
    }
  }, {
    key: "getStrideY",
    value: function getStrideY() {
      return this._rowElements;
    }
  }, {
    key: "getStrideZ",
    value: function getStrideZ() {
      return this._planeElements;
    }
  }]);
  return Volume2;
}();
Volume$2.prototype.id = "Volume";
var Molecule$8 = function() {
  function Molecule2(complex, name2, index) {
    _classCallCheck(this, Molecule2);
    this.complex = complex;
    this.name = name2 || "";
    this.residues = [];
    this.mask = 1 | 0;
    this.index = index || -1;
  }
  _createClass(Molecule2, [{
    key: "forEachResidue",
    value: function forEachResidue(process2) {
      var residues = this.residues;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        process2(residues[i2]);
      }
    }
  }, {
    key: "collectMask",
    value: function collectMask() {
      var mask = 4294967295;
      var residues = this.residues;
      for (var i2 = 0, n2 = residues.length; i2 < n2; ++i2) {
        mask &= residues[i2]._mask;
      }
      this.mask = mask;
    }
  }]);
  return Molecule2;
}();
var chem = {
  Atom: Atom$2,
  Element: Element$a,
  Bond: Bond$5,
  Residue: Residue$1,
  ResidueType: ResidueType$1,
  Chain: Chain$2,
  Helix: Helix$3,
  Strand: Strand$3,
  Sheet: Sheet$3,
  SGroup: SGroup$1,
  Assembly: Assembly$3,
  Complex: Complex$9,
  Volume: Volume$2,
  VoxelWorld,
  selectors: selectors$5,
  Molecule: Molecule$8
};
function _createSuper$1V(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1V();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1V() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var CSS2DObject = function(_Object3D) {
  _inherits(CSS2DObject2, _Object3D);
  var _super = _createSuper$1V(CSS2DObject2);
  function CSS2DObject2(element) {
    var _this;
    _classCallCheck(this, CSS2DObject2);
    _this = _super.call(this);
    var self2 = _assertThisInitialized(_this);
    _this._element = element;
    _this._element.style.position = "absolute";
    _this.addEventListener("removed", function() {
      if (self2._element.parentNode !== null) {
        self2._element.parentNode.removeChild(self2._element);
      }
    });
    return _this;
  }
  _createClass(CSS2DObject2, [{
    key: "getElement",
    value: function getElement() {
      return this._element;
    }
  }, {
    key: "setTransparency",
    value: function setTransparency(transp) {
      var el = this.getElement();
      if (el === null) {
        return;
      }
      if (transp === 1) {
        el.style.display = "none";
        return;
      }
      el.style.display = "inline";
      var op = 1 - transp;
      var top = op.toString();
      var op100 = op * 100;
      el.style.opacity = top;
      el.style.filter = "alpha(opacity=".concat(op100, ")");
    }
  }, {
    key: "clone",
    value: function clone2() {
      var obj = new CSS2DObject2(this._element);
      obj.copy(this);
      return obj;
    }
  }]);
  return CSS2DObject2;
}(Object3D);
function _createSuper$1U(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1U();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1U() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var RCGroup = function(_Group) {
  _inherits(RCGroup2, _Group);
  var _super = _createSuper$1U(RCGroup2);
  function RCGroup2() {
    _classCallCheck(this, RCGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(RCGroup2, [{
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      if (!this.visible) {
        return;
      }
      var children = this.children;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        children[i2].raycast(raycaster, intersects2);
      }
    }
  }, {
    key: "enableSubset",
    value: function enableSubset(mask, innerOnly) {
      var children = this.children;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].enableSubset) {
          children[i2].enableSubset(mask, innerOnly);
        }
      }
    }
  }, {
    key: "disableSubset",
    value: function disableSubset(mask, innerOnly) {
      var children = this.children;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].disableSubset) {
          children[i2].disableSubset(mask, innerOnly);
        }
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty2() {
      return this.children.length === 0;
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var children = this.children;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].updateToFrame) {
          children[i2].updateToFrame(frameData);
        }
      }
    }
  }, {
    key: "getSubset",
    value: function getSubset2(mask, innerOnly) {
      var totalSubset = [];
      var children = this.children;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].getSubset) {
          Array.prototype.push.apply(totalSubset, children[i2].getSubset(mask, innerOnly));
        }
      }
      return totalSubset;
    }
  }]);
  return RCGroup2;
}(Group);
var vertexScreenQuadShader = "uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec2 uv;\r\nattribute vec3 position;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n";
var fragmentScreenQuadFromTex = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n  vec4 color = texture2D(srcTex, vUv);\r\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\r\n}\r\n";
var fragmentScreenQuadFromTexWithDistortion = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float coef;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  float r2 = dot(uv, uv);\r\n  vec2 tc = uv * (1.0 + coef * r2);\r\n  if (!all(lessThan(abs(tc), vec2(1.0))))\r\n    discard;\r\n  tc = 0.5 * (tc + 1.0);\r\n  gl_FragColor = texture2D(srcTex, tc);\r\n}\r\n";
function _createSuper$1T(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1T();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1T() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var LAYERS = {
  DEFAULT: 0,
  VOLUME: 1,
  TRANSPARENT: 2,
  PREPASS_TRANSPARENT: 3,
  VOLUME_BFPLANE: 4,
  COLOR_FROM_POSITION: 5,
  SHADOWMAP: 6
};
var SELECTION_LAYERS = [
  LAYERS.DEFAULT,
  LAYERS.TRANSPARENT
];
Object3D.prototype.resetTransform = function() {
  this.position.set(0, 0, 0);
  this.quaternion.set(0, 0, 0, 1);
  this.scale.set(1, 1, 1);
};
Object3D.prototype.updateMatrixWorldRecursive = function() {
  if (this.parent != null) {
    this.parent.updateMatrixWorldRecursive();
  }
  this.updateMatrixWorld();
};
Object3D.prototype.addSavingWorldTransform = function() {
  var _worldMatrixInverse = new Matrix4();
  return function(object4) {
    if (object4 instanceof Object3D) {
      _worldMatrixInverse.copy(this.matrixWorld).invert();
      _worldMatrixInverse.multiply(object4.matrixWorld);
      object4.matrix.copy(_worldMatrixInverse);
      object4.matrix.decompose(object4.position, object4.quaternion, object4.scale);
      this.add(object4);
    }
  };
}();
WebGLRenderer.prototype.renderDummyQuad = function() {
  var _material = new MeshBasicMaterial({
    transparent: true,
    opacity: 0,
    depthWrite: false
  });
  var _scene = new Scene();
  var _quad = new Mesh(new PlaneGeometry(0.01, 0.01), _material);
  _scene.add(_quad);
  var _camera2 = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1e4, 1e4);
  _camera2.position.z = 100;
  return function() {
    this.render(_scene, _camera2);
  };
}();
WebGLRenderer.prototype.renderScreenQuad = function() {
  var _scene = new Scene();
  var _quad = new Mesh(new PlaneGeometry(1, 1));
  _scene.add(_quad);
  var _camera2 = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1e4, 1e4);
  _camera2.position.z = 100;
  return function(material2) {
    _quad.material = material2;
    this.render(_scene, _camera2);
  };
}();
Matrix4.prototype.isIdentity = function() {
  var identity3 = new Matrix4();
  return function() {
    return identity3.equals(this);
  };
}();
Matrix4.prototype.applyToPointsArray = function(array4, stride, w2) {
  if (!array4 || !stride || stride < 3) {
    return array4;
  }
  w2 = w2 || 0;
  var e2 = this.elements;
  for (var i2 = 0; i2 < array4.length; i2 += stride) {
    var x2 = array4[i2];
    var y2 = array4[i2 + 1];
    var z2 = array4[i2 + 2];
    var persp = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
    array4[i2] = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w2) * persp;
    array4[i2 + 1] = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w2) * persp;
    array4[i2 + 2] = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w2) * persp;
  }
  return array4;
};
var ScreenQuadMaterial = function(_RawShaderMaterial) {
  _inherits(ScreenQuadMaterial2, _RawShaderMaterial);
  var _super = _createSuper$1T(ScreenQuadMaterial2);
  function ScreenQuadMaterial2(params) {
    _classCallCheck(this, ScreenQuadMaterial2);
    if (params.uniforms === void 0) {
      params.uniforms = {};
    }
    params.uniforms.srcTex = {
      type: "t",
      value: null
    };
    params.vertexShader = vertexScreenQuadShader;
    params.transparent = false;
    params.depthTest = false;
    params.depthWrite = false;
    return _super.call(this, params);
  }
  return _createClass(ScreenQuadMaterial2);
}(RawShaderMaterial);
WebGLRenderer.prototype.renderScreenQuadFromTex = function() {
  var _material = new ScreenQuadMaterial({
    uniforms: {
      opacity: {
        type: "f",
        value: 1
      }
    },
    fragmentShader: fragmentScreenQuadFromTex,
    transparent: true
  });
  return function(srcTex, opacity) {
    _material.uniforms.srcTex.value = srcTex;
    _material.transparent = opacity < 1;
    _material.uniforms.opacity.value = opacity;
    this.renderScreenQuad(_material);
  };
}();
WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion = function() {
  var _material = new ScreenQuadMaterial({
    uniforms: {
      coef: {
        type: "f",
        value: 1
      }
    },
    fragmentShader: fragmentScreenQuadFromTexWithDistortion
  });
  return function(srcTex, coef) {
    _material.uniforms.srcTex.value = srcTex;
    _material.uniforms.coef.value = coef;
    this.renderScreenQuad(_material);
  };
}();
PerspectiveCamera.prototype.setMinimalFov = function(angle) {
  if (this.aspect >= 1) {
    this.fov = angle;
  } else {
    this.fov = MathUtils.radToDeg(2 * Math.atan(Math.tan(MathUtils.degToRad(angle) * 0.5) / this.aspect));
  }
};
StereoCamera.prototype.updateHalfSized = function(camera, angle) {
  var originalAspect = camera.aspect;
  var originalFov = camera.fov;
  camera.aspect = originalAspect / 2;
  camera.setMinimalFov(angle);
  camera.updateProjectionMatrix();
  this.update(camera);
  camera.aspect = originalAspect;
  camera.fov = originalFov;
  camera.updateProjectionMatrix();
};
PerspectiveCamera.prototype.setDistanceToFit = function(radius, angle) {
  this.position.z = radius / Math.sin(0.5 * MathUtils.degToRad(angle));
};
Raycaster.prototype.intersectVisibleObject = function(gfxObj, camera, clipPlane, fogFarPlane) {
  var intersects2 = this.intersectObject(gfxObj, false);
  if (intersects2.length === 0) {
    return null;
  }
  var nearPlane = Math.min(camera.near, clipPlane);
  var i2;
  var p2 = intersects2[0];
  var v2 = new Vector3();
  for (i2 = 0; i2 < intersects2.length; ++i2) {
    p2 = intersects2[i2];
    v2.copy(p2.point);
    v2.applyMatrix4(camera.matrixWorldInverse);
    if (v2.z <= -nearPlane) {
      break;
    }
  }
  if (i2 === intersects2.length) {
    return null;
  }
  var farPlane = Math.min(camera.far, fogFarPlane);
  v2.copy(p2.point);
  v2.applyMatrix4(camera.matrixWorldInverse);
  if (v2.z <= -farPlane) {
    return null;
  }
  return p2;
};
Matrix4.prototype.extractScale = function() {
  var _v = new Vector3();
  return function(scale) {
    if (scale === void 0) {
      logger.debug("extractScale(): new is too expensive operation to do it on-the-fly");
      scale = _v.clone();
    }
    var te = this.elements;
    scale.x = _v.set(te[0], te[1], te[2]).length();
    scale.y = _v.set(te[4], te[5], te[6]).length();
    scale.z = _v.set(te[8], te[9], te[10]).length();
    var det = this.determinant();
    if (det < 0) {
      scale.x = -scale.x;
    }
    return scale;
  };
}();
function _calcCylinderMatrix(posBegin, posEnd, radius) {
  var posCenter = posBegin.clone().lerp(posEnd, 0.5);
  var matScale = new Matrix4();
  matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);
  var matRotHalf = new Matrix4();
  matRotHalf.makeRotationX(Math.PI / 2);
  var matRotLook = new Matrix4();
  var vUp = new Vector3(0, 1, 0);
  matRotLook.lookAt(posCenter, posEnd, vUp);
  matRotLook.multiply(matRotHalf);
  matRotLook.multiply(matScale);
  matRotLook.setPosition(posCenter);
  return matRotLook;
}
function _calcChunkMatrix(eye, target, up, rad) {
  var matScale = new Matrix4();
  matScale.makeScale(rad.x, rad.y, 0);
  var matRotLook = new Matrix4();
  matRotLook.lookAt(eye, target, up);
  matRotLook.multiply(matScale);
  matRotLook.setPosition(eye);
  return matRotLook;
}
function _groupHasGeometryToRender(group) {
  var hasGeoms = false;
  group.traverse(function(node) {
    if (node.hasOwnProperty("geometry") || node instanceof CSS2DObject) {
      hasGeoms = true;
    }
  });
  return hasGeoms;
}
function _buildDistorionMesh(widthSegments, heightSegements, coef) {
  function calcInverseBarrel(r2) {
    var epsilon = 1e-5;
    var prevR2 = 0;
    var curR2 = r2;
    var dr = 1;
    while (Math.abs(curR2 - prevR2) > epsilon) {
      dr = 1 + coef * curR2;
      prevR2 = curR2;
      curR2 = r2 / (dr * dr);
    }
    return 1 / dr;
  }
  var geo = new PlaneGeometry(2, 2, widthSegments, heightSegements);
  var pos = geo.getAttribute("position");
  for (var i2 = 0; i2 < pos.count; ++i2) {
    var x2 = pos.array[3 * i2];
    var y2 = pos.array[3 * i2 + 1];
    var c2 = calcInverseBarrel(x2 * x2 + y2 * y2);
    pos.setXY(i2, c2 * x2, c2 * y2);
  }
  return geo;
}
BufferAttribute.prototype.copyAtList = function(attribute, indexList) {
  console.assert(this.itemSize === attribute.itemSize, "false: BufferAttribute.copyAtList buffers have different item size.");
  var itemSize = this.itemSize;
  for (var i2 = 0, n2 = indexList.length; i2 < n2; ++i2) {
    for (var j2 = 0; j2 < itemSize; ++j2) {
      this.array[i2 * itemSize + j2] = attribute.array[indexList[i2] * itemSize + j2];
    }
  }
  return this;
};
function fillArray(array4, value, startIndex, endIndex) {
  startIndex = typeof startIndex !== "undefined" ? startIndex : 0;
  endIndex = typeof endIndex !== "undefined" ? endIndex : array4.length;
  for (var i2 = startIndex; i2 < endIndex; ++i2) {
    array4[i2] = value;
  }
}
function removeChildren(object4) {
  var children = object4.children;
  for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
    var child = children[i2];
    child.parent = null;
    child.dispatchEvent({
      type: "removed"
    });
  }
  object4.children = [];
}
function clearTree(object4) {
  object4.traverse(function(obj) {
    if (obj instanceof Mesh || obj instanceof LineSegments || obj instanceof Line) {
      obj.geometry.dispose();
    }
  });
  removeChildren(object4);
}
function destroyObject(object4) {
  clearTree(object4);
  if (object4.parent) {
    object4.parent.remove(object4);
  } else {
    object4.dispatchEvent({
      type: "removed"
    });
  }
}
function belongToSelectLayers(object4) {
  for (var i2 = 0; i2 < SELECTION_LAYERS.length; i2++) {
    if ((object4.layers.mask >> SELECTION_LAYERS[i2] & 1) === 1) {
      return true;
    }
  }
  return false;
}
function processObjRenderOrder(root, idMaterial) {
  var renderOrder = +(idMaterial !== "BA");
  root.traverse(function(object4) {
    if (object4.isGroup) {
      object4.renderOrder = renderOrder;
    }
  });
}
function applySelectionMaterial(geo) {
  geo.traverse(function(node) {
    if ("material" in node) {
      node.material = node.material.clone(true);
      node.material.setValues({
        depthFunc: LessEqualDepth,
        overrideColor: true,
        fog: false,
        lights: false,
        shadowmap: false
      });
      node.material.setUberOptions({
        fixedColor: new Color(16776960),
        zOffset: -1e-6
      });
    }
  });
}
function getMiddlePoint(point1, point2, optionalTarget) {
  var result = optionalTarget || new Vector3();
  result.set(0, 0, 0);
  result.addScaledVector(point1, 0.5);
  result.addScaledVector(point2, 0.5);
  return result;
}
var _oldInstancedBufferGeometryCopy = InstancedBufferGeometry.prototype.copy;
InstancedBufferGeometry.prototype.copy = function(source) {
  _oldInstancedBufferGeometryCopy.call(this, source);
  if (this.instanceCount === void 0) {
    this.instanceCount = Infinity;
  }
};
var gfxutils = {
  calcCylinderMatrix: _calcCylinderMatrix,
  calcChunkMatrix: _calcChunkMatrix,
  groupHasGeometryToRender: _groupHasGeometryToRender,
  buildDistorionMesh: _buildDistorionMesh,
  RCGroup,
  fillArray,
  clearTree,
  destroyObject,
  belongToSelectLayers,
  processObjRenderOrder,
  applySelectionMaterial,
  getMiddlePoint,
  LAYERS
};
function _createSuper$1S(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1S();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1S() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _defaultBoundaries = {
  boundingBox: new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),
  boundingSphere: new Sphere(new Vector3(0, 0, 0), 1)
};
var Visual = function(_gfxutils$RCGroup) {
  _inherits(Visual2, _gfxutils$RCGroup);
  var _super = _createSuper$1S(Visual2);
  function Visual2(name2, dataSource) {
    var _this;
    _classCallCheck(this, Visual2);
    _this = _super.call(this, name2, dataSource);
    _this.name = name2;
    _this._dataSource = dataSource;
    return _this;
  }
  _createClass(Visual2, [{
    key: "release",
    value: function release2() {
      if (this.parent) {
        this.parent.remove(this);
      }
    }
  }, {
    key: "getDataSource",
    value: function getDataSource() {
      return this._dataSource;
    }
  }, {
    key: "getBoundaries",
    value: function getBoundaries() {
      return _defaultBoundaries;
    }
  }]);
  return Visual2;
}(gfxutils.RCGroup);
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}
function _ensureArray(x2) {
  if (x2 === null || x2 === void 0 || Array.isArray(x2)) {
    return x2;
  }
  return [x2];
}
var EntityList = function() {
  function EntityList2() {
    var _this = this;
    var entities = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var indices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["id"];
    _classCallCheck(this, EntityList2);
    this._list = [];
    this._dict = {};
    this._indices = _toConsumableArray(indices);
    this._indices.forEach(function(index) {
      _this._dict[index] = {};
    });
    entities.forEach(function(entity) {
      return _this.register(entity);
    });
  }
  _createClass(EntityList2, [{
    key: "register",
    value: function register(entity) {
      var _this2 = this;
      EntityList2.registerInList(this._list, entity);
      this._indices.forEach(function(index) {
        EntityList2.registerInDict(_this2._dict[index], _ensureArray(entity[index]), entity);
      });
    }
  }, {
    key: "unregister",
    value: function unregister(entity) {
      var _this3 = this;
      EntityList2.unregisterFromList(this._list, entity);
      this._indices.forEach(function(index) {
        EntityList2.unregisterFromDict(_this3._dict[index], _ensureArray(entity[index]), entity);
      });
    }
  }, {
    key: "all",
    get: function get3() {
      return _toConsumableArray(this._list);
    }
  }, {
    key: "first",
    get: function get3() {
      return this._list[0];
    }
  }, {
    key: "keys",
    value: function keys2(index) {
      return Object.keys(this._dict[index || this._indices[0]]);
    }
  }, {
    key: "get",
    value: function get3(key, index) {
      var dict = this._dict[index || this._indices[0]];
      if (dict) {
        var values = dict[key && key.toLowerCase()];
        return values && values.length > 0 ? values[0] : void 0;
      }
      return void 0;
    }
  }], [{
    key: "registerInList",
    value: function registerInList(list, value) {
      if (!list.includes(value)) {
        list.push(value);
      }
    }
  }, {
    key: "unregisterFromList",
    value: function unregisterFromList(list, value) {
      var pos = list.indexOf(value);
      if (pos !== -1) {
        list.splice(pos, 1);
      }
    }
  }, {
    key: "registerInDict",
    value: function registerInDict(dict, keys2, value) {
      keys2.forEach(function(key) {
        key = key.toLowerCase();
        var list = dict[key] = dict[key] || [];
        if (!list.includes(value)) {
          list.push(value);
        }
      });
    }
  }, {
    key: "unregisterFromDict",
    value: function unregisterFromDict(dict, keys2, value) {
      keys2.forEach(function(key) {
        key = key.toLowerCase();
        var list = dict[key];
        if (list) {
          var pos = list.indexOf(value);
          if (pos !== -1) {
            list.splice(pos, 1);
          }
          if (list.length === 0) {
            delete dict[key];
          }
        }
      });
    }
  }]);
  return EntityList2;
}();
function makeContextDependent(prototype) {
  Object.defineProperties(prototype, {
    logger: {
      get: function get3() {
        return this.context && this.context.logger ? this.context.logger : logger;
      }
    },
    settings: {
      get: function get3() {
        return this.context && this.context.settings ? this.context.settings : settings$1;
      }
    }
  });
}
function _createSuper$1R(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1R();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1R() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var CollisionSphere = function() {
  function CollisionSphere2(position, radius) {
    _classCallCheck(this, CollisionSphere2);
    this._position = position;
    this._radius = radius;
  }
  _createClass(CollisionSphere2, [{
    key: "raycast",
    value: function raycast(raycaster) {
      var sphere = CollisionSphere2._sphere;
      sphere.set(this._position, this._radius);
      var p2 = new Vector3();
      if (raycaster.ray.intersectSphere(sphere, p2)) {
        return {
          distance: raycaster.ray.origin.distanceTo(p2),
          point: p2
        };
      }
      return null;
    }
  }]);
  return CollisionSphere2;
}();
_defineProperty2(CollisionSphere, "_sphere", new Sphere());
var SphereCollisionGeo = function SphereCollisionGeo2(base) {
  return function(_base) {
    _inherits(_class, _base);
    var _super = _createSuper$1R(_class);
    function _class(count) {
      var _this;
      _classCallCheck(this, _class);
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this._objects = new Array(count);
      _this.boundingSphere = null;
      _this.boundingBox = null;
      return _this;
    }
    _createClass(_class, [{
      key: "setSphere",
      value: function setSphere(idx, position, radius) {
        this._objects[idx] = new CollisionSphere(position, radius);
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects2) {
        for (var i2 = 0, n2 = this._objects.length; i2 < n2; ++i2) {
          var inters = this._objects[i2].raycast(raycaster);
          if (inters) {
            inters.chunkIdx = i2;
            intersects2.push(inters);
          }
        }
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var objects = this._objects;
        var boundingBox = this.boundingBox;
        if (boundingBox === null) {
          this.boundingBox = boundingBox = new Box3();
        }
        boundingBox.makeEmpty();
        for (var i2 = 0, n2 = objects.length; i2 < n2; ++i2) {
          boundingBox.expandByPoint(objects[i2]._position);
        }
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        this.computeBoundingBox();
        var objects = this._objects;
        var boundingBox = this.boundingBox;
        var radiusSquared = 0;
        var center = new Vector3();
        boundingBox.getCenter(center);
        for (var i2 = 0, n2 = objects.length; i2 < n2; ++i2) {
          var pos = objects[i2]._position;
          var lengthSquared = center.distanceToSquared(pos);
          if (radiusSquared < lengthSquared) {
            radiusSquared = lengthSquared;
          }
        }
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        this.boundingSphere.set(center, Math.sqrt(radiusSquared));
      }
    }]);
    return _class;
  }(base);
};
function _createSuper$1Q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1Q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1Q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var tmpColor$4 = new Color();
var OFFSET_SIZE$1 = 4;
var COLOR_SIZE$3 = 3;
var copySubArrays$1 = utils.copySubArrays;
function setArrayXYZ$2(arr, idx, x2, y2, z2) {
  arr[idx] = x2;
  arr[idx + 1] = y2;
  arr[idx + 2] = z2;
}
function setArrayXYZW$2(arr, idx, x2, y2, z2, w2) {
  arr[idx] = x2;
  arr[idx + 1] = y2;
  arr[idx + 2] = z2;
  arr[idx + 3] = w2;
}
var InstancedSpheresGeometry = function(_SphereCollisionGeo) {
  _inherits(InstancedSpheresGeometry2, _SphereCollisionGeo);
  var _super = _createSuper$1Q(InstancedSpheresGeometry2);
  function InstancedSpheresGeometry2(spheresCount, sphereComplexity, useZSprites) {
    var _this;
    _classCallCheck(this, InstancedSpheresGeometry2);
    _this = _super.call(this, spheresCount);
    _this._sphGeometry = useZSprites ? new PlaneGeometry(2, 2, 1, 1) : new SphereGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
    _this._init(spheresCount, _this._sphGeometry);
    return _this;
  }
  _createClass(InstancedSpheresGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, itemPos, itemRad) {
      setArrayXYZW$2(this._offsets, itemIdx * OFFSET_SIZE$1, itemPos.x, itemPos.y, itemPos.z, itemRad);
      this.setSphere(itemIdx, itemPos, itemRad);
    }
  }, {
    key: "setColor",
    value: function setColor(itemIdx, colorVal) {
      tmpColor$4.set(colorVal);
      setArrayXYZ$2(this._colors, itemIdx * COLOR_SIZE$3, tmpColor$4.r, tmpColor$4.g, tmpColor$4.b);
    }
  }, {
    key: "startUpdate",
    value: function startUpdate() {
      return true;
    }
  }, {
    key: "finishUpdate",
    value: function finishUpdate() {
      this.getAttribute("offset").needsUpdate = true;
      this.getAttribute("color").needsUpdate = true;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.finishUpdate();
      this.computeBoundingSphere();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(chunkIndices, value) {
      var alphaArr = this._alpha;
      for (var i2 = 0, n2 = chunkIndices.length; i2 < n2; ++i2) {
        alphaArr[chunkIndices[i2]] = value;
      }
      this.getAttribute("alphaColor").needsUpdate = true;
    }
  }, {
    key: "getSubset",
    value: function getSubset2(chunkIndices) {
      var instanceCount = chunkIndices.length;
      var geom = new InstancedBufferGeometry();
      this._init.call(geom, instanceCount, this._sphGeometry);
      copySubArrays$1(this._offsets, geom._offsets, chunkIndices, OFFSET_SIZE$1);
      copySubArrays$1(this._colors, geom._colors, chunkIndices, COLOR_SIZE$3);
      geom.boundingSphere = this.boundingSphere;
      geom.boundingBox = this.boundingBox;
      return [geom];
    }
  }, {
    key: "_init",
    value: function _init(spheresCount, sphereGeo) {
      this.copy(sphereGeo);
      this._offsets = utils.allocateTyped(Float32Array, spheresCount * OFFSET_SIZE$1);
      this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE$3);
      var alpha = this._alpha = utils.allocateTyped(Float32Array, spheresCount);
      (0, import_lodash.fill)(alpha, 1);
      this.setAttribute("offset", new InstancedBufferAttribute(this._offsets, OFFSET_SIZE$1, false, 1));
      this.setAttribute("color", new InstancedBufferAttribute(this._colors, COLOR_SIZE$3, false, 1));
      this.setAttribute("alphaColor", new InstancedBufferAttribute(alpha, 1, false, 1));
    }
  }]);
  return InstancedSpheresGeometry2;
}(SphereCollisionGeo(InstancedBufferGeometry));
function _createSuper$1P(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1P();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1P() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var MAX_IDC_16BIT$1 = 65535;
var VEC_SIZE$4 = 3;
var tmpColor$3 = new Color();
var ChunkedObjectsGeometry = function(_BufferGeometry) {
  _inherits(ChunkedObjectsGeometry2, _BufferGeometry);
  var _super = _createSuper$1P(ChunkedObjectsGeometry2);
  function ChunkedObjectsGeometry2(chunkGeo, chunksCount) {
    var _this;
    _classCallCheck(this, ChunkedObjectsGeometry2);
    _this = _super.call(this);
    if (_this.constructor === ChunkedObjectsGeometry2) {
      throw new Error("Can not instantiate abstract class!");
    }
    _this._chunkGeo = chunkGeo;
    _this._init(chunkGeo, chunksCount);
    return _this;
  }
  _createClass(ChunkedObjectsGeometry2, [{
    key: "startUpdate",
    value: function startUpdate() {
      return true;
    }
  }, {
    key: "finishUpdate",
    value: function finishUpdate() {
      this.getAttribute("position").needsUpdate = true;
      this.getAttribute("normal").needsUpdate = true;
      this.getAttribute("color").needsUpdate = true;
    }
  }, {
    key: "setColor",
    value: function setColor(chunkIdx, colorVal) {
      tmpColor$3.set(colorVal);
      var colors = this._colors;
      var chunkSize = this._chunkSize;
      for (var i2 = chunkIdx * chunkSize, end = i2 + chunkSize; i2 < end; ++i2) {
        var idx = i2 * VEC_SIZE$4;
        colors[idx] = tmpColor$3.r;
        colors[idx + 1] = tmpColor$3.g;
        colors[idx + 2] = tmpColor$3.b;
      }
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.finishUpdate();
      this.computeBoundingSphere();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(chunkIndices, value) {
      var alphaArr = this._alpha;
      var chunkSize = this._chunkSize;
      for (var i2 = 0, n2 = chunkIndices.length; i2 < n2; ++i2) {
        var left = chunkIndices[i2] * chunkSize;
        (0, import_lodash.fill)(alphaArr, value, left, left + chunkSize);
      }
      this.getAttribute("alphaColor").needsUpdate = true;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var inters = [];
      var mesh = new Mesh();
      mesh.geometry = this;
      mesh.raycast(raycaster, inters);
      var facesPerChunk = this._chunkGeo.index.count / 3;
      for (var i2 = 0, n2 = inters.length; i2 < n2; ++i2) {
        if (!inters[i2].hasOwnProperty("faceIndex")) {
          continue;
        }
        inters[i2].chunkIdx = Math.floor(inters[i2].faceIndex / facesPerChunk);
        intersects2.push(inters[i2]);
      }
    }
  }, {
    key: "getSubset",
    value: function getSubset2(chunkIndices) {
      var instanceCount = chunkIndices.length;
      var geom = new BufferGeometry();
      this._init.call(geom, this._chunkGeo, instanceCount);
      var srcPos = this._positions;
      var srcNorm = this._normals;
      var srcColor = this._colors;
      var dstPos = geom._positions;
      var dstNorm = geom._normals;
      var dstColor = geom._colors;
      var chunkSize = this._chunkSize * VEC_SIZE$4;
      for (var i2 = 0, n2 = chunkIndices.length; i2 < n2; ++i2) {
        var dstPtOffset = i2 * chunkSize;
        var ptIdxBegin = chunkIndices[i2] * chunkSize;
        var ptIdxEnd = ptIdxBegin + chunkSize;
        dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
      }
      geom.boundingSphere = this.boundingSphere;
      geom.boundingBox = this.boundingBox;
      return [geom];
    }
  }, {
    key: "_init",
    value: function _init(chunkGeo, chunksCount) {
      var chunkSize = this._chunkSize = chunkGeo.attributes.position.count;
      var chunkIndex = chunkGeo.index.array;
      var chunkIndexSize = chunkIndex.length;
      var pointsCount = this._chunkSize * chunksCount;
      var use32bitIndex = pointsCount > MAX_IDC_16BIT$1;
      var indexSize = chunkIndexSize * chunksCount;
      var index = this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, indexSize);
      this._positions = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE$4);
      this._normals = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE$4);
      this._colors = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE$4);
      var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
      (0, import_lodash.fill)(alpha, 1);
      for (var i2 = 0; i2 < chunksCount; ++i2) {
        var offset = i2 * chunkIndexSize;
        var posOffset = i2 * chunkSize;
        index.set(chunkIndex, offset);
        for (var j2 = 0; j2 < chunkIndexSize; ++j2) {
          index[offset + j2] += posOffset;
        }
      }
      this.setIndex(new BufferAttribute(this._index, 1));
      this.setAttribute("position", new BufferAttribute(this._positions, VEC_SIZE$4));
      this.setAttribute("normal", new BufferAttribute(this._normals, VEC_SIZE$4));
      this.setAttribute("color", new BufferAttribute(this._colors, VEC_SIZE$4));
      this.setAttribute("alphaColor", new BufferAttribute(alpha, 1));
    }
  }]);
  return ChunkedObjectsGeometry2;
}(BufferGeometry);
function _createSuper$1O(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1O();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1O() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VEC_SIZE$3 = 3;
var SimpleSpheresGeometry = function(_SphereCollisionGeo) {
  _inherits(SimpleSpheresGeometry2, _SphereCollisionGeo);
  var _super = _createSuper$1O(SimpleSpheresGeometry2);
  function SimpleSpheresGeometry2(spheresCount, sphereComplexity) {
    var _this;
    _classCallCheck(this, SimpleSpheresGeometry2);
    var sphGeometry = new SphereGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
    _this = _super.call(this, spheresCount, sphGeometry, spheresCount);
    var normals = _this._normals;
    var geoNormals = sphGeometry.attributes.normal.array;
    var chunkSize = _this._chunkSize;
    _this._chunkPos = _this._chunkGeo.attributes.position.array;
    _this._tmpPositions = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$3);
    for (var i2 = 0; i2 < spheresCount; ++i2) {
      normals.set(geoNormals, chunkSize * VEC_SIZE$3 * i2);
    }
    return _this;
  }
  _createClass(SimpleSpheresGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, itemPos, itemRad) {
      var tmpPos = this._tmpPositions;
      var chunkSize = this._chunkSize;
      var geoPos = this._chunkPos;
      for (var i2 = 0; i2 < chunkSize; ++i2) {
        var idx = i2 * 3;
        tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad;
        tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad;
        tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad;
      }
      this._positions.set(tmpPos, chunkSize * itemIdx * VEC_SIZE$3);
      this.setSphere(itemIdx, itemPos, itemRad);
    }
  }]);
  return SimpleSpheresGeometry2;
}(SphereCollisionGeo(ChunkedObjectsGeometry));
function _createSuper$1N(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1N();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1N() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VEC_SIZE$2 = 3;
var centerPos = new Vector3();
var tmpVector$2 = new Vector3();
var normMtx$1 = new Matrix3();
var Simple2CCylindersGeometry = function(_ChunkedObjectsGeomet) {
  _inherits(Simple2CCylindersGeometry2, _ChunkedObjectsGeomet);
  var _super = _createSuper$1N(Simple2CCylindersGeometry2);
  function Simple2CCylindersGeometry2(instanceCount, polyComplexity) {
    var _this;
    _classCallCheck(this, Simple2CCylindersGeometry2);
    var cylGeometry = new CylinderGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, true);
    _this = _super.call(this, cylGeometry, 2 * instanceCount);
    var chunkSize = _this._chunkSize;
    _this._chunkPos = _this._chunkGeo.attributes.position.array;
    _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
    _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$2);
    return _this;
  }
  _createClass(Simple2CCylindersGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, botPos, topPos, itemRad) {
      var chunkSize = this._chunkSize;
      var firstOffset = chunkSize * 2 * itemIdx * VEC_SIZE$2;
      var secondOffset = firstOffset + chunkSize * VEC_SIZE$2;
      var tmpArray = this._tmpVector;
      var geoPos = this._chunkPos;
      var geoNorm = this._chunkNorms;
      centerPos.lerpVectors(botPos, topPos, 0.5);
      var mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
      normMtx$1.getNormalMatrix(mtx1);
      var idx;
      for (var i2 = 0; i2 < chunkSize; ++i2) {
        idx = i2 * VEC_SIZE$2;
        tmpVector$2.fromArray(geoPos, idx);
        tmpVector$2.applyMatrix4(mtx1);
        tmpVector$2.toArray(tmpArray, idx);
      }
      this._positions.set(tmpArray, firstOffset);
      centerPos.sub(botPos);
      for (var _i = 0; _i < chunkSize; ++_i) {
        idx = _i * VEC_SIZE$2;
        tmpArray[idx] += centerPos.x;
        tmpArray[idx + 1] += centerPos.y;
        tmpArray[idx + 2] += centerPos.z;
      }
      this._positions.set(tmpArray, secondOffset);
      for (var _i2 = 0; _i2 < chunkSize; ++_i2) {
        idx = _i2 * VEC_SIZE$2;
        tmpVector$2.fromArray(geoNorm, idx);
        tmpVector$2.applyMatrix3(normMtx$1);
        tmpVector$2.toArray(tmpArray, idx);
      }
      this._normals.set(tmpArray, firstOffset);
      this._normals.set(tmpArray, secondOffset);
    }
  }, {
    key: "setColor",
    value: function setColor(itemIdx, colorVal1, colorVal2) {
      var first = 2 * itemIdx;
      _get(_getPrototypeOf(Simple2CCylindersGeometry2.prototype), "setColor", this).call(this, first, colorVal1);
      var second = first + 1;
      _get(_getPrototypeOf(Simple2CCylindersGeometry2.prototype), "setColor", this).call(this, second, colorVal2);
    }
  }]);
  return Simple2CCylindersGeometry2;
}(ChunkedObjectsGeometry);
function _createSuper$1M(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1M();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1M() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var MAX_POINTS_COUNT_16BIT = 65536;
var PTS_PER_TRIANGLE = 3;
var CylinderBufferGeometry = function(_BufferGeometry) {
  _inherits(CylinderBufferGeometry2, _BufferGeometry);
  var _super = _createSuper$1M(CylinderBufferGeometry2);
  function CylinderBufferGeometry2(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
    var _this;
    _classCallCheck(this, CylinderBufferGeometry2);
    _this = _super.call(this);
    var thetaStart = 0;
    var thetaLength = 2 * Math.PI;
    _this.type = "CylinderBufferGeometry";
    _this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded
    };
    var hasTop = openEnded === false && radiusTop > 0;
    var hasBottom = openEnded === false && radiusBottom > 0;
    var vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
    var facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;
    var heightHalf = height / 2;
    var positions = new BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    var normals = new BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    var indices = new Uint16BufferAttribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
    var uvs = new BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
    console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, "false: Cylinder Geometry has too many vertices (65536 max).");
    var currVtxIdx = 0;
    var currFaceIdx = 0;
    var tanTheta = -(radiusBottom - radiusTop) / height;
    for (var y2 = 0; y2 <= heightSegments; y2++) {
      if (y2 !== heightSegments) {
        for (var i2 = 0; i2 < radialSegments; i2++) {
          var v1 = currVtxIdx + i2;
          var v2 = currVtxIdx + radialSegments + i2;
          var v3 = currVtxIdx + radialSegments + (i2 + 1) % radialSegments;
          var v4 = currVtxIdx + (i2 + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2);
          currFaceIdx++;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3);
          currFaceIdx++;
        }
      }
      var v5 = y2 / heightSegments;
      var radius = v5 * (radiusBottom - radiusTop) + radiusTop;
      for (var x2 = 0; x2 < radialSegments; x2++) {
        var u2 = x2 / radialSegments;
        var vx = radius * Math.sin(u2 * thetaLength + thetaStart);
        var vy = v5 * height - heightHalf;
        var vz = radius * Math.cos(u2 * thetaLength + thetaStart);
        var normal = new Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();
        positions.setXYZ(currVtxIdx, vx, vy, vz);
        normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
        uvs.setXY(currVtxIdx, u2, v5);
        ++currVtxIdx;
      }
    }
    if (hasTop) {
      var startTIdx = currVtxIdx;
      var lastIdx = currVtxIdx + radialSegments;
      for (var fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
        var currSrcIdx = currVtxIdx - radialSegments;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
        normals.setXYZ(currVtxIdx, 0, 1, 0);
        uvs.setXY(currVtxIdx, 1, 1);
        var nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, 1, 0);
      uvs.setXY(currVtxIdx, 1, 1);
      ++currVtxIdx;
    }
    if (hasBottom) {
      var startBIdx = currVtxIdx;
      var lastBIdx = currVtxIdx + radialSegments;
      for (var fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
        var currSrcBIdx = fBIdx;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
        normals.setXYZ(currVtxIdx, 0, -1, 0);
        uvs.setXY(currVtxIdx, 0, 0);
        var nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, -1, 0);
      uvs.setXY(currVtxIdx, 0, 0);
    }
    _this.setIndex(indices);
    _this.setAttribute("position", positions);
    _this.setAttribute("normal", normals);
    _this.setAttribute("uv", uvs);
    return _this;
  }
  _createClass(CylinderBufferGeometry2, [{
    key: "clone",
    value: function clone2() {
      var parameters = this.parameters;
      return new CylinderBufferGeometry2(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
    }
  }]);
  return CylinderBufferGeometry2;
}(BufferGeometry);
function _createSuper$1L(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1L();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1L() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var tmpColor$2 = new Color();
var invMatrix = new Matrix4();
var OFFSET_SIZE = 4;
var COLOR_SIZE$2 = 3;
var copySubArrays = utils.copySubArrays;
function setArrayXYZ$1(arr, idx, x2, y2, z2) {
  arr[idx] = x2;
  arr[idx + 1] = y2;
  arr[idx + 2] = z2;
}
function setArrayXYZW$1(arr, idx, x2, y2, z2, w2) {
  arr[idx] = x2;
  arr[idx + 1] = y2;
  arr[idx + 2] = z2;
  arr[idx + 3] = w2;
}
function sortNumber(a2, b2) {
  return a2 - b2;
}
function _prepareCylinderInfo(chunkIndices) {
  chunkIndices.sort(sortNumber);
  var chunksIdx = [];
  var cylinderInfo = [];
  for (var i2 = 0, n2 = chunkIndices.length; i2 < n2; ++i2) {
    var val = chunkIndices[i2];
    var even = (val | 0) % 2 === 0;
    var newPar = {
      first: false,
      second: false
    };
    if (even) {
      newPar.first = true;
      newPar.second = i2 + 1 < n2 && chunkIndices[i2 + 1] === chunkIndices[i2] + 1;
      if (newPar.second) {
        ++i2;
      }
    } else {
      newPar.second = true;
    }
    chunksIdx.push(Math.floor(val / 2));
    cylinderInfo.push(newPar);
  }
  return {
    indices: chunksIdx,
    cylinderInfo
  };
}
function _assignOpacity(cylinderInfo, color1, color2) {
  for (var i2 = 0, n2 = cylinderInfo.length; i2 < n2; ++i2) {
    var info = cylinderInfo[i2];
    if (!info.first) {
      color1[COLOR_SIZE$2 * i2] = -0.5;
    }
    if (!info.second) {
      color2[COLOR_SIZE$2 * i2] = -0.5;
    }
  }
}
var Instanced2CCylindersGeometry = function(_InstancedBufferGeome) {
  _inherits(Instanced2CCylindersGeometry2, _InstancedBufferGeome);
  var _super = _createSuper$1L(Instanced2CCylindersGeometry2);
  function Instanced2CCylindersGeometry2(instanceCount, polyComplexity, useZSprites, openEnded) {
    var _this;
    _classCallCheck(this, Instanced2CCylindersGeometry2);
    _this = _super.call(this);
    _this._useZSprites = useZSprites;
    _this._cylGeometry = useZSprites ? new PlaneGeometry(2, 2, 1, 1) : new CylinderBufferGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, openEnded);
    _this._init(instanceCount, _this._cylGeometry, _this._useZSprites);
    _this._collisionGeo = new Simple2CCylindersGeometry(instanceCount, 3);
    return _this;
  }
  _createClass(Instanced2CCylindersGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, botPos, topPos, itemRad) {
      var matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
      var me = matrix.elements;
      var mtxOffset = itemIdx * OFFSET_SIZE;
      this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad);
      setArrayXYZW$1(this._matVector1, mtxOffset, me[0], me[4], me[8], me[12]);
      setArrayXYZW$1(this._matVector2, mtxOffset, me[1], me[5], me[9], me[13]);
      setArrayXYZW$1(this._matVector3, mtxOffset, me[2], me[6], me[10], me[14]);
      if (this._useZSprites) {
        invMatrix.copy(matrix).invert();
        me = invMatrix.elements;
        setArrayXYZW$1(this._invmatVector1, mtxOffset, me[0], me[4], me[8], me[12]);
        setArrayXYZW$1(this._invmatVector2, mtxOffset, me[1], me[5], me[9], me[13]);
        setArrayXYZW$1(this._invmatVector3, mtxOffset, me[2], me[6], me[10], me[14]);
      }
    }
  }, {
    key: "setColor",
    value: function setColor(itemIdx, colorVal1, colorVal2) {
      var colorIdx = itemIdx * COLOR_SIZE$2;
      tmpColor$2.set(colorVal1);
      setArrayXYZ$1(this._color1, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
      tmpColor$2.set(colorVal2);
      setArrayXYZ$1(this._color2, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      this._collisionGeo.computeBoundingSphere();
      this.boundingSphere = this._collisionGeo.boundingSphere;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      this._collisionGeo.computeBoundingBox();
      this.boundingBox = this._collisionGeo.boundingBox;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      this._collisionGeo.raycast(raycaster, intersects2);
    }
  }, {
    key: "startUpdate",
    value: function startUpdate() {
      return true;
    }
  }, {
    key: "finishUpdate",
    value: function finishUpdate() {
      this.getAttribute("matVector1").needsUpdate = true;
      this.getAttribute("matVector2").needsUpdate = true;
      this.getAttribute("matVector3").needsUpdate = true;
      this.getAttribute("color").needsUpdate = true;
      this.getAttribute("color2").needsUpdate = true;
      this.getAttribute("alphaColor").needsUpdate = true;
      if (this._useZSprites) {
        this.getAttribute("invmatVector1").needsUpdate = true;
        this.getAttribute("invmatVector2").needsUpdate = true;
        this.getAttribute("invmatVector3").needsUpdate = true;
      }
      this._collisionGeo.finishUpdate();
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.finishUpdate();
      this.computeBoundingSphere();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(chunkIndices, value) {
      var alphaArr = this._alpha;
      for (var i2 = 0, n2 = chunkIndices.length; i2 < n2; ++i2) {
        alphaArr[Math.floor(chunkIndices[i2] / 2)] = value;
      }
      this.getAttribute("alphaColor").needsUpdate = true;
    }
  }, {
    key: "getSubset",
    value: function getSubset2(chunkIndices) {
      var info = _prepareCylinderInfo(chunkIndices);
      var cylinderIndices = info.indices;
      var instanceCount = cylinderIndices.length;
      var geom = new InstancedBufferGeometry();
      this._init.call(geom, instanceCount, this._cylGeometry, this._useZSprites);
      copySubArrays(this._matVector1, geom._matVector1, cylinderIndices, OFFSET_SIZE);
      copySubArrays(this._matVector2, geom._matVector2, cylinderIndices, OFFSET_SIZE);
      copySubArrays(this._matVector3, geom._matVector3, cylinderIndices, OFFSET_SIZE);
      if (this._useZSprites) {
        copySubArrays(this._invmatVector1, geom._invmatVector1, cylinderIndices, OFFSET_SIZE);
        copySubArrays(this._invmatVector2, geom._invmatVector2, cylinderIndices, OFFSET_SIZE);
        copySubArrays(this._invmatVector3, geom._invmatVector3, cylinderIndices, OFFSET_SIZE);
      }
      copySubArrays(this._color1, geom._color1, cylinderIndices, COLOR_SIZE$2);
      copySubArrays(this._color2, geom._color2, cylinderIndices, COLOR_SIZE$2);
      _assignOpacity(info.cylinderInfo, geom._color1, geom._color2);
      geom.boundingSphere = this.boundingSphere;
      geom.boundingBox = this.boundingBox;
      return [geom];
    }
  }, {
    key: "getGeoParams",
    value: function getGeoParams() {
      return this._cylGeometry.parameters;
    }
  }, {
    key: "_init",
    value: function _init(instanceCount, cylinderGeo, useZSprites) {
      this.copy(cylinderGeo);
      this._matVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
      this._matVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
      this._matVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
      this._color1 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$2);
      this._color2 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$2);
      var alpha = this._alpha = utils.allocateTyped(Float32Array, instanceCount);
      (0, import_lodash.fill)(alpha, 1);
      this.setAttribute("matVector1", new InstancedBufferAttribute(this._matVector1, OFFSET_SIZE, false, 1));
      this.setAttribute("matVector2", new InstancedBufferAttribute(this._matVector2, OFFSET_SIZE, false, 1));
      this.setAttribute("matVector3", new InstancedBufferAttribute(this._matVector3, OFFSET_SIZE, false, 1));
      this.setAttribute("color", new InstancedBufferAttribute(this._color1, COLOR_SIZE$2, false, 1));
      this.setAttribute("color2", new InstancedBufferAttribute(this._color2, COLOR_SIZE$2, false, 1));
      this.setAttribute("alphaColor", new InstancedBufferAttribute(this._alpha, 1, false, 1));
      if (useZSprites) {
        this._invmatVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
        this._invmatVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
        this._invmatVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
        this.setAttribute("invmatVector1", new InstancedBufferAttribute(this._invmatVector1, OFFSET_SIZE, false, 1));
        this.setAttribute("invmatVector2", new InstancedBufferAttribute(this._invmatVector2, OFFSET_SIZE, false, 1));
        this.setAttribute("invmatVector3", new InstancedBufferAttribute(this._invmatVector3, OFFSET_SIZE, false, 1));
      }
    }
  }]);
  return Instanced2CCylindersGeometry2;
}(InstancedBufferGeometry);
function _createSuper$1K(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1K();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1K() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VEC_SIZE$1 = 3;
var TRI_SIZE = 3;
var tmpPrev = new Vector3();
var tmpNext = new Vector3();
var tmpRes = new Vector3();
var simpleNormal = new Vector3(1, 0, 0);
var normalOnCut = new Vector3();
var nearRingPt = new Vector3();
function _createExtrudedChunkGeometry(shape, ringsCount) {
  var geo = new BufferGeometry();
  var ptsCount = shape.length;
  var totalPts = ptsCount * ringsCount;
  var type = totalPts <= 65536 ? Uint16Array : Uint32Array;
  var facesPerChunk = (ringsCount - 1) * ptsCount * 2;
  var indices = new BufferAttribute(utils.allocateTyped(type, facesPerChunk * TRI_SIZE), 1);
  var currVtxIdx = 0;
  var currFaceIdx = 0;
  for (var y2 = 0; y2 < ringsCount; y2++) {
    if (y2 !== ringsCount - 1) {
      for (var i2 = 0; i2 < ptsCount; i2++) {
        var v1 = currVtxIdx + i2;
        var v2 = currVtxIdx + ptsCount + i2;
        var v3 = currVtxIdx + ptsCount + (i2 + 1) % ptsCount;
        var v4 = currVtxIdx + (i2 + 1) % ptsCount;
        indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2);
        currFaceIdx++;
        indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3);
        currFaceIdx++;
      }
    }
    currVtxIdx += ptsCount;
  }
  geo.setIndex(indices);
  var pos = utils.allocateTyped(Float32Array, totalPts * VEC_SIZE$1);
  geo.setAttribute("position", new BufferAttribute(pos, VEC_SIZE$1));
  geo._positions = shape;
  return geo;
}
var ExtrudedObjectsGeometry = function(_ChunkedObjectsGeomet) {
  _inherits(ExtrudedObjectsGeometry2, _ChunkedObjectsGeomet);
  var _super = _createSuper$1K(ExtrudedObjectsGeometry2);
  function ExtrudedObjectsGeometry2(shape, ringsCount, chunksCount) {
    var _this;
    _classCallCheck(this, ExtrudedObjectsGeometry2);
    var chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount);
    _this = _super.call(this, chunkGeo, chunksCount);
    _this._ringsCount = ringsCount;
    var tmpShape = _this._tmpShape = [];
    for (var i2 = 0; i2 < shape.length; ++i2) {
      tmpShape[i2] = new Vector3();
    }
    return _this;
  }
  _createClass(ExtrudedObjectsGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, matrices) {
      var hasSlope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var hasCut = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var ptsCount = this._chunkGeo._positions.length;
      var ringsCount = this._ringsCount;
      var chunkStartIdx = ptsCount * this._ringsCount * itemIdx * VEC_SIZE$1;
      this._setPoints(matrices, ptsCount, ringsCount, chunkStartIdx);
      if (hasSlope) {
        this._setSlopeNormals(ptsCount, ringsCount, chunkStartIdx);
      } else {
        this._setBaseNormals(ptsCount, ringsCount, chunkStartIdx);
      }
      if (hasCut) {
        this._addCut(ptsCount, ringsCount, chunkStartIdx);
      }
    }
  }, {
    key: "_setPoints",
    value: function _setPoints(matrices, ptsCount, ringsCount, chunkStartIdx) {
      var tmpShape = this._tmpShape;
      var positions = this._positions;
      var shape = this._chunkGeo._positions;
      for (var i2 = 0, vtxIdx = chunkStartIdx; i2 < ringsCount; ++i2) {
        var mtx = matrices[i2];
        for (var j2 = 0; j2 < ptsCount; ++j2, vtxIdx += VEC_SIZE$1) {
          tmpShape[j2].copy(shape[j2]).applyMatrix4(mtx).toArray(positions, vtxIdx);
        }
      }
    }
  }, {
    key: "_setBaseNormals",
    value: function _setBaseNormals(ptsCount, ringsCount, chunkStartIdx) {
      var nPtsInRing = ptsCount * VEC_SIZE$1;
      for (var i2 = 0, vtxIdx = chunkStartIdx; i2 < ringsCount; ++i2, vtxIdx += nPtsInRing) {
        this._countNormalsInRing(ptsCount, vtxIdx, false);
      }
    }
  }, {
    key: "_setSlopeNormals",
    value: function _setSlopeNormals(ptsCount, ringsCount, chunkStartIdx) {
      var normals = this._normals;
      var nPtsInRing = ptsCount * VEC_SIZE$1;
      var vtxIdx = chunkStartIdx;
      for (var j2 = 0; j2 < ptsCount; ++j2, vtxIdx += VEC_SIZE$1) {
        simpleNormal.toArray(normals, vtxIdx);
      }
      if (vtxIdx - 2 * nPtsInRing > 0) {
        for (var _j = 0; _j < ptsCount; ++_j, vtxIdx += VEC_SIZE$1) {
          tmpRes.fromArray(normals, vtxIdx - 2 * nPtsInRing).toArray(normals, vtxIdx);
        }
      } else {
        this._countNormalsInRing(ptsCount, vtxIdx, true, +nPtsInRing);
        vtxIdx += nPtsInRing;
      }
      for (var i2 = 2; i2 < ringsCount; ++i2, vtxIdx += nPtsInRing) {
        this._countNormalsInRing(ptsCount, vtxIdx, true, -nPtsInRing);
      }
    }
  }, {
    key: "_countNormalsInRing",
    value: function _countNormalsInRing(ptsCount, vtxIdx, isSlope, shiftToExtraPt) {
      var tmpShape = this._tmpShape;
      var normals = this._normals;
      tmpShape[0].fromArray(this._positions, vtxIdx);
      tmpShape[ptsCount - 1].fromArray(this._positions, vtxIdx + (ptsCount - 1) * VEC_SIZE$1);
      for (var j2 = 0; j2 < ptsCount; ++j2, vtxIdx += VEC_SIZE$1) {
        if (j2 < ptsCount - 1) {
          tmpShape[j2 + 1].fromArray(this._positions, vtxIdx + VEC_SIZE$1);
        }
        if (isSlope) {
          nearRingPt.fromArray(this._positions, vtxIdx + shiftToExtraPt);
          tmpPrev.subVectors(tmpShape[(j2 + ptsCount - 1) % ptsCount], tmpShape[(j2 + 1) % ptsCount]).normalize();
          tmpNext.subVectors(tmpShape[j2], nearRingPt).normalize();
          tmpRes.crossVectors(tmpNext, tmpPrev).normalize().toArray(normals, vtxIdx);
        } else {
          tmpPrev.subVectors(tmpShape[j2], tmpShape[(j2 + ptsCount - 1) % ptsCount]).normalize();
          tmpNext.subVectors(tmpShape[j2], tmpShape[(j2 + 1) % ptsCount]).normalize();
          tmpRes.addVectors(tmpPrev, tmpNext).normalize().toArray(normals, vtxIdx);
        }
      }
    }
  }, {
    key: "_addCut",
    value: function _addCut(ptsCount, ringsCount, chunkStartIdx) {
      if (ptsCount < 3 || ringsCount < 2) {
        return;
      }
      var positions = this._positions;
      var normals = this._normals;
      var tmpShape = this._tmpShape;
      var nPtsInRing = ptsCount * VEC_SIZE$1;
      tmpShape[0].fromArray(positions, chunkStartIdx);
      tmpShape[1].fromArray(positions, chunkStartIdx + VEC_SIZE$1);
      tmpShape[2].fromArray(positions, chunkStartIdx + 2 * VEC_SIZE$1);
      tmpPrev.subVectors(tmpShape[1], tmpShape[0]).normalize();
      tmpNext.subVectors(tmpShape[1], tmpShape[2]).normalize();
      normalOnCut.crossVectors(tmpPrev, tmpNext).normalize();
      var vtxIdx = chunkStartIdx;
      for (var j2 = 0; j2 < ptsCount * 2; ++j2, vtxIdx += VEC_SIZE$1) {
        normalOnCut.toArray(normals, vtxIdx);
      }
      if (ringsCount > 2) {
        for (var _j2 = 0; _j2 < ptsCount; ++_j2, vtxIdx += VEC_SIZE$1) {
          tmpRes.fromArray(positions, vtxIdx - nPtsInRing).toArray(positions, vtxIdx);
        }
      }
    }
  }]);
  return ExtrudedObjectsGeometry2;
}(ChunkedObjectsGeometry);
function _createSuper$1J(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1J();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1J() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var MAX_IDC_16BIT = 65535;
var VERTEX_PER_SEGMENT = 4;
var POS_SIZE = 4;
var DIR_SIZE = 3;
var COL_SIZE = 3;
var tmpColor$1 = new Color();
var direction = new Vector3();
function setArrayXYZ(arr, idx, x2, y2, z2) {
  arr[idx] = x2;
  arr[idx + 1] = y2;
  arr[idx + 2] = z2;
}
function setArrayXYZW(arr, idx, x2, y2, z2, w2) {
  arr[idx] = x2;
  arr[idx + 1] = y2;
  arr[idx + 2] = z2;
  arr[idx + 3] = w2;
}
function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
  var start = startSegmentIdx * VERTEX_PER_SEGMENT;
  var end = start + segmentsCount * VERTEX_PER_SEGMENT;
  return arr.subarray(start * elemSize, end * elemSize);
}
var ThickLinesGeometry = function(_BufferGeometry) {
  _inherits(ThickLinesGeometry2, _BufferGeometry);
  var _super = _createSuper$1J(ThickLinesGeometry2);
  function ThickLinesGeometry2(segmentsCount) {
    var _this;
    _classCallCheck(this, ThickLinesGeometry2);
    _this = _super.call(this);
    _this._initVertices(segmentsCount);
    return _this;
  }
  _createClass(ThickLinesGeometry2, [{
    key: "startUpdate",
    value: function startUpdate() {
      return true;
    }
  }, {
    key: "finishUpdate",
    value: function finishUpdate() {
      this.getAttribute("position").needsUpdate = true;
      this.getAttribute("color").needsUpdate = true;
      this.getAttribute("alphaColor").needsUpdate = true;
      this.getAttribute("direction").needsUpdate = true;
    }
  }, {
    key: "setColor",
    value: function setColor(segmentIdx, colorVal) {
      tmpColor$1.set(colorVal);
      var idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
      setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
      idx += COL_SIZE;
      setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
      idx += COL_SIZE;
      setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
      idx += COL_SIZE;
      setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
    }
  }, {
    key: "setSegment",
    value: function setSegment(segmentIdx, pos1, pos2) {
      direction.subVectors(pos1, pos2);
      direction.normalize();
      var positions = this._positions;
      var directions = this._directions;
      var idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
      var dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
      setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, 0.5);
      setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
      idx += POS_SIZE;
      dirIdx += DIR_SIZE;
      setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, -0.5);
      setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
      idx += POS_SIZE;
      dirIdx += DIR_SIZE;
      setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, 0.5);
      setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
      idx += POS_SIZE;
      dirIdx += DIR_SIZE;
      setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, -0.5);
      setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(startSegIdx, endSegIdx, value) {
      var start = startSegIdx * VERTEX_PER_SEGMENT;
      var end = endSegIdx * VERTEX_PER_SEGMENT;
      (0, import_lodash.fill)(this.alpha, value, end, start);
      this.getAttribute("alphaColor").needsUpdate = true;
    }
  }, {
    key: "getSubsetSegments",
    value: function getSubsetSegments(startSegmentIdx, segmentsCount) {
      return [getSubset(this._positions, startSegmentIdx, segmentsCount, POS_SIZE), getSubset(this._directions, startSegmentIdx, segmentsCount, DIR_SIZE)];
    }
  }, {
    key: "getSubsetColors",
    value: function getSubsetColors(startSegmentIdx, segmentsCount) {
      return getSubset(this._colors, startSegmentIdx, segmentsCount, COL_SIZE);
    }
  }, {
    key: "getSubsetOpacities",
    value: function getSubsetOpacities(startSegmentIdx, segmentsCount) {
      return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1);
    }
  }, {
    key: "getNumVertexPerSegment",
    value: function getNumVertexPerSegment() {
      return VERTEX_PER_SEGMENT;
    }
  }, {
    key: "getPositionSize",
    value: function getPositionSize() {
      return POS_SIZE;
    }
  }, {
    key: "setSegments",
    value: function setSegments(startSegmentIdx, positions) {
      var startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
      if (positions instanceof Array && positions.length === 2) {
        this._positions.set(positions[0], startPos);
        var startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
        this._directions.set(positions[1], startDir);
      } else {
        this._positions.set(positions, startPos);
      }
    }
  }, {
    key: "setColors",
    value: function setColors(startSegmentIdx, colors) {
      var start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
      this._colors.set(colors, start);
    }
  }, {
    key: "_initVertices",
    value: function _initVertices(segmentsCount) {
      this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT;
      var pointsCount = this._buffersSize;
      var use32bitIndex = pointsCount > MAX_IDC_16BIT;
      this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, segmentsCount * 6);
      this._positions = utils.allocateTyped(Float32Array, pointsCount * POS_SIZE);
      this._colors = utils.allocateTyped(Float32Array, pointsCount * COL_SIZE);
      this._directions = utils.allocateTyped(Float32Array, pointsCount * DIR_SIZE);
      var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
      (0, import_lodash.fill)(alpha, 1);
      var index = this._index;
      var indexOffset = 0;
      var pointOffset = 0;
      for (var j2 = 0; j2 < segmentsCount; j2++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT) {
        index[indexOffset] = pointOffset;
        index[indexOffset + 1] = pointOffset + 1;
        index[indexOffset + 2] = pointOffset + 3;
        index[indexOffset + 3] = pointOffset;
        index[indexOffset + 4] = pointOffset + 2;
        index[indexOffset + 5] = pointOffset + 3;
      }
      this.setIndex(new BufferAttribute(this._index, 1));
      this.setAttribute("position", new BufferAttribute(this._positions, POS_SIZE));
      this.setAttribute("color", new BufferAttribute(this._colors, COL_SIZE));
      this.setAttribute("alphaColor", new BufferAttribute(alpha, 1));
      this.setAttribute("direction", new BufferAttribute(this._directions, DIR_SIZE));
    }
  }]);
  return ThickLinesGeometry2;
}(BufferGeometry);
function _createSuper$1I(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1I();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1I() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var LinesGeometry = function(_BaseLinesGeometry) {
  _inherits(LinesGeometry2, _BaseLinesGeometry);
  var _super = _createSuper$1I(LinesGeometry2);
  function LinesGeometry2() {
    _classCallCheck(this, LinesGeometry2);
    return _super.apply(this, arguments);
  }
  _createClass(LinesGeometry2, [{
    key: "startUpdate",
    value: function startUpdate() {
      return true;
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      var boundingBox = this.boundingBox;
      var radiusSquared = 0;
      var center = new Vector3();
      if (boundingBox) {
        boundingBox.getCenter(center);
      }
      var positions = this._positions;
      var sphere = this.boundingSphere || new Sphere();
      var size = this._positions.length;
      var pos = new Vector3();
      var posSize = this.getPositionSize();
      for (var i2 = 0; i2 < size; i2 += posSize) {
        pos.set(positions[i2], positions[i2 + 1], positions[i2 + 2]);
        var lengthSquared = center.distanceToSquared(pos);
        if (radiusSquared < lengthSquared) {
          radiusSquared = lengthSquared;
        }
      }
      sphere.set(center, Math.sqrt(radiusSquared));
      this.boundingSphere = sphere;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      var positions = this._positions;
      var box = new Box3();
      var size = this._positions.length;
      var tmpVec = new Vector3();
      var posSize = this.getPositionSize();
      for (var i2 = 0; i2 < size; i2 += posSize) {
        tmpVec.set(positions[i2], positions[i2 + 1], positions[i2 + 2]);
        box.expandByPoint(tmpVec);
      }
      this.boundingBox = box;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.finishUpdate();
      this.computeBoundingSphere();
    }
  }]);
  return LinesGeometry2;
}(ThickLinesGeometry);
function _createSuper$1H(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1H();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1H() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VEC_SIZE = 3;
var tmpVector$1 = new Vector3();
var normMtx = new Matrix3();
var CylinderCollisionGeo = function(_ChunkedObjectsGeomet) {
  _inherits(CylinderCollisionGeo2, _ChunkedObjectsGeomet);
  var _super = _createSuper$1H(CylinderCollisionGeo2);
  function CylinderCollisionGeo2(instanceCount, polyComplexity) {
    var _this;
    _classCallCheck(this, CylinderCollisionGeo2);
    var cylGeometry = new CylinderGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, true);
    _this = _super.call(this, cylGeometry, instanceCount);
    var chunkSize = _this._chunkSize;
    _this._chunkPos = _this._chunkGeo.attributes.position.array;
    _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
    _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE);
    return _this;
  }
  _createClass(CylinderCollisionGeo2, [{
    key: "setItem",
    value: function setItem(itemIdx, botPos, topPos, itemRad) {
      var chunkSize = this._chunkSize;
      var itemOffset = chunkSize * itemIdx * VEC_SIZE;
      var tmpArray = this._tmpVector;
      var geoPos = this._chunkPos;
      var geoNorm = this._chunkNorms;
      var mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
      normMtx.getNormalMatrix(mtx1);
      var idx;
      for (var i2 = 0; i2 < chunkSize; ++i2) {
        idx = i2 * VEC_SIZE;
        tmpVector$1.fromArray(geoPos, idx);
        tmpVector$1.applyMatrix4(mtx1);
        tmpVector$1.toArray(tmpArray, idx);
      }
      this._positions.set(tmpArray, itemOffset);
      for (var _i = 0; _i < chunkSize; ++_i) {
        idx = _i * VEC_SIZE;
        tmpVector$1.fromArray(geoNorm, idx);
        tmpVector$1.applyMatrix3(normMtx);
        tmpVector$1.toArray(tmpArray, idx);
      }
      this._normals.set(tmpArray, itemOffset);
    }
  }]);
  return CylinderCollisionGeo2;
}(ChunkedObjectsGeometry);
function _createSuper$1G(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1G();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1G() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var COLLISION_RAD$1 = 0.1;
var ChunkedLinesGeometry = function(_LinesGeometry) {
  _inherits(ChunkedLinesGeometry2, _LinesGeometry);
  var _super = _createSuper$1G(ChunkedLinesGeometry2);
  function ChunkedLinesGeometry2(chunksCount, segmentsCount, enableCollision) {
    var _this;
    _classCallCheck(this, ChunkedLinesGeometry2);
    _this = _super.call(this, chunksCount * segmentsCount);
    _this._init(segmentsCount);
    _this._collisionGeo = enableCollision ? new CylinderCollisionGeo(chunksCount * segmentsCount, 3) : null;
    return _this;
  }
  _createClass(ChunkedLinesGeometry2, [{
    key: "startUpdate",
    value: function startUpdate() {
      return true;
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      var collisionGeo = this._collisionGeo;
      if (collisionGeo) {
        collisionGeo.computeBoundingSphere();
        this.boundingSphere = collisionGeo.boundingSphere;
        return;
      }
      _get(_getPrototypeOf(ChunkedLinesGeometry2.prototype), "computeBoundingSphere", this).call(this);
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      var collisionGeo = this._collisionGeo;
      if (collisionGeo) {
        collisionGeo.computeBoundingBox();
        this.boundingBox = collisionGeo.boundingBox;
        return;
      }
      _get(_getPrototypeOf(ChunkedLinesGeometry2.prototype), "computeBoundingBox", this).call(this);
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var collisionGeo = this._collisionGeo;
      if (!collisionGeo) {
        return;
      }
      var segCount = this._chunkSize;
      this._collisionGeo.raycast(raycaster, intersects2);
      for (var i2 = 0, n2 = intersects2.length; i2 < n2; ++i2) {
        var chunkIdx = intersects2[i2].chunkIdx;
        if (chunkIdx === void 0) {
          continue;
        }
        chunkIdx = chunkIdx / segCount | 0;
        intersects2[i2].chunkIdx = chunkIdx;
      }
    }
  }, {
    key: "setColor",
    value: function setColor(chunkIdx, colorVal) {
      var chunkSize = this._chunkSize;
      for (var i2 = chunkIdx * chunkSize, end = i2 + chunkSize; i2 < end; ++i2) {
        _get(_getPrototypeOf(ChunkedLinesGeometry2.prototype), "setColor", this).call(this, i2, colorVal);
      }
    }
  }, {
    key: "setSegment",
    value: function setSegment(chunkIdx, segIdx, pos1, pos2) {
      var chunkSize = this._chunkSize;
      var idx = chunkIdx * chunkSize + segIdx;
      _get(_getPrototypeOf(ChunkedLinesGeometry2.prototype), "setSegment", this).call(this, idx, pos1, pos2);
      if (this._collisionGeo) {
        this._collisionGeo.setItem(chunkIdx * chunkSize + segIdx, pos1, pos2, COLLISION_RAD$1);
      }
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.finishUpdate();
      this.computeBoundingSphere();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(chunkIndices, value) {
      var chunkSize = this._chunkSize;
      for (var i2 = 0, n2 = chunkIndices.length; i2 < n2; ++i2) {
        var left = chunkIndices[i2] * chunkSize;
        _get(_getPrototypeOf(ChunkedLinesGeometry2.prototype), "setOpacity", this).call(this, left, left + chunkSize - 1, value);
      }
    }
  }, {
    key: "getSubset",
    value: function getSubset2(chunkIndices) {
      var instanceCount = chunkIndices.length;
      var chunkSize = this._chunkSize;
      var subset = new ChunkedLinesGeometry2(instanceCount, chunkSize, false);
      for (var i2 = 0, n2 = chunkIndices.length; i2 < n2; ++i2) {
        var dstPtOffset = i2 * chunkSize;
        var startSegIdx = chunkIndices[i2] * chunkSize;
        subset.setSegments(dstPtOffset, this.getSubsetSegments(startSegIdx, chunkSize));
        subset.setColors(dstPtOffset, this.getSubsetColors(startSegIdx, chunkSize));
      }
      subset.boundingSphere = this.boundingSphere;
      subset.boundingBox = this.boundingBox;
      return [subset];
    }
  }, {
    key: "_init",
    value: function _init(chunkSize) {
      this._chunkSize = chunkSize;
    }
  }]);
  return ChunkedLinesGeometry2;
}(LinesGeometry);
function _createSuper$1F(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1F();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1F() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var COLLISION_RAD = 0.3;
var tmpVector = new Vector3();
var TwoColorLinesGeometry = function(_LinesGeometry) {
  _inherits(TwoColorLinesGeometry2, _LinesGeometry);
  var _super = _createSuper$1F(TwoColorLinesGeometry2);
  function TwoColorLinesGeometry2(segmentsCount) {
    var _this;
    _classCallCheck(this, TwoColorLinesGeometry2);
    _this = _super.call(this, segmentsCount * 2);
    _this._init(segmentsCount);
    _this._collisionGeo = new Simple2CCylindersGeometry(segmentsCount, 3);
    return _this;
  }
  _createClass(TwoColorLinesGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, botPos, topPos) {
      this._collisionGeo.setItem(itemIdx, botPos, topPos, COLLISION_RAD);
      var offset = 2 * itemIdx;
      tmpVector.lerpVectors(botPos, topPos, 0.5);
      _get(_getPrototypeOf(TwoColorLinesGeometry2.prototype), "setSegment", this).call(this, offset, botPos, tmpVector);
      _get(_getPrototypeOf(TwoColorLinesGeometry2.prototype), "setSegment", this).call(this, offset + 1, tmpVector, topPos);
    }
  }, {
    key: "setColor",
    value: function setColor(itemIdx, colorVal1, colorVal2) {
      var offset = 2 * itemIdx;
      _get(_getPrototypeOf(TwoColorLinesGeometry2.prototype), "setColor", this).call(this, offset, colorVal1);
      _get(_getPrototypeOf(TwoColorLinesGeometry2.prototype), "setColor", this).call(this, offset + 1, colorVal2);
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      if (this._collisionGeo) {
        this._collisionGeo.raycast(raycaster, intersects2);
      }
    }
  }, {
    key: "getSubset",
    value: function getSubset2(segmentIndices) {
      var instanceCount = segmentIndices.length;
      var subset = new TwoColorLinesGeometry2(instanceCount, false);
      for (var i2 = 0, n2 = instanceCount; i2 < n2; ++i2) {
        var startSegIdx = segmentIndices[i2];
        subset.setSegments(i2, this.getSubsetSegments(startSegIdx, 1));
        subset.setColors(i2, this.getSubsetColors(startSegIdx, 1));
      }
      subset.boundingSphere = this.boundingSphere;
      subset.boundingBox = this.boundingBox;
      return [subset];
    }
  }, {
    key: "_init",
    value: function _init(segmentsCount) {
      this._segCounts = segmentsCount * 2;
    }
  }]);
  return TwoColorLinesGeometry2;
}(LinesGeometry);
function _createSuper$1E(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1E();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1E() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var vectors = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
var vecCount = vectors.length;
var tempPos1 = new Vector3();
var tempPos2 = new Vector3();
var CrossGeometry = function(_SphereCollisionGeo) {
  _inherits(CrossGeometry2, _SphereCollisionGeo);
  var _super = _createSuper$1E(CrossGeometry2);
  function CrossGeometry2(chunksCount) {
    _classCallCheck(this, CrossGeometry2);
    return _super.call(this, chunksCount, chunksCount, vecCount / 2 | 0, false);
  }
  _createClass(CrossGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, itemPos, itemRad) {
      this.setSphere(itemIdx, itemPos, itemRad);
      for (var i2 = 0; i2 < vecCount / 2; ++i2) {
        var first = i2 * 2;
        tempPos1.x = itemPos.x + vectors[first].x * itemRad;
        tempPos1.y = itemPos.y + vectors[first].y * itemRad;
        tempPos1.z = itemPos.z + vectors[first].z * itemRad;
        var second = first + 1;
        tempPos2.x = itemPos.x + vectors[second].x * itemRad;
        tempPos2.y = itemPos.y + vectors[second].y * itemRad;
        tempPos2.z = itemPos.z + vectors[second].z * itemRad;
        this.setSegment(itemIdx, i2, tempPos1, tempPos2);
      }
    }
  }]);
  return CrossGeometry2;
}(SphereCollisionGeo(ChunkedLinesGeometry));
function _createSuper$1D(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1D();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1D() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var POS_RAD_SIZE = 4;
var COLOR_SIZE$1 = 3;
var tmpColor = new Color();
var IsoSurfaceGeometry = function(_BufferGeometry) {
  _inherits(IsoSurfaceGeometry2, _BufferGeometry);
  var _super = _createSuper$1D(IsoSurfaceGeometry2);
  function IsoSurfaceGeometry2(spheresCount, opts) {
    var _this;
    _classCallCheck(this, IsoSurfaceGeometry2);
    _this = _super.call(this);
    _this._opts = opts;
    _this.zClip = _this._opts.zClip;
    _this._posRad = utils.allocateTyped(Float32Array, spheresCount * POS_RAD_SIZE);
    _this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE$1);
    return _this;
  }
  _createClass(IsoSurfaceGeometry2, [{
    key: "setItem",
    value: function setItem(chunkIdx, pos, radius) {
      var posRad = this._posRad;
      var idx = POS_RAD_SIZE * chunkIdx;
      posRad[idx++] = pos.x;
      posRad[idx++] = pos.y;
      posRad[idx++] = pos.z;
      posRad[idx] = radius;
    }
  }, {
    key: "setColor",
    value: function setColor(chunkIdx, colorVal) {
      tmpColor.set(colorVal);
      var colors = this._colors;
      var idx = COLOR_SIZE$1 * chunkIdx;
      colors[idx++] = tmpColor.r;
      colors[idx++] = tmpColor.g;
      colors[idx] = tmpColor.b;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.finishUpdate();
      this.computeBoundingSphere();
    }
  }, {
    key: "finishUpdate",
    value: function finishUpdate() {
      this._build();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity() {
    }
  }, {
    key: "raycast",
    value: function raycast() {
    }
  }, {
    key: "getSubset",
    value: function getSubset2() {
      return [];
    }
  }]);
  return IsoSurfaceGeometry2;
}(BufferGeometry);
var IsoSurfaceMarchCube = function() {
  function IsoSurfaceMarchCube2() {
    _classCallCheck(this, IsoSurfaceMarchCube2);
    this.pointsValuesLinear = null;
    this.hasIntersection = null;
    this.bitsInside = null;
  }
  _createClass(IsoSurfaceMarchCube2, [{
    key: "create",
    value: function create(numCellsPerSide) {
      var vx7000000 = 117440512;
      var n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;
      if (n3 > vx7000000) {
        throw new Error("Too large cube dimension: lead to memory huge uasge");
      }
      this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
      this.hasIntersection = utils.allocateTyped(Int32Array, n3);
      this.bitsInside = utils.allocateTyped(Int32Array, n3);
      return 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.bitsInside = null;
      this.hasIntersection = null;
      this.pointsValuesLinear = null;
    }
  }]);
  return IsoSurfaceMarchCube2;
}();
IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var edgeTable = [0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309, 2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666, 1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219, 3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340, 2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681, 419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214, 4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367, 613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912, 1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317, 4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881, 1107, 1370, 598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899, 2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204, 4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505, 2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966, 1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167, 3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616, 2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013, 255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154, 3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635, 1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988, 1196, 1445, 1711, 1958, 170, 419, 681, 928, 3376, 3129, 3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590, 314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975, 2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400, 3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541, 1295, 1030, 778, 515, 265, 0];
function _voxelGradientFast(v2, point, grad) {
  var g2 = v2.getValue(point.x, point.y, point.z);
  grad.set(g2[0], g2[1], g2[2]);
}
var GridCell = _createClass(function GridCell2() {
  _classCallCheck(this, GridCell2);
  this._arrSize = 8;
  this.p = new Array(this._arrSize);
  this.g = new Array(this._arrSize);
  this.val = new Array(this._arrSize);
  for (var i2 = 0; i2 < this._arrSize; ++i2) {
    this.p[i2] = new Vector3();
    this.g[i2] = new Vector3();
  }
  this.cubeIndex = 0;
});
var Triangle2 = _createClass(function Triangle3() {
  _classCallCheck(this, Triangle3);
  this.a = {
    p: new Vector3(),
    n: new Vector3()
  };
  this.b = {
    p: new Vector3(),
    n: new Vector3()
  };
  this.c = {
    p: new Vector3(),
    n: new Vector3()
  };
});
function createArray(arrSize) {
  var arr = new Array(arrSize);
  for (var i2 = 0; i2 < arrSize; ++i2) {
    arr[i2] = new Vector3();
  }
  return arr;
}
var IsoSurface = function() {
  function IsoSurface2() {
    _classCallCheck(this, IsoSurface2);
    this._numTriangles = 0;
    this._numVertices = 0;
    this._position = [];
    this._normals = [];
    this._colors = null;
    this._indices = [];
    this._volumetricData = null;
    this._xAxis = new Vector3();
    this._yAxis = new Vector3();
    this._zAxis = new Vector3();
    this._xDir = new Vector3();
    this._yDir = new Vector3();
    this._zDir = new Vector3();
  }
  _createClass(IsoSurface2, [{
    key: "_prepareAxesAndDirs",
    value: function _prepareAxesAndDirs() {
      var volData = this._volumetricData;
      var cellSize = volData.getCellSize();
      var xAxis = this._xAxis;
      var yAxis = this._yAxis;
      var zAxis = this._zAxis;
      var xDir = this._xDir;
      var yDir = this._yDir;
      var zDir = this._zDir;
      xAxis.set(cellSize.x, 0, 0);
      yAxis.set(0, cellSize.y, 0);
      zAxis.set(0, 0, cellSize.z);
      xDir.set(1, 0, 0);
      yDir.set(0, 1, 0);
      zDir.set(0, 0, 1);
      var tmp2 = new Vector3();
      tmp2.crossVectors(xDir, yDir);
      if (tmp2.dot(zDir) < 0) {
        xDir.negate();
        yDir.negate();
        zDir.negate();
      }
      if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
        return false;
      }
      var notZero = function notZero2(axe) {
        return Math.abs(axe) > Number.EPSILON;
      };
      return !(notZero(xAxis.y) || notZero(xAxis.z) || notZero(yAxis.x) || notZero(yAxis.z) || notZero(zAxis.x) || notZero(zAxis.y));
    }
  }, {
    key: "_vertexInterp",
    value: function _vertexInterp(isoLevel, grid, ind1, ind2, vertex, normal) {
      var p1 = grid.p[ind1];
      var p2 = grid.p[ind2];
      var n1 = grid.g[ind1];
      var n2 = grid.g[ind2];
      var valP1 = grid.val[ind1];
      var valP2 = grid.val[ind2];
      var isoDiffP1 = isoLevel - valP1;
      var diffValP2P1 = valP2 - valP1;
      var mu = 0;
      if (Math.abs(diffValP2P1) > 0) {
        mu = isoDiffP1 / diffValP2P1;
      }
      mu = mu > 1 ? 1 : mu;
      vertex.lerpVectors(p1, p2, mu);
      normal.lerpVectors(n1, n2, mu);
    }
  }, {
    key: "_polygonize",
    value: function _polygonize(grid, isoLevel, triangles) {
      var cubeIndex = grid.cubeIndex;
      var i2 = 0;
      var arrSize = IsoSurface2._arrSize;
      var firstIndices = IsoSurface2._firstIndices;
      var secondIndices = IsoSurface2._secondIndices;
      var vertexList = IsoSurface2._vertexList;
      var normalList = IsoSurface2._normalList;
      for (; i2 < arrSize; ++i2) {
        if (edgeTable[cubeIndex] & 1 << i2) {
          this._vertexInterp(isoLevel, grid, firstIndices[i2], secondIndices[i2], vertexList[i2], normalList[i2]);
        }
      }
      var triCount = 0;
      var triTblIdx = cubeIndex * 16;
      var triTable = IsoSurface2._triTable;
      for (i2 = 0; triTable[triTblIdx + i2] !== -1; i2 += 3) {
        triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i2]]);
        triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i2]]);
        triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i2 + 1]]);
        triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i2 + 1]]);
        triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i2 + 2]]);
        triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i2 + 2]]);
        ++triCount;
      }
      return triCount;
    }
  }, {
    key: "_doGridPosNorms",
    value: function _doGridPosNorms(isoValue, step, appendSimple) {
      var vol = this._volumetricData;
      var volData = this._volumetricData.getData();
      var dim = vol.getDimensions();
      var xSize = dim[0];
      var ySize = dim[1];
      var zSize = dim[2];
      var stepX = step * vol.getStrideX();
      var stepY = step * vol.getStrideY();
      var stepZ = step * vol.getStrideZ();
      var gc = new GridCell();
      var gcVal = gc.val;
      var gcValSize = gc.val.length;
      var additions = [
        new Vector3(0, 0, 0),
        new Vector3(step, 0, 0),
        new Vector3(step, step, 0),
        new Vector3(0, step, 0),
        new Vector3(0, 0, step),
        new Vector3(step, 0, step),
        new Vector3(step, step, step),
        new Vector3(0, step, step)
      ];
      var tmpTriCount = 5;
      var triangles = new Array(tmpTriCount);
      for (var j2 = 0; j2 < tmpTriCount; ++j2) {
        triangles[j2] = new Triangle2();
      }
      var appendVertex;
      var self2 = this;
      var positions = this._position;
      var normals = this._normals;
      if (appendSimple) {
        appendVertex = function() {
          var axis = new Vector3(self2._xAxis.x, self2._yAxis.y, self2._zAxis.z);
          return function(triVertex) {
            var vertex = triVertex.p.clone();
            vertex.multiply(axis);
            positions.push(vertex.add(self2._origin));
            normals.push(triVertex.n.clone());
          };
        }();
      } else {
        appendVertex = function() {
          var posMtx = new Matrix3();
          posMtx.set(self2._xAxis.x, self2._yAxis.x, self2._zAxis.x, self2._xAxis.y, self2._yAxis.y, self2._zAxis.y, self2._xAxis.z, self2._yAxis.z, self2._zAxis.z);
          var normMtx2 = new Matrix3();
          normMtx2.set(self2._xDir.x, self2._yDir.x, self2._zDir.x, self2._xDir.y, self2._yDir.y, self2._zDir.y, self2._xDir.z, self2._yDir.z, self2._zDir.z);
          return function(triVertex) {
            positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(self2._origin));
            normals.push(triVertex.n.clone().applyMatrix3(normMtx2));
          };
        }();
      }
      var indices = this._indices;
      var globTriCount = 0;
      for (var z2 = 0; z2 < zSize - step; z2 += step) {
        for (var y2 = 0; y2 < ySize - step; y2 += step) {
          var idx = vol.getDirectIdx(0, y2, z2);
          for (var x2 = 0; x2 < xSize - step; x2 += step, idx += stepX) {
            gcVal[0] = volData[idx];
            gcVal[1] = volData[idx + stepX];
            gcVal[3] = volData[idx + stepY];
            gcVal[2] = volData[idx + stepX + stepY];
            gcVal[4] = volData[idx + stepZ];
            gcVal[5] = volData[idx + stepX + stepZ];
            gcVal[7] = volData[idx + stepY + stepZ];
            gcVal[6] = volData[idx + stepX + stepY + stepZ];
            var cubeIndex = 0;
            var i2 = 0;
            for (; i2 < gcValSize; ++i2) {
              if (gcVal[i2] < isoValue) {
                cubeIndex |= 1 << i2;
              }
            }
            if (edgeTable[cubeIndex] === 0) {
              continue;
            }
            gc.cubeIndex = cubeIndex;
            for (i2 = 0; i2 < gcValSize; ++i2) {
              gc.p[i2].set(x2 + additions[i2].x, y2 + additions[i2].y, z2 + additions[i2].z);
              _voxelGradientFast(this._gradient, gc.p[i2], gc.g[i2]);
            }
            var triCount = this._polygonize(gc, isoValue, triangles);
            globTriCount += triCount;
            for (i2 = 0; i2 < triCount; ++i2) {
              indices.push(this._numTriangles * 3);
              indices.push(this._numTriangles * 3 + 1);
              indices.push(this._numTriangles * 3 + 2);
              ++this._numTriangles;
              appendVertex(triangles[i2].a);
              appendVertex(triangles[i2].b);
              appendVertex(triangles[i2].c);
            }
          }
        }
      }
      return globTriCount;
    }
  }, {
    key: "compute",
    value: function compute(volData, origin, isoValue, step) {
      this._volumetricData = volData;
      this._origin = origin;
      this._gradient = volData.computeGradient();
      this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
    }
  }, {
    key: "_remapIndices",
    value: function _remapIndices(vertexMap, idcCount) {
      var indices = this._indices;
      var newIndices = utils.allocateTyped(Uint32Array, idcCount);
      for (var i2 = 0; i2 < idcCount; ++i2) {
        indices[i2] = vertexMap[indices[i2]];
        newIndices[i2] = indices[i2];
      }
      this._indices = newIndices;
    }
  }, {
    key: "_remapVertices",
    value: function _remapVertices(vertices, normals, count) {
      var newPositions = utils.allocateTyped(Float32Array, count * 3);
      var newNormals = utils.allocateTyped(Float32Array, count * 3);
      for (var i2 = 0; i2 < count; ++i2) {
        var pos = vertices[i2];
        newPositions[i2 * 3] = pos.x;
        newPositions[i2 * 3 + 1] = pos.y;
        newPositions[i2 * 3 + 2] = pos.z;
        var norm = normals[i2].normalize();
        newNormals[i2 * 3] = norm.x;
        newNormals[i2 * 3 + 1] = norm.y;
        newNormals[i2 * 3 + 2] = norm.z;
      }
      this._position = newPositions;
      this._normals = newNormals;
    }
  }, {
    key: "vertexFusion",
    value: function vertexFusion(offset, len) {
      var faceVer = this._indices.length;
      var vertices = this._position;
      var normals = this._normals;
      var oldVerCount = vertices.length | 0;
      if (faceVer === 0 || oldVerCount === 0) {
        return;
      }
      var vMap = utils.allocateTyped(Uint32Array, oldVerCount);
      vMap[0] = 0;
      var newVer = 1;
      var i2 = 1;
      for (; i2 < oldVerCount; ++i2) {
        var start = newVer - offset < 0 ? 0 : newVer - offset;
        var end = start + len > newVer ? newVer : start + len;
        var matchedIndex = -1;
        for (var j2 = start; j2 < end; ++j2) {
          if (Math.abs(vertices[i2] - vertices[j2]) < Number.EPSILON) {
            matchedIndex = j2;
            break;
          }
        }
        if (matchedIndex !== -1) {
          vMap[i2] = matchedIndex;
        } else {
          vertices[newVer].copy(vertices[i2]);
          normals[newVer].copy(normals[i2]);
          vMap[i2] = newVer;
          ++newVer;
        }
      }
      this._remapIndices(vMap, faceVer);
      this._remapVertices(vertices, normals, newVer);
    }
  }, {
    key: "setColorVolTex",
    value: function setColorVolTex(colorMap, atomMap, atomWeightMap, visibilitySelector) {
      var i2;
      var idx;
      var numVerts = this._position.length / 3;
      var vertices = this._position;
      var origin = this._origin;
      var dim = this._volumetricData.getDimensions();
      var xs = dim[0] - 1;
      var ys = dim[1] - 1;
      var zs = dim[2] - 1;
      var colorData = colorMap.getData();
      var strideX = colorMap.getStrideX();
      var strideY = colorMap.getStrideY();
      var strideZ = colorMap.getStrideZ();
      var atomWeightData;
      var atomStrideX;
      var atomStrideY;
      var atomStrideZ;
      if (visibilitySelector !== null) {
        atomWeightData = atomWeightMap.getData();
        atomStrideX = atomWeightMap.getStrideX();
        atomStrideY = atomWeightMap.getStrideY();
        atomStrideZ = atomWeightMap.getStrideZ();
      }
      var xInv = 1 / this._xAxis.x;
      var yInv = 1 / this._yAxis.y;
      var zInv = 1 / this._zAxis.z;
      var atomLookup = [];
      var atomWeights = [];
      var colors = utils.allocateTyped(Float32Array, numVerts * 3);
      function interp(mu, idx1, idx2, c4) {
        c4[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2];
        c4[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1];
        c4[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2];
      }
      function collectWeight(ai, coefX, coefY, coefZ) {
        var a2 = atomMap[ai];
        if (a2 != null) {
          atomLookup[a2.index] = a2;
          var w2 = coefX * coefY * coefZ * atomWeightData[ai];
          if (typeof atomWeights[a2.index] === "undefined") {
            atomWeights[a2.index] = w2;
          } else {
            atomWeights[a2.index] += w2;
          }
        }
      }
      var vMap = utils.allocateTyped(Int32Array, numVerts);
      var newVerCount = 0;
      for (i2 = 0; i2 < numVerts; i2++) {
        var ind = i2 * 3;
        var vx = (vertices[ind] - origin.x) * xInv;
        var vy = (vertices[ind + 1] - origin.y) * yInv;
        var vz = (vertices[ind + 2] - origin.z) * zInv;
        var x2 = Math.min(Math.max(vx, 0), xs) | 0;
        var y2 = Math.min(Math.max(vy, 0), ys) | 0;
        var z2 = Math.min(Math.max(vz, 0), zs) | 0;
        var mux = vx - x2;
        var muy = vy - y2;
        var muz = vz - z2;
        if (visibilitySelector != null) {
          atomLookup = [];
          atomWeights = [];
          idx = atomWeightMap.getDirectIdx(x2, y2, z2);
          collectWeight(idx, 1 - mux, 1 - muy, 1 - muz);
          collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz);
          collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz);
          collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz);
          collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz);
          collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz);
          collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz);
          collectWeight(idx + atomStrideX + atomStrideY + atomStrideZ, mux, muy, muz);
          var maxWeight = 0;
          var dominantIdx = -1;
          for (var atomIdx in atomWeights) {
            if (atomWeights[atomIdx] > maxWeight) {
              dominantIdx = atomIdx;
              maxWeight = atomWeights[atomIdx];
            }
          }
          if (dominantIdx < 0 || !visibilitySelector.includesAtom(atomLookup[dominantIdx])) {
            vMap[i2] = -1;
            continue;
          }
        }
        vMap[i2] = newVerCount++;
        var dx = x2 < xs ? strideX : 0;
        var dy = y2 < ys ? strideY : 0;
        var dz = z2 < zs ? strideZ : 0;
        var c0 = [0, 0, 0];
        var c1 = [0, 0, 0];
        var c2 = [0, 0, 0];
        var c3 = [0, 0, 0];
        idx = colorMap.getDirectIdx(x2, y2, z2);
        interp(mux, idx, idx + dx, c0);
        interp(mux, idx + dy, idx + dx + dy, c1);
        interp(mux, idx + dz, idx + dx + dz, c2);
        interp(mux, idx + dy + dz, idx + dx + dy + dz, c3);
        var cz0 = [0, 0, 0];
        cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
        cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
        cz0[2] = (1 - muy) * c0[2] + muy * c1[2];
        var cz1 = [0, 0, 0];
        cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
        cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
        cz1[2] = (1 - muy) * c2[2] + muy * c3[2];
        colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
        colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
        colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
      }
      this._colors = colors;
      if (visibilitySelector != null) {
        for (i2 = 0; i2 < numVerts; ++i2) {
          var j2 = vMap[i2];
          if (j2 < 0) {
            continue;
          }
          this._position[j2 * 3] = this._position[i2 * 3];
          this._position[j2 * 3 + 1] = this._position[i2 * 3 + 1];
          this._position[j2 * 3 + 2] = this._position[i2 * 3 + 2];
          this._normals[j2 * 3] = this._normals[i2 * 3];
          this._normals[j2 * 3 + 1] = this._normals[i2 * 3 + 1];
          this._normals[j2 * 3 + 2] = this._normals[i2 * 3 + 2];
          this._colors[j2 * 3] = this._colors[i2 * 3];
          this._colors[j2 * 3 + 1] = this._colors[i2 * 3 + 1];
          this._colors[j2 * 3 + 2] = this._colors[i2 * 3 + 2];
        }
        var numTriangles = this._indices.length / 3;
        var newTriCount = 0;
        for (i2 = 0; i2 < numTriangles; ++i2) {
          var i0 = vMap[this._indices[3 * i2]];
          var i1 = vMap[this._indices[3 * i2 + 1]];
          var i22 = vMap[this._indices[3 * i2 + 2]];
          if (i0 >= 0 && i1 >= 0 && i22 >= 0) {
            this._indices[3 * newTriCount] = i0;
            this._indices[3 * newTriCount + 1] = i1;
            this._indices[3 * newTriCount + 2] = i22;
            ++newTriCount;
          }
        }
        this._position = new Float32Array(this._position.buffer.slice(0, newVerCount * 3 * 4));
        this._normals = new Float32Array(this._normals.buffer.slice(0, newVerCount * 3 * 4));
        this._colors = new Float32Array(this._colors.buffer.slice(0, newVerCount * 3 * 4));
        this._indices = new Uint32Array(this._indices.buffer.slice(0, newTriCount * 3 * 4));
      }
    }
  }, {
    key: "toMesh",
    value: function toMesh() {
      var geo = new BufferGeometry();
      geo.setIndex(new BufferAttribute(this._indices, 1));
      geo.setAttribute("position", new BufferAttribute(this._position, 3));
      geo.setAttribute("normal", new BufferAttribute(this._normals, 3));
      geo.setAttribute("color", new BufferAttribute(this._colors, 3));
      geo.computeBoundingSphere();
      return geo;
    }
  }]);
  return IsoSurface2;
}();
_defineProperty2(IsoSurface, "_triTable", IsoSurfaceMarchCube.prototype.striIndicesMarchCube);
_defineProperty2(IsoSurface, "_arrSize", 12);
_defineProperty2(IsoSurface, "_firstIndices", [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3]);
_defineProperty2(IsoSurface, "_secondIndices", [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7]);
_defineProperty2(IsoSurface, "_vertexList", createArray(IsoSurface._arrSize));
_defineProperty2(IsoSurface, "_normalList", createArray(IsoSurface._arrSize));
function _createSuper$1C(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1C();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1C() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VolumeSurfaceGeometry = function(_IsoSurfaceGeometry) {
  _inherits(VolumeSurfaceGeometry2, _IsoSurfaceGeometry);
  var _super = _createSuper$1C(VolumeSurfaceGeometry2);
  function VolumeSurfaceGeometry2() {
    _classCallCheck(this, VolumeSurfaceGeometry2);
    return _super.apply(this, arguments);
  }
  _createClass(VolumeSurfaceGeometry2, [{
    key: "_build",
    value: function _build() {
      var params = this._opts;
      this.numVoxels = [128, 128, 128];
      this.xAxis = new Vector3(1, 0, 0);
      this.yAxis = new Vector3(0, 1, 0);
      this.zAxis = new Vector3(0, 0, 1);
      this.origin = new Vector3(0, 0, 0);
      this._visibilitySelector = params.visibilitySelector;
      this._calcSurface(params);
    }
  }, {
    key: "_findMinMax",
    value: function _findMinMax(posRadArray) {
      var itemSize = 4;
      var itemsCount = posRadArray.length / itemSize;
      var maxPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
      var minPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
      for (var i2 = 1; i2 < itemsCount; ++i2) {
        var ind = i2 * itemSize;
        for (var itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
          var tmpVal = posRadArray[ind + itemIdx];
          maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
          minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
        }
      }
      return {
        maxPosRad,
        minPosRad
      };
    }
  }, {
    key: "_findNumVoxels",
    value: function _findNumVoxels(posRadArray, params) {
      var numVoxels = this.numVoxels;
      var minMaxValues = this._findMinMax(posRadArray);
      var minCoordRad = minMaxValues.minPosRad;
      var maxCoordRad = minMaxValues.maxPosRad;
      if (minCoordRad[3] > 4) {
        params.gridSpacing *= minCoordRad[3];
      }
      var gridPadding = params.radScale * maxCoordRad[3] * 1.7;
      var padRad = gridPadding;
      padRad = 0.65 * Math.sqrt(4 / 3 * Math.PI * padRad * padRad * padRad);
      gridPadding = Math.max(gridPadding, padRad);
      var i2 = 0;
      for (; i2 < 3; ++i2) {
        minCoordRad[i2] -= gridPadding;
        maxCoordRad[i2] += gridPadding;
      }
      for (i2 = 0; i2 < 3; ++i2) {
        numVoxels[i2] = Math.ceil((maxCoordRad[i2] - minCoordRad[i2]) / params.gridSpacing);
      }
      this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
      this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
      this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;
      var _minCoordRad = _slicedToArray(minCoordRad, 3);
      this.origin.x = _minCoordRad[0];
      this.origin.y = _minCoordRad[1];
      this.origin.z = _minCoordRad[2];
      return {
        bbox: minMaxValues,
        dim: numVoxels
      };
    }
  }, {
    key: "_makeSurface",
    value: function _makeSurface(surface, params) {
      var isoSurf = new IsoSurface();
      isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1);
      isoSurf.vertexFusion(9, 9);
      if (isoSurf._numTriangles > 0) {
        isoSurf.setColorVolTex(surface.volTexMap, surface.atomMap, surface.atomWeightMap, this._visibilitySelector);
        this.setIndex(new BufferAttribute(isoSurf._indices, 1));
        this.setAttribute("position", new BufferAttribute(isoSurf._position, 3));
        this.setAttribute("normal", new BufferAttribute(isoSurf._normals, 3));
        this.setAttribute("color", new BufferAttribute(isoSurf._colors, 3));
      } else {
        this.setAttribute("position", new BufferAttribute(utils.allocateTyped(Float32Array, 0), 3));
      }
    }
  }, {
    key: "_calcSurface",
    value: function _calcSurface(params) {
      var packedArrays = {
        posRad: this._posRad,
        colors: this._colors,
        atoms: this._opts.atoms
      };
      if (packedArrays.posRad.length === 0) {
        return;
      }
      var boundaries = this._findNumVoxels(packedArrays.posRad, params);
      var box = new Box3(this.origin, new Vector3(this.xAxis.x, this.yAxis.y, this.zAxis.z).add(this.origin));
      var surface = this._computeSurface(packedArrays, box, boundaries, params);
      this._makeSurface(surface, params);
    }
  }]);
  return VolumeSurfaceGeometry2;
}(IsoSurfaceGeometry);
function _createSuper$1B(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1B();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1B() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Volume$1 = chem.Volume;
var QuickSurfGeometry = function(_VolumeSurfaceGeometr) {
  _inherits(QuickSurfGeometry2, _VolumeSurfaceGeometr);
  var _super = _createSuper$1B(QuickSurfGeometry2);
  function QuickSurfGeometry2() {
    _classCallCheck(this, QuickSurfGeometry2);
    return _super.apply(this, arguments);
  }
  _createClass(QuickSurfGeometry2, [{
    key: "_computeSurface",
    value: function _computeSurface(packedArrays, box, boundaries, params) {
      this._shiftByOrigin(packedArrays.posRad);
      var surface = {
        volMap: new Volume$1(Float32Array, this.numVoxels, box),
        volTexMap: new Volume$1(Float32Array, this.numVoxels, box, 3)
      };
      if (this._visibilitySelector != null) {
        surface.atomMap = [];
        surface.atomWeightMap = new Volume$1(Float32Array, this.numVoxels, box);
      }
      this.gaussdensity(surface, packedArrays, null, params);
      return surface;
    }
  }, {
    key: "gaussdensity",
    value: function gaussdensity(surface, packedArrays, atomicNum, params) {
      var numAtoms = packedArrays.posRad.length / 4;
      var posRad = packedArrays.posRad, colors = packedArrays.colors;
      var numVoxels = this.numVoxels;
      var radScale = params.radScale, gaussLim = params.gaussLim, gridSpacing = params.gridSpacing;
      var invIsoValue = 1 / params.isoValue;
      var invGridSpacing = 1 / gridSpacing;
      var maxVoxelX = numVoxels[0] - 1;
      var maxVoxelY = numVoxels[1] - 1;
      var maxVoxelZ = numVoxels[2] - 1;
      var volMap = surface.volMap, volTexMap = surface.volTexMap;
      var volData = volMap.getData();
      var strideX = volMap.getStrideX();
      var volTexData = volTexMap.getData();
      var texStrideX = volTexMap.getStrideX();
      var atomWeightData;
      if (this._visibilitySelector != null) {
        atomWeightData = surface.atomWeightMap.getData();
      }
      var atomMap = surface.atomMap;
      for (var i2 = 0; i2 < numAtoms; ++i2) {
        var ind = i2 * 4;
        var scaledRad = posRad[ind + 3] * radScale;
        var atomicNumFactor = atomicNum === null ? 1 : atomicNum[i2];
        var radInv = 1 / (2 * scaledRad * scaledRad);
        var radLim = gaussLim * scaledRad;
        var radLim2 = radLim * radLim;
        radLim *= invGridSpacing;
        var tmp2 = posRad[ind] * invGridSpacing;
        var xMin = Math.max(tmp2 - radLim | 0, 0);
        var xMax = Math.min(tmp2 + radLim | 0, maxVoxelX);
        tmp2 = posRad[ind + 1] * invGridSpacing;
        var yMin = Math.max(tmp2 - radLim | 0, 0);
        var yMax = Math.min(tmp2 + radLim | 0, maxVoxelY);
        tmp2 = posRad[ind + 2] * invGridSpacing;
        var zMin = Math.max(tmp2 - radLim | 0, 0);
        var zMax = Math.min(tmp2 + radLim | 0, maxVoxelZ);
        var dz = zMin * gridSpacing - posRad[ind + 2];
        for (var z2 = zMin; z2 <= zMax; ++z2, dz += gridSpacing) {
          var dy = yMin * gridSpacing - posRad[ind + 1];
          for (var y2 = yMin; y2 <= yMax; ++y2, dy += gridSpacing) {
            var dy2dz2 = dy * dy + dz * dz;
            if (dy2dz2 >= radLim2) {
              continue;
            }
            var addr = volMap.getDirectIdx(xMin, y2, z2);
            var texAddr = volTexMap.getDirectIdx(xMin, y2, z2);
            var dx = xMin * gridSpacing - posRad[ind];
            for (var x2 = xMin; x2 <= xMax; ++x2, dx += gridSpacing, addr += strideX, texAddr += texStrideX) {
              var r2 = dx * dx + dy2dz2;
              var expVal = -r2 * radInv;
              var density = Math.exp(expVal) * atomicNumFactor;
              if (this._visibilitySelector != null && density > atomWeightData[addr]) {
                atomWeightData[addr] = density;
                atomMap[addr] = packedArrays.atoms[i2];
              }
              volData[addr] += density;
              density *= invIsoValue;
              var colInd = i2 * 3;
              volTexData[texAddr] += density * colors[colInd];
              volTexData[texAddr + 1] += density * colors[colInd + 1];
              volTexData[texAddr + 2] += density * colors[colInd + 2];
            }
          }
        }
      }
    }
  }, {
    key: "_shiftByOrigin",
    value: function _shiftByOrigin(posRadArray) {
      var originX = this.origin.x;
      var originY = this.origin.y;
      var originZ = this.origin.z;
      var itemSize = 4;
      var itemsCount = posRadArray.length / itemSize;
      for (var i2 = 0; i2 < itemsCount; ++i2) {
        var ind = i2 * itemSize;
        posRadArray[ind] -= originX;
        posRadArray[ind + 1] -= originY;
        posRadArray[ind + 2] -= originZ;
      }
    }
  }]);
  return QuickSurfGeometry2;
}(VolumeSurfaceGeometry);
function AVHash(posRad, min, max, maxDistance) {
  var itemSize = 4;
  var nAtoms = posRad.length / itemSize;
  var minX = min[0];
  var minY = min[1];
  var minZ = min[2];
  var maxX = max[0];
  var maxY = max[1];
  var maxZ = max[2];
  function hashFunc(w2, minW) {
    return Math.floor((w2 - minW) / maxDistance);
  }
  var iDim = hashFunc(maxX, minX) + 1;
  var jDim = hashFunc(maxY, minY) + 1;
  var kDim = hashFunc(maxZ, minZ) + 1;
  var nCells = iDim * jDim * kDim;
  var jkDim = jDim * kDim;
  var cellID = function cellID2(x2, y2, z2) {
    return (hashFunc(x2, minX) * jDim + hashFunc(y2, minY)) * kDim + hashFunc(z2, minZ);
  };
  var preHash = [];
  var i2;
  var cid;
  for (i2 = 0; i2 < nAtoms; i2++) {
    var iIdx = itemSize * i2;
    cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2]);
    if (preHash[cid] === void 0) {
      preHash[cid] = [i2];
    } else {
      preHash[cid].push(i2);
    }
  }
  var cellOffsets = utils.allocateTyped(Uint32Array, nCells);
  var cellLengths = utils.allocateTyped(Uint16Array, nCells);
  var data = utils.allocateTyped(Uint32Array, nAtoms);
  var offset = 0;
  var maxCellLength = 0;
  var j2;
  for (i2 = 0; i2 < nCells; i2++) {
    var start = cellOffsets[i2] = offset;
    var subArray = preHash[i2];
    if (subArray !== void 0) {
      for (j2 = 0; j2 < subArray.length; j2++) {
        data[offset] = subArray[j2];
        offset++;
      }
    }
    var cellLength = offset - start;
    cellLengths[i2] = cellLength;
    if (cellLength > maxCellLength) {
      maxCellLength = cellLength;
    }
  }
  this.neighbourListLength = 27 * maxCellLength + 1;
  this.withinRadii = function(x2, y2, z2, rExtra, out) {
    var outIdx = 0;
    var nearI = hashFunc(x2, minX);
    var nearJ = hashFunc(y2, minY);
    var nearK = hashFunc(z2, minZ);
    var loI = Math.max(0, nearI - 1);
    var loJ = Math.max(0, nearJ - 1);
    var loK = Math.max(0, nearK - 1);
    var hiI = Math.min(iDim - 1, nearI + 1);
    var hiJ = Math.min(jDim - 1, nearJ + 1);
    var hiK = Math.min(kDim - 1, nearK + 1);
    for (i2 = loI; i2 <= hiI; ++i2) {
      var iOffset = i2 * jkDim;
      for (j2 = loJ; j2 <= hiJ; ++j2) {
        var jOffset = j2 * kDim;
        for (var k2 = loK; k2 <= hiK; ++k2) {
          cid = iOffset + jOffset + k2;
          var cellStart = cellOffsets[cid];
          var cellEnd = cellStart + cellLengths[cid];
          for (var dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
            var atomIndex = data[dataIndex];
            var baseIndex = itemSize * atomIndex;
            var dx = posRad[baseIndex] - x2;
            var dy = posRad[baseIndex + 1] - y2;
            var dz = posRad[baseIndex + 2] - z2;
            var rSum = posRad[baseIndex + 3] + rExtra;
            if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
              out[outIdx++] = data[dataIndex];
            }
          }
        }
      }
    }
    out[outIdx] = -1;
  };
}
function ContactSurface(packedArrays, boundaries, params, _indexList) {
  var itemSize = 4;
  var posRad = packedArrays.posRad, colors = packedArrays.colors, atoms = packedArrays.atoms;
  var nAtoms = posRad.length / itemSize;
  var bbox = boundaries.bbox;
  var min = bbox.minPosRad;
  var max = bbox.maxPosRad;
  var r2;
  var maxRadius;
  var probeRadius;
  var scaleFactor;
  var probePositions;
  var lastClip = -1;
  var dim;
  var grid;
  var volTex;
  var weights;
  var weightsMap = null;
  var atomMap = null;
  var visibilitySelector = null;
  var gridx;
  var gridy;
  var gridz;
  var sinTable;
  var cosTable;
  var hash;
  var neighbours;
  var mid = new Vector3(0, 0, 0);
  var n1 = new Vector3(0, 0, 0);
  var n2 = new Vector3(0, 0, 0);
  var ngTorus;
  function uniformArray(TypeName, n3, a2) {
    var array4 = utils.allocateTyped(TypeName, n3);
    for (var innI = 0; innI < n3; ++innI) {
      array4[innI] = a2;
    }
    return array4;
  }
  function fillGridDim(a2, start, step) {
    for (var innI = 0; innI < a2.length; innI++) {
      a2[innI] = start + step * innI;
    }
  }
  function initializeGrid() {
    scaleFactor = params.scaleFactor;
    dim = boundaries.dim;
    ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));
    var gridSize = dim[0] * dim[1] * dim[2];
    grid = uniformArray(Float32Array, gridSize, -1001);
    volTex = utils.allocateTyped(Float32Array, gridSize * 3);
    weights = utils.allocateTyped(Float32Array, gridSize);
    if (visibilitySelector) {
      weightsMap = utils.allocateTyped(Float32Array, gridSize);
      atomMap = [];
    }
    gridx = utils.allocateTyped(Float32Array, dim[0]);
    gridy = utils.allocateTyped(Float32Array, dim[1]);
    gridz = utils.allocateTyped(Float32Array, dim[2]);
    fillGridDim(gridx, min[0], 1 / scaleFactor);
    fillGridDim(gridy, min[1], 1 / scaleFactor);
    fillGridDim(gridz, min[2], 1 / scaleFactor);
  }
  function initializeAngleTables() {
    var theta = 0;
    var step = 2 * Math.PI / probePositions;
    cosTable = utils.allocateTyped(Float32Array, probePositions);
    sinTable = utils.allocateTyped(Float32Array, probePositions);
    for (var innI = 0; innI < probePositions; innI++) {
      cosTable[innI] = Math.cos(theta);
      sinTable[innI] = Math.sin(theta);
      theta += step;
    }
  }
  function initializeHash() {
    hash = new AVHash(posRad, min, max, 2.01 * maxRadius);
    neighbours = new Int32Array(hash.neighbourListLength);
  }
  function init2() {
    probeRadius = params.probeRadius;
    scaleFactor = params.scaleFactor;
    probePositions = params.probePositions;
    visibilitySelector = params.visibilitySelector;
    r2 = utils.allocateTyped(Float32Array, nAtoms);
    maxRadius = 0;
    for (var innI = 0; innI < nAtoms; ++innI) {
      var rExt = posRad[innI * itemSize + 3] += probeRadius;
      if (rExt > maxRadius) {
        maxRadius = rExt;
      }
      r2[innI] = rExt * rExt;
    }
    initializeGrid();
    initializeAngleTables();
    initializeHash();
    lastClip = -1;
  }
  function singleAtomObscures(ai, innX, innY, innZ) {
    var innCI = itemSize * ai;
    var ra2 = r2[ai];
    var dx = posRad[innCI] - innX;
    var dy = posRad[innCI + 1] - innY;
    var dz = posRad[innCI + 2] - innZ;
    var d2 = dx * dx + dy * dy + dz * dz;
    return d2 < ra2;
  }
  function obscured(innX, innY, innZ, a2, b2) {
    var ai;
    if (lastClip !== -1) {
      ai = lastClip;
      if (ai !== a2 && ai !== b2 && singleAtomObscures(ai, innX, innY, innZ)) {
        return ai;
      }
      lastClip = -1;
    }
    var ni = 0;
    ai = neighbours[ni];
    while (ai >= 0) {
      if (ai !== a2 && ai !== b2 && singleAtomObscures(ai, innX, innY, innZ)) {
        lastClip = ai;
        return ai;
      }
      ai = neighbours[++ni];
    }
    lastClip = -1;
    return -1;
  }
  function projectPoints() {
    var maxRad = 4;
    var sigma = maxRad / 3;
    var sigma2Inv = 1 / (2 * sigma * sigma);
    for (var innI = 0; innI < nAtoms; innI++) {
      var innCI = itemSize * innI;
      var ax = posRad[innCI];
      var ay = posRad[innCI + 1];
      var az = posRad[innCI + 2];
      var ar = posRad[innCI + 3];
      var ar2 = r2[innI];
      hash.withinRadii(ax, ay, az, ar, neighbours);
      var ng = Math.ceil(ar * scaleFactor);
      var iax = Math.floor(scaleFactor * (ax - min[0]));
      var iay = Math.floor(scaleFactor * (ay - min[1]));
      var iaz = Math.floor(scaleFactor * (az - min[2]));
      var minx = Math.max(0, iax - ng);
      var miny = Math.max(0, iay - ng);
      var minz = Math.max(0, iaz - ng);
      var maxx = Math.min(dim[0], iax + ng + 2);
      var maxy = Math.min(dim[1], iay + ng + 2);
      var maxz = Math.min(dim[2], iaz + ng + 2);
      var colIdx = innI * 3;
      var cr = colors[colIdx];
      var cg = colors[colIdx + 1];
      var cb = colors[colIdx + 2];
      for (var iz = minz; iz < maxz; iz++) {
        var dz = gridz[iz] - az;
        var zOffset = dim[1] * dim[0] * iz;
        for (var iy = miny; iy < maxy; iy++) {
          var dy = gridy[iy] - ay;
          var dzy2 = dz * dz + dy * dy;
          var zyOffset = zOffset + dim[0] * iy;
          for (var ix = minx; ix < maxx; ix++) {
            var idx = ix + zyOffset;
            var dx = gridx[ix] - ax;
            var d2 = dzy2 + dx * dx;
            if (d2 < ar2) {
              var w2 = Math.exp(-d2 * sigma2Inv);
              var cIdx = idx * 3;
              volTex[cIdx] += cr * w2;
              volTex[cIdx + 1] += cg * w2;
              volTex[cIdx + 2] += cb * w2;
              weights[idx] += w2;
              if (visibilitySelector !== null && w2 > weightsMap[idx]) {
                weightsMap[idx] = w2;
                atomMap[idx] = atoms[innI];
              }
              if (grid[idx] < 0) {
                grid[idx] = -grid[idx];
              }
              var d3 = Math.sqrt(d2);
              var ap = ar / d3;
              var spx = dx * ap;
              var spy = dy * ap;
              var spz = dz * ap;
              spx += ax;
              spy += ay;
              spz += az;
              if (obscured(spx, spy, spz, innI, -1) === -1) {
                var dd = ar - d3;
                if (dd < grid[idx]) {
                  grid[idx] = dd;
                }
              }
            }
          }
        }
      }
    }
  }
  function normalToLine(out, p2) {
    out.x = out.y = out.z = 1;
    if (p2.x !== 0) {
      out.x = (p2.y + p2.z) / -p2.x;
    } else if (p2.y !== 0) {
      out.y = (p2.x + p2.z) / -p2.y;
    } else if (p2.z !== 0) {
      out.z = (p2.x + p2.y) / -p2.z;
    }
    return out;
  }
  function projectTorus(a2, b2) {
    var aIdx = itemSize * a2;
    var bIdx = itemSize * b2;
    var xa = posRad[aIdx];
    var ya = posRad[aIdx + 1];
    var za = posRad[aIdx + 2];
    var r1 = posRad[aIdx + 3];
    var dx = mid.x = posRad[bIdx] - xa;
    var dy = mid.y = posRad[bIdx + 1] - ya;
    var dz = mid.z = posRad[bIdx + 2] - za;
    var innR2 = posRad[bIdx + 3];
    var d2 = dx * dx + dy * dy + dz * dz;
    var d3 = Math.sqrt(d2);
    var cosA = (r1 * r1 + d3 * d3 - innR2 * innR2) / (2 * r1 * d3);
    var dmp = r1 * cosA;
    mid.normalize();
    normalToLine(n1, mid);
    n1.normalize();
    n2.crossVectors(mid, n1);
    n2.normalize();
    var rInt = Math.sqrt(r1 * r1 - dmp * dmp);
    n1.multiplyScalar(rInt);
    n2.multiplyScalar(rInt);
    mid.multiplyScalar(dmp);
    mid.x += xa;
    mid.y += ya;
    mid.z += za;
    lastClip = -1;
    var ng = ngTorus;
    for (var innI = 0; innI < probePositions; innI++) {
      var cost = cosTable[innI];
      var sint = sinTable[innI];
      var px2 = mid.x + cost * n1.x + sint * n2.x;
      var py2 = mid.y + cost * n1.y + sint * n2.y;
      var pz2 = mid.z + cost * n1.z + sint * n2.z;
      if (obscured(px2, py2, pz2, a2, b2) === -1) {
        var iax = Math.floor(scaleFactor * (px2 - min[0]));
        var iay = Math.floor(scaleFactor * (py2 - min[1]));
        var iaz = Math.floor(scaleFactor * (pz2 - min[2]));
        var minx = Math.max(0, iax - ng);
        var miny = Math.max(0, iay - ng);
        var minz = Math.max(0, iaz - ng);
        var maxx = Math.min(dim[0], iax + ng + 2);
        var maxy = Math.min(dim[1], iay + ng + 2);
        var maxz = Math.min(dim[2], iaz + ng + 2);
        for (var iz = minz; iz < maxz; iz++) {
          dz = pz2 - gridz[iz];
          var zOffset = dim[1] * dim[0] * iz;
          for (var iy = miny; iy < maxy; iy++) {
            dy = py2 - gridy[iy];
            var dzy2 = dz * dz + dy * dy;
            var zyOffset = zOffset + dim[0] * iy;
            for (var ix = minx; ix < maxx; ix++) {
              dx = px2 - gridx[ix];
              d2 = dzy2 + dx * dx;
              var idx = ix + zyOffset;
              var current2 = grid[idx];
              if (current2 > 0 && d2 < current2 * current2) {
                grid[idx] = Math.sqrt(d2);
              }
            }
          }
        }
      }
    }
  }
  function projectTorii() {
    for (var innI = 0; innI < nAtoms; innI++) {
      var innIdx = itemSize * innI;
      hash.withinRadii(posRad[innIdx], posRad[innIdx + 1], posRad[innIdx + 2], posRad[innIdx + 3], neighbours);
      var ia = 0;
      var ni = neighbours[ia];
      while (ni >= 0) {
        if (innI < ni) {
          projectTorus(innI, ni);
        }
        ni = neighbours[++ia];
      }
    }
  }
  function fixNegatives() {
    for (var innI = 0, n3 = grid.length; innI < n3; innI++) {
      if (grid[innI] < 0) grid[innI] = 0;
      var w2 = weights[innI];
      if (w2 > 0) {
        w2 = 1 / w2;
        var innInnI = innI * 3;
        volTex[innInnI] *= w2;
        volTex[innInnI + 1] *= w2;
        volTex[innInnI + 2] *= w2;
      }
    }
  }
  function getVolume() {
    console.time("ContactSurface.getVolume");
    console.time("ContactSurface.init");
    init2();
    console.timeEnd("ContactSurface.init");
    console.time("ContactSurface.projectPoints");
    projectPoints();
    console.timeEnd("ContactSurface.projectPoints");
    console.time("ContactSurface.projectTorii");
    projectTorii();
    console.timeEnd("ContactSurface.projectTorii");
    fixNegatives();
    console.timeEnd("ContactSurface.getVolume");
  }
  this.build = function() {
    getVolume();
    this.volTexMap = volTex;
    this.weightsMap = weightsMap;
    this.atomMap = atomMap;
    this.volMap = grid;
  };
}
function _createSuper$1A(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1A();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1A() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Volume = chem.Volume;
var ContactSurfaceGeometry = function(_VolumeSurfaceGeometr) {
  _inherits(ContactSurfaceGeometry2, _VolumeSurfaceGeometr);
  var _super = _createSuper$1A(ContactSurfaceGeometry2);
  function ContactSurfaceGeometry2() {
    _classCallCheck(this, ContactSurfaceGeometry2);
    return _super.apply(this, arguments);
  }
  _createClass(ContactSurfaceGeometry2, [{
    key: "_computeSurface",
    value: function _computeSurface(packedArrays, box, boundaries, params) {
      var contactSurface = new ContactSurface(packedArrays, boundaries, params);
      contactSurface.build();
      var surface = {
        volMap: new Volume(Float32Array, this.numVoxels, box, 1, contactSurface.volMap),
        volTexMap: new Volume(Float32Array, this.numVoxels, box, 3, contactSurface.volTexMap),
        atomMap: contactSurface.atomMap,
        atomWeightMap: new Volume(Float32Array, this.numVoxels, box, 1, contactSurface.weightsMap)
      };
      return surface;
    }
  }]);
  return ContactSurfaceGeometry2;
}(VolumeSurfaceGeometry);
var IsoSurfaceAtomColored = _createClass(function IsoSurfaceAtomColored2(vCenter, radiusAt) {
  _classCallCheck(this, IsoSurfaceAtomColored2);
  this.coord = new Vector3();
  this.coord.copy(vCenter);
  this.radius = radiusAt;
  this.colorX = 0.99999;
  this.colorY = 0;
  this.colorZ = 0;
  this.atomType = 0;
  this.srcAtom = null;
});
var IsosurfaceBuildNormals = function() {
  function IsosurfaceBuildNormals2(numAtoms, atoms, vBoxMin, vBoxMax, probeRadius) {
    _classCallCheck(this, IsosurfaceBuildNormals2);
    this._numAtoms = numAtoms;
    this._atoms = atoms;
    this._vBoxMin = new Vector3();
    this._vBoxMax = new Vector3();
    this._vBoxMin.copy(vBoxMin);
    this._vBoxMax.copy(vBoxMax);
    this._probeRadius = probeRadius;
    this._atomsList = null;
    this._voxelList = null;
  }
  _createClass(IsosurfaceBuildNormals2, [{
    key: "createVoxels",
    value: function createVoxels() {
      var numAtomsRefs;
      var rad;
      var ATOM_VOXEL_REF_SCALE = 4.5;
      var numAtoms = this._numAtoms | 0;
      var atoms = this._atoms;
      var dx = this._vBoxMax.x - this._vBoxMin.x;
      var dy = this._vBoxMax.y - this._vBoxMin.y;
      var dz = this._vBoxMax.z - this._vBoxMin.z;
      var w2 = dx < dy ? dx : dy;
      w2 = dz < w2 ? dz : w2;
      var maxRad = 0;
      var aveRad = 0;
      var i2;
      for (i2 = 0; i2 < numAtoms; i2++) {
        rad = (atoms[i2].radius + this._probeRadius) * 2;
        maxRad = rad > maxRad ? rad : maxRad;
        aveRad += rad;
      }
      var numCells = Math.floor(w2 / maxRad);
      if (numCells < 2) {
        numCells = 2;
      }
      aveRad /= numAtoms;
      this._numCells = numCells;
      this._aveRad = aveRad;
      this._maxRad = maxRad;
      var side = numCells;
      var side2 = numCells * numCells;
      var side3 = numCells * numCells * numCells;
      var xScale = this._xScale = 1 / (this._vBoxMax.x - this._vBoxMin.x);
      var yScale = this._yScale = 1 / (this._vBoxMax.y - this._vBoxMin.y);
      var zScale = this._zScale = 1 / (this._vBoxMax.z - this._vBoxMin.z);
      var maxAtomsRefs = 0;
      var xNumVoxMult = xScale * numCells;
      var yNumVoxMult = yScale * numCells;
      var zNumVoxMult = zScale * numCells;
      for (i2 = 0; i2 < numAtoms; i2++) {
        var radAffect = (atoms[i2].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
        var diaAffect = radAffect * 2;
        var numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
        var numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
        var numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8);
        numVoxX++;
        numVoxY++;
        numVoxZ++;
        maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
      }
      this._voxelList = utils.allocateTyped(Int32Array, side3);
      var atomsList = [];
      atomsList.length = maxAtomsRefs;
      if (this._voxelList === null || atomsList === null) {
        return 0 - 1;
      }
      for (i2 = 0; i2 < side3; i2++) {
        this._voxelList[i2] = -1;
      }
      numAtomsRefs = 0;
      for (i2 = 0; i2 < numAtoms; i2++) {
        rad = (atoms[i2].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
        var xIndMin = Math.floor((atoms[i2].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
        var yIndMin = Math.floor((atoms[i2].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
        var zIndMin = Math.floor((atoms[i2].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
        var xIndMax = Math.floor((atoms[i2].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
        var yIndMax = Math.floor((atoms[i2].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
        var zIndMax = Math.floor((atoms[i2].coord.z - this._vBoxMin.z + rad) * numCells * zScale);
        xIndMin = xIndMin >= 0 ? xIndMin : 0;
        yIndMin = yIndMin >= 0 ? yIndMin : 0;
        zIndMin = zIndMin >= 0 ? zIndMin : 0;
        xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
        yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
        zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;
        for (var z2 = zIndMin; z2 <= zIndMax; z2++) {
          for (var y2 = yIndMin; y2 <= yIndMax; y2++) {
            for (var x2 = xIndMin; x2 <= xIndMax; x2++) {
              var indVoxel = x2 + y2 * side + z2 * side2;
              if (this._voxelList[indVoxel] < 0) {
                atomsList[numAtomsRefs * 2 + 0] = i2;
                atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
                this._voxelList[indVoxel] = numAtomsRefs;
                numAtomsRefs++;
                continue;
              }
              var indexNext = this._voxelList[indVoxel];
              this._voxelList[indVoxel] = numAtomsRefs;
              atomsList[numAtomsRefs * 2 + 0] = i2;
              atomsList[numAtomsRefs * 2 + 1] = indexNext;
              numAtomsRefs++;
            }
          }
        }
      }
      this._atomsList = Int32Array.from(atomsList);
      return 0;
    }
  }, {
    key: "destroyVoxels",
    value: function destroyVoxels() {
      this._atomsList = null;
      this._voxelList = null;
      this._atoms = null;
      this._vertices = null;
      this._vBoxMin = null;
      this._vBoxMax = null;
    }
  }, {
    key: "forEachRelatedAtom",
    value: function forEachRelatedAtom(point, process2) {
      var xInd = Math.floor((point.x - this._vBoxMin.x) * this._numCells * this._xScale);
      var yInd = Math.floor((point.y - this._vBoxMin.y) * this._numCells * this._yScale);
      var zInd = Math.floor((point.z - this._vBoxMin.z) * this._numCells * this._zScale);
      var indVoxel = xInd + yInd * this._numCells + zInd * this._numCells * this._numCells;
      var atoms = this._atoms;
      for (var ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
        var indexAtom = this._atomsList[ref * 2];
        process2(atoms[indexAtom]);
      }
    }
  }, {
    key: "getClosestAtom",
    value: function getClosestAtom(point) {
      var closest = null;
      var minDist2 = Number.MAX_VALUE;
      this.forEachRelatedAtom(point, function(atom) {
        var dist2 = point.distanceToSquared(atom.coord);
        if (dist2 < minDist2) {
          minDist2 = dist2;
          closest = atom;
        }
      });
      return closest;
    }
  }, {
    key: "buildNormals",
    value: function buildNormals(numVertices, vertices, normals) {
      var self2 = this;
      var numCloseAtoms = 0;
      var vx = 0;
      var vy = 0;
      var vz = 0;
      var dist2;
      var vNormalX = 0;
      var vNormalY = 0;
      var vNormalZ = 0;
      var koef = 0;
      var w2 = 0;
      var r25 = 2.5;
      var r01 = 0.1;
      var maxRadAffect = this._aveRad * r25;
      var maxRadAffect2 = maxRadAffect * maxRadAffect;
      var expScale = -this._aveRad * r01;
      var gatherNormals = function gatherNormals2(atom) {
        var dx = vx - atom.coord.x;
        var dy = vy - atom.coord.y;
        var dz = vz - atom.coord.z;
        dist2 = dx * dx + dy * dy + dz * dz;
        if (dist2 > maxRadAffect2) {
          return;
        }
        var rad = atom.radius + self2._probeRadius;
        koef = dist2 - rad * rad;
        if (koef < 0) {
          koef = -koef;
        }
        w2 = Math.exp(expScale * koef);
        vNormalX += dx * w2;
        vNormalY += dy * w2;
        vNormalZ += dz * w2;
        numCloseAtoms++;
      };
      for (var i2 = 0; i2 < numVertices; i2++) {
        vx = vertices[i2].x;
        vy = vertices[i2].y;
        vz = vertices[i2].z;
        numCloseAtoms = 0;
        vNormalX = vNormalY = vNormalZ = 0;
        this.forEachRelatedAtom(vertices[i2], gatherNormals);
        dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;
        if (numCloseAtoms > 0) {
          koef = 1 / Math.sqrt(dist2);
          vNormalX *= koef;
          vNormalY *= koef;
          vNormalZ *= koef;
        }
        normals[i2].x = vNormalX;
        normals[i2].y = vNormalY;
        normals[i2].z = vNormalZ;
      }
      return 0;
    }
  }, {
    key: "buildColors",
    value: function buildColors(numVertices, vertices, colors, radiusColorSmoothness) {
      var self2 = this;
      var vx = 0;
      var vy = 0;
      var vz = 0;
      var koef = 0;
      var w2 = 0;
      var KOEF_ADD = 0.8;
      var maxRadAffect = radiusColorSmoothness;
      var maxRadAffect2 = maxRadAffect * maxRadAffect;
      var colorsClose = [];
      var weights = [];
      var weightsSum = 0;
      var gatherColors = function gatherColors2(atom) {
        var dx = vx - atom.coord.x;
        var dy = vy - atom.coord.y;
        var dz = vz - atom.coord.z;
        var dist2 = dx * dx + dy * dy + dz * dz;
        if (dist2 > maxRadAffect2) {
          return;
        }
        var rad = atom.radius + self2._probeRadius;
        koef = dist2 - rad * rad;
        if (koef < 0) {
          koef = -koef;
        }
        w2 = 1 / (KOEF_ADD + koef);
        colorsClose.push([atom.colorX, atom.colorY, atom.colorZ]);
        weights.push(w2);
        weightsSum += w2;
      };
      for (var i2 = 0; i2 < numVertices; i2++) {
        vx = vertices[i2].x;
        vy = vertices[i2].y;
        vz = vertices[i2].z;
        colorsClose = [];
        weights = [];
        weightsSum = 0;
        this.forEachRelatedAtom(vertices[i2], gatherColors);
        for (var j2 = 0; j2 < colorsClose.length; ++j2) {
          var weightNormalized = weights[j2] / weightsSum;
          colors[i2].x += colorsClose[j2][0] * weightNormalized;
          colors[i2].y += colorsClose[j2][1] * weightNormalized;
          colors[i2].z += colorsClose[j2][2] * weightNormalized;
        }
      }
      return 0;
    }
  }]);
  return IsosurfaceBuildNormals2;
}();
var IsoSurfaceGeo = function() {
  function IsoSurfaceGeo2(maxNumVertices, maxNumTriangles, needVertexColors) {
    _classCallCheck(this, IsoSurfaceGeo2);
    this._maxNumVertices = maxNumVertices;
    this._maxNumTriangles = maxNumTriangles;
    this._vertices = new Array(maxNumVertices);
    this._normals = new Array(maxNumVertices);
    this._colors = null;
    if (needVertexColors) {
      this._colors = new Array(maxNumVertices);
    }
    this._indices = new Array(maxNumTriangles * (1 + 2));
    this._numVertices = 0;
    this._numTriangles = 0;
    var i2;
    for (i2 = 0; i2 < maxNumVertices; i2++) {
      this._vertices[i2] = new Vector3();
      this._normals[i2] = new Vector3();
    }
    for (i2 = 0; i2 < maxNumTriangles * (1 + 2); i2++) {
      this._indices[i2] = -1;
    }
    if (needVertexColors) {
      for (i2 = 0; i2 < maxNumVertices; i2++) {
        this._colors[i2] = new Vector3();
      }
    }
  }
  _createClass(IsoSurfaceGeo2, [{
    key: "destroy",
    value: function destroy() {
      this._vertices = null;
      this._normals = null;
      this._indices = null;
    }
  }]);
  return IsoSurfaceGeo2;
}();
function _createSuper$1z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1z() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var COLOR_SIZE = 3;
var HASH_SIZE = 32768;
var Element$9 = chem.Element;
var SSIsosurfaceGeometry = function(_IsoSurfaceGeometry) {
  _inherits(SSIsosurfaceGeometry2, _IsoSurfaceGeometry);
  var _super = _createSuper$1z(SSIsosurfaceGeometry2);
  function SSIsosurfaceGeometry2() {
    _classCallCheck(this, SSIsosurfaceGeometry2);
    return _super.apply(this, arguments);
  }
  _createClass(SSIsosurfaceGeometry2, [{
    key: "_build",
    value: function _build() {
      this._innerBuild();
      var geoOut = this.getGeo();
      this.destroy();
      this._fromGeo(geoOut);
    }
  }, {
    key: "_fromGeo",
    value: function _fromGeo(geoOut) {
      var colors = null;
      var positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
      var normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
      if (geoOut._colors !== null) {
        colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
      }
      var indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);
      for (var i2 = 0, j2 = 0; i2 < geoOut._numVertices; i2++) {
        positions[j2 + 0] = geoOut._vertices[i2].x;
        positions[j2 + 1] = geoOut._vertices[i2].y;
        positions[j2 + 2] = geoOut._vertices[i2].z;
        normals[j2 + 0] = geoOut._normals[i2].x;
        normals[j2 + 1] = geoOut._normals[i2].y;
        normals[j2 + 2] = geoOut._normals[i2].z;
        j2 += 3;
      }
      if (colors !== null) {
        for (var _i = 0, _j = 0; _i < geoOut._numVertices; _i++, _j += 3) {
          colors[_j + 0] = geoOut._colors[_i].x;
          colors[_j + 1] = geoOut._colors[_i].y;
          colors[_j + 2] = geoOut._colors[_i].z;
        }
      }
      var numTri3 = geoOut._numTriangles * (1 + 2);
      for (var _i2 = 0; _i2 < numTri3; _i2++) {
        indices[_i2] = geoOut._indices[_i2];
      }
      this.setIndex(new BufferAttribute(indices, 1));
      this.setAttribute("position", new BufferAttribute(positions, 3));
      this.setAttribute("normal", new BufferAttribute(normals, 3));
      this.setAttribute("color", new BufferAttribute(colors, 3));
      this.computeBoundingBox();
      this.computeBoundingSphere();
      geoOut.destroy();
    }
  }, {
    key: "convertToAtomsColored",
    value: function convertToAtomsColored(packedArrays, atomsColored) {
      var atoms = packedArrays.atoms, colors = packedArrays.colors;
      for (var i2 = 0, numAtoms = atoms.length; i2 < numAtoms; i2++) {
        var vCenter = atoms[i2].position;
        var radius = atoms[i2].element.radius;
        atomsColored[i2] = new IsoSurfaceAtomColored(vCenter, radius);
        var nm = atoms[i2].element.number;
        atomsColored[i2].atomType = this.getType(nm);
        var cIdx = COLOR_SIZE * i2;
        atomsColored[i2].colorX = colors[cIdx++];
        atomsColored[i2].colorY = colors[cIdx++];
        atomsColored[i2].colorZ = colors[cIdx];
        atomsColored[i2].srcAtom = atoms[i2];
      }
    }
  }, {
    key: "getGeo",
    value: function getGeo() {
      return this.geoOut;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.atoms = null;
      this.hashLines = null;
      this.hashEntries = null;
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(atoms, vBoxMin, vBoxMax) {
      var bigNum = 1e7;
      vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
      vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;
      var probeRadius2 = this.probeRadius * this.atomRadiusScale;
      var radMax = 0;
      for (var i2 = 0, num = atoms.length; i2 < num; i2++) {
        var vCenter = atoms[i2].coord;
        var rad = atoms[i2].radius + probeRadius2;
        radMax = rad > radMax ? rad : radMax;
        if (vCenter.x - rad < vBoxMin.x) {
          vBoxMin.x = vCenter.x - rad;
        }
        if (vCenter.y - rad < vBoxMin.y) {
          vBoxMin.y = vCenter.y - rad;
        }
        if (vCenter.z - rad < vBoxMin.z) {
          vBoxMin.z = vCenter.z - rad;
        }
        if (vCenter.x + rad > vBoxMax.x) {
          vBoxMax.x = vCenter.x + rad;
        }
        if (vCenter.y + rad > vBoxMax.y) {
          vBoxMax.y = vCenter.y + rad;
        }
        if (vCenter.z + rad > vBoxMax.z) {
          vBoxMax.z = vCenter.z + rad;
        }
      }
      vBoxMin.x -= radMax;
      vBoxMin.y -= radMax;
      vBoxMin.z -= radMax;
      vBoxMax.x += radMax;
      vBoxMax.y += radMax;
      vBoxMax.z += radMax;
    }
  }, {
    key: "getCornerCoord",
    value: function getCornerCoord(vBoxMin, vBoxMax, x2, y2, z2, numPoints, vOut) {
      var invNP = 1 / (numPoints - 1);
      var tx = x2 * invNP;
      var ty = y2 * invNP;
      var tz = z2 * invNP;
      vOut.x = vBoxMin.x * (1 - tx) + vBoxMax.x * tx;
      vOut.y = vBoxMin.y * (1 - ty) + vBoxMax.y * ty;
      vOut.z = vBoxMin.z * (1 - tz) + vBoxMax.z * tz;
    }
  }, {
    key: "buildEdgePoint",
    value: function buildEdgePoint(indexA, indexB, sign2, cube, indexPointValue, vOut) {
      if (sign2[indexA] ^ sign2[indexB]) {
        var cTwentyFour = 24;
        var a2 = 0 - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA];
        var b2 = cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB];
        var c2 = cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA];
        var t2 = a2 / (b2 - c2);
        var xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
        var ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
        var za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
        var xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
        var yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
        var zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];
        vOut.x = xa * (1 - t2) + xb * t2;
        vOut.y = ya * (1 - t2) + yb * t2;
        vOut.z = za * (1 - t2) + zb * t2;
      }
    }
  }, {
    key: "isTriangleVisible",
    value: function isTriangleVisible(v0, v1, v2) {
      var a0 = this.voxelWorld.getClosestAtom(v0);
      var a1 = this.voxelWorld.getClosestAtom(v1);
      var a2 = this.voxelWorld.getClosestAtom(v2);
      if (a0 === null || a1 === null || a2 === null || a0.srcAtom === null || a1.srcAtom === null || a2.srcAtom === null) {
        return false;
      }
      return this.visibilitySelector.includesAtom(a0.srcAtom) && this.visibilitySelector.includesAtom(a1.srcAtom) && this.visibilitySelector.includesAtom(a2.srcAtom);
    }
  }, {
    key: "addTriangle",
    value: function addTriangle(v0, v1, v2) {
      if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
        return true;
      }
      var geo = this.geoOut;
      if (geo._numTriangles >= this.maxNumTriangles) {
        return false;
      }
      var indInGeo0 = this.addVertexToGeo(geo, v0);
      var indInGeo1 = this.addVertexToGeo(geo, v1);
      var indInGeo2 = this.addVertexToGeo(geo, v2);
      if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
        return false;
      }
      var itr = 3 * geo._numTriangles;
      geo._indices[itr + 0] = indInGeo0;
      geo._indices[itr + 1] = indInGeo1;
      geo._indices[itr + 2] = indInGeo2;
      geo._numTriangles++;
      return true;
    }
  }, {
    key: "buildGeoFromCorners",
    value: function buildGeoFromCorners(meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube) {
      var arrSize = 12;
      var cNumVerts = 8;
      var numCells = meshRes - 1;
      var side = meshRes;
      var side2 = meshRes * meshRes;
      var vaEdges = new Array(arrSize);
      for (var i2 = 0; i2 < arrSize; i2++) {
        vaEdges[i2] = new Vector3();
      }
      var sign2 = [];
      for (var _i3 = 0; _i3 < cNumVerts; _i3++) {
        sign2[_i3] = 1;
      }
      var vCorner = new Vector3();
      var indCell = 0;
      var indY = 0;
      for (var y2 = 0; y2 < numCells; y2++, indY += side2) {
        var indZ = 0;
        for (var z2 = 0; z2 < numCells; z2++, indZ += side) {
          for (var x2 = 0; x2 < numCells; x2++) {
            if (!cube.hasIntersection[indCell]) {
              indCell++;
              continue;
            }
            var bitsInside = cube.bitsInside[indCell];
            this.getCornerCoord(vBoxMin, vBoxMax, x2, y2, z2, meshRes, vCorner);
            var indPointValues = indCell * (2 << 2 + 2);
            for (var _i4 = 0, j2 = 0; _i4 < cNumVerts; _i4++) {
              cube.pointsValuesLinear[indPointValues + j2++] = vCorner.x;
              cube.pointsValuesLinear[indPointValues + j2++] = vCorner.y;
              cube.pointsValuesLinear[indPointValues + j2++] = vCorner.z;
            }
            cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] += vCellStep.y;
            cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] += vCellStep.y;
            cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] += vCellStep.y;
            cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] += vCellStep.y;
            var indValues = indPointValues + 24;
            for (var _i5 = 0; _i5 < cNumVerts; ++_i5) {
              sign2[_i5] = cube.pointsValuesLinear[indValues + _i5] < 0 ? 1 : 0;
            }
            this.buildEdgePoint(0, 1, sign2, cube, indPointValues, vaEdges[0]);
            this.buildEdgePoint(1, 2, sign2, cube, indPointValues, vaEdges[1]);
            this.buildEdgePoint(2, 3, sign2, cube, indPointValues, vaEdges[2]);
            this.buildEdgePoint(3, 0, sign2, cube, indPointValues, vaEdges[3]);
            this.buildEdgePoint(4, 5, sign2, cube, indPointValues, vaEdges[4]);
            this.buildEdgePoint(5, 6, sign2, cube, indPointValues, vaEdges[5]);
            this.buildEdgePoint(6, 7, sign2, cube, indPointValues, vaEdges[6]);
            this.buildEdgePoint(7, 4, sign2, cube, indPointValues, vaEdges[7]);
            this.buildEdgePoint(0, 4, sign2, cube, indPointValues, vaEdges[8]);
            this.buildEdgePoint(1, 5, sign2, cube, indPointValues, vaEdges[9]);
            this.buildEdgePoint(2, 6, sign2, cube, indPointValues, vaEdges[10]);
            this.buildEdgePoint(3, 7, sign2, cube, indPointValues, vaEdges[11]);
            var offs = bitsInside * (2 << 1 + 2);
            for (var numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 3) {
              var i0 = cube.striIndicesMarchCube[offs + indTri];
              if (i0 < 0) {
                break;
              }
              var i1 = cube.striIndicesMarchCube[offs + indTri + 1];
              var i22 = cube.striIndicesMarchCube[offs + indTri + 2];
              if (!this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i22])) {
                return 0 - 2;
              }
            }
            indCell++;
          }
        }
      }
      return 0;
    }
  }, {
    key: "getNumIntersectedCells",
    value: function getNumIntersectedCells(side, numCells, corners, cube) {
      var side2 = side * side;
      var cNumVerts = 8;
      var numIntersectedCells = 0;
      var indCell = 0;
      var indY = 0;
      for (var y2 = 0; y2 < numCells; y2++, indY += side2) {
        var indZ = 0;
        for (var z2 = 0; z2 < numCells; z2++, indZ += side) {
          for (var x2 = 0; x2 < numCells; x2++) {
            var cubeValuesIndex = indCell * (2 << 2 + 2) + 24;
            var indCorner = x2 + indZ + indY;
            cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner];
            cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
            cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
            cube.pointsValuesLinear[cubeValuesIndex + 3] = corners[indCorner + side];
            cube.pointsValuesLinear[cubeValuesIndex + 4] = corners[side2 + indCorner];
            cube.pointsValuesLinear[cubeValuesIndex + 5] = corners[side2 + indCorner + 1];
            cube.pointsValuesLinear[cubeValuesIndex + 6] = corners[side2 + indCorner + side + 1];
            cube.pointsValuesLinear[cubeValuesIndex + 7] = corners[side2 + indCorner + side];
            var bitsInside = 0;
            for (var i2 = 0; i2 < cNumVerts; ++i2) {
              if (cube.pointsValuesLinear[cubeValuesIndex + i2] < 0) {
                bitsInside |= 1 << i2;
              }
            }
            if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
              cube.hasIntersection[indCell] = false;
            } else {
              cube.hasIntersection[indCell] = true;
              numIntersectedCells++;
            }
            cube.bitsInside[indCell] = bitsInside;
            indCell++;
          }
        }
      }
      return numIntersectedCells;
    }
  }, {
    key: "getType",
    value: function getType(letter) {
      var atomT = [0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20, 6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6, 30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39, 6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6, 49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58, 6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6, 68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77, 6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6, 87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96, 6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105, 6, 106, 6, 107, 6, 108, 6, 109, 6];
      if (letter < 1 || letter > atomT.length / 2 || Object.keys(Element$9.ByAtomicNumber).length * 2 !== atomT.length) {
        throw new Error("atomT.length  should be equal Element.ByAtomicNumber.length * 2");
      }
      return atomT[letter * 2];
    }
  }, {
    key: "calculateGridCorners",
    value: function calculateGridCorners(corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
      var side2 = side * side;
      var side3 = side2 * side;
      var vCorner = new Vector3();
      var vDif = new Vector3();
      var aLot = 1e12;
      for (var i2 = 0; i2 < side3; i2++) {
        corners[i2] = aLot;
      }
      var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
      var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
      var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
      for (var s2 = 0, numAtoms = atoms.length; s2 < numAtoms; s2++) {
        var atom = atoms[s2];
        var radius = atom.radius + probeRad;
        var fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
        var fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
        var fz = (atom.coord.z - radius - vBoxMin.z) * zScale;
        var indXMin = Math.floor(fx);
        var indYMin = Math.floor(fy);
        var indZMin = Math.floor(fz);
        var indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
        var indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
        var indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);
        indXMax++;
        indYMax++;
        indZMax++;
        indXMax = indXMax <= side - 1 ? indXMax : side - 1;
        indYMax = indYMax <= side - 1 ? indYMax : side - 1;
        indZMax = indZMax <= side - 1 ? indZMax : side - 1;
        for (var y2 = indYMin; y2 <= indYMax; y2++) {
          var indY = y2 * side2;
          for (var z2 = indZMin; z2 <= indZMax; z2++) {
            var indZ = z2 * side;
            for (var x2 = indXMin; x2 <= indXMax; x2++) {
              var ind = indY + indZ + x2;
              this.getCornerCoord(vBoxMin, vBoxMax, x2, y2, z2, side, vCorner);
              vDif.x = vCorner.x - atom.coord.x;
              vDif.y = vCorner.y - atom.coord.y;
              vDif.z = vCorner.z - atom.coord.z;
              var distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z);
              var val = distToSphere - radius;
              if (val < corners[ind]) {
                corners[ind] = val;
              }
            }
          }
        }
      }
    }
  }, {
    key: "createVertexHash",
    value: function createVertexHash(maxNumVertices, maxNumTriangles) {
      this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);
      if (this.hashLines === null) {
        return 0 - 1;
      }
      for (var i2 = 0, j2 = 0; i2 < HASH_SIZE; i2++) {
        this.hashLines[j2++] = 0;
        this.hashLines[j2++] = 0 - 1;
      }
      this.maxNumVertices = maxNumVertices;
      this.maxNumTriangles = maxNumTriangles;
      this.numHashEtriesAllocated = maxNumVertices;
      this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);
      if (this.hashEntries === null) {
        return 0 - 1;
      }
      for (var _i6 = 0, _j2 = 0; _i6 < this.numHashEtriesAllocated; _i6++) {
        this.hashEntries[_j2++] = 0 - 1;
        this.hashEntries[_j2++] = 0 - 1;
      }
      this.numHashEntryIndex = 0;
      return 0;
    }
  }, {
    key: "getNewHashEntry",
    value: function getNewHashEntry() {
      if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
        var i2 = this.numHashEntryIndex;
        this.numHashEntryIndex++;
        return i2;
      }
      return 0 - 1;
    }
  }, {
    key: "addVertexToGeo",
    value: function addVertexToGeo(geoOut, vAdd) {
      var entry;
      var oneHynberes = 0.01;
      var n815851 = 815851;
      var n37633 = 37633;
      var n2453543 = 2453543;
      var r106 = 1e-6;
      var hashResolution = this.marCubeResoultion << 2;
      var v2 = new Vector3();
      var ix = Math.floor(hashResolution * (vAdd.x - this.vBoxMin.x) / (this.vBoxMax.x + oneHynberes - this.vBoxMin.x));
      var iy = Math.floor(hashResolution * (vAdd.y - this.vBoxMin.y) / (this.vBoxMax.y + oneHynberes - this.vBoxMin.y));
      var iz = Math.floor(hashResolution * (vAdd.z - this.vBoxMin.z) / (this.vBoxMax.z + oneHynberes - this.vBoxMin.z));
      var iHash = ix * n815851 + iz * n37633 + iy * n2453543;
      iHash &= HASH_SIZE - 1;
      var hLineIndex = iHash + iHash;
      if (this.vBoxMin !== null && this.vBoxMax !== null) {
        for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
          var ind = this.hashEntries[entry * 2 + 0];
          v2.copy(geoOut._vertices[ind]);
          v2.x -= vAdd.x;
          v2.y -= vAdd.y;
          v2.z -= vAdd.z;
          var dot2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
          if (dot2 < r106) {
            return ind;
          }
        }
      }
      if (geoOut._numVertices >= this.maxNumVertices) {
        return 0 - 1;
      }
      var iVertAdd = geoOut._numVertices;
      geoOut._vertices[iVertAdd].copy(vAdd);
      if (this.vBoxMin !== null && this.vBoxMax !== null) {
        entry = this.getNewHashEntry();
        if (entry < 0) {
          return 0 - 1;
        }
        var entryFirst = this.hashLines[hLineIndex + 1];
        this.hashLines[hLineIndex + 1] = entry;
        this.hashEntries[entry * 2 + 0] = iVertAdd;
        this.hashEntries[entry * 2 + 1] = entryFirst;
        this.hashLines[hLineIndex + 0]++;
      }
      geoOut._numVertices++;
      return iVertAdd;
    }
  }, {
    key: "modifyExcludedFromGeo",
    value: function modifyExcludedFromGeo(side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
      var ind;
      var distToSphere;
      var distToBorder;
      var r11 = 1.1;
      function innerBlockWorkAround() {
        if (distToBorder > 0) {
          if (corners[ind] < 0) {
            corners[ind] = distToBorder;
          }
          if (distToBorder > corners[ind]) {
            corners[ind] = distToBorder;
          }
        } else if (distToBorder > corners[ind]) {
          corners[ind] = distToBorder;
        }
      }
      var side2 = side * side;
      var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
      var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
      var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
      var probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
      var sideInv = 1 / (side - 1);
      for (var i2 = 0; i2 < geoOut._numVertices; i2++) {
        var vCenter = geoOut._vertices[i2];
        var radEst = probeSphereRadius * r11;
        var indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
        var indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
        var indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);
        var indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
        var indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
        var indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);
        indXMin = indXMin >= 0 ? indXMin : 0;
        indYMin = indYMin >= 0 ? indYMin : 0;
        indZMin = indZMin >= 0 ? indZMin : 0;
        indXMax = indXMax <= side - 1 ? indXMax : side - 1;
        indYMax = indYMax <= side - 1 ? indYMax : side - 1;
        indZMax = indZMax <= side - 1 ? indZMax : side - 1;
        for (var iy = indYMin; iy <= indYMax; iy++) {
          var indY = iy * side2;
          for (var iz = indZMin; iz <= indZMax; iz++) {
            var indZ = iz * side;
            for (var ix = indXMin; ix <= indXMax; ix++) {
              ind = indY + indZ + ix;
              var t2 = ix * sideInv;
              var xCorner = vBoxMin.x * (1 - t2) + vBoxMax.x * t2;
              t2 = iy * sideInv;
              var yCorner = vBoxMin.y * (1 - t2) + vBoxMax.y * t2;
              t2 = iz * sideInv;
              var zCorner = vBoxMin.z * (1 - t2) + vBoxMax.z * t2;
              var dx = xCorner - vCenter.x;
              var dy = yCorner - vCenter.y;
              var dz = zCorner - vCenter.z;
              var dist2 = dx * dx + dy * dy + dz * dz;
              if (dist2 < probeSpRad2) {
                distToSphere = Math.sqrt(dist2);
                distToBorder = -(distToSphere - probeSphereRadius);
                innerBlockWorkAround();
              }
            }
          }
        }
      }
      return 0;
    }
  }, {
    key: "_innerBuild",
    value: function _innerBuild() {
      var ok;
      var expandFactor = 1.2;
      var packedArrays = {
        posRad: this._posRad,
        colors: this._colors,
        atoms: this._opts.atoms
      };
      this.complex = this._opts.parent;
      this.atoms = packedArrays.atoms;
      this.meshResolution = this._opts.gridSpacing;
      this.atomRadiusScale = this._opts.radScale;
      this.colorMode = this._opts.colorMode;
      this.probeRadius = this._opts.probeRadius;
      this.useVertexColors = true;
      this.excludeProbe = this._opts.excludeProbe;
      this.visibilitySelector = this._opts.visibilitySelector;
      this.geoOut = null;
      this.hashLines = null;
      this.hashEntries = null;
      this.numHashEtriesAllocated = 0;
      this.numHashEntryIndex = 0;
      this.maxNumVertices = 0;
      this.maxNumTriangles = 0;
      var atomsColored = new Array(this.atoms.length);
      this.convertToAtomsColored(packedArrays, atomsColored);
      var vBoxMin = this.vBoxMin = new Vector3();
      var vBoxMax = this.vBoxMax = new Vector3();
      this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);
      var marCubeResoultion = this.marCubeResoultion = this.meshResolution * (2 + 2);
      var side = marCubeResoultion;
      var side2 = side * side;
      var side3 = side2 * side;
      var corners = utils.allocateTyped(Float32Array, side3);
      var rProbeRadius = this.probeRadius * this.atomRadiusScale;
      this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
      var numCells = marCubeResoultion - 1;
      var cube = new IsoSurfaceMarchCube();
      ok = cube.create(numCells);
      if (ok < 0) {
        return ok;
      }
      var vCellStep = new Vector3();
      vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
      vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
      vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;
      var numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
      var maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
      var maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
      this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
      ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
      if (ok < 0) {
        return ok;
      }
      var probeRadForNormalsColors = rProbeRadius;
      if (this.excludeProbe) {
        probeRadForNormalsColors = 0.01;
      }
      this.voxelWorld = new IsosurfaceBuildNormals(atomsColored.length, atomsColored, vBoxMin, vBoxMax, probeRadForNormalsColors);
      this.voxelWorld.createVoxels();
      ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube);
      if (this.excludeProbe) {
        this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners);
        this.geoOut._vertices = null;
        this.geoOut._colors = null;
        this.geoOut._indices = null;
        this.geoOut._normals = null;
        this.geoOut._numVertices = 0;
        this.geoOut._numTriangles = 0;
        this.geoOut = null;
        numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
        maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
        maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
        this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
        ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
        if (ok < 0) {
          return ok;
        }
        ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube);
      }
      this.voxelWorld.buildNormals(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._normals);
      var radiusColorSmoothness = 6.5;
      if (this.excludeProbe) {
        radiusColorSmoothness -= 1.5;
      }
      if (this.useVertexColors) {
        this.voxelWorld.buildColors(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._colors, radiusColorSmoothness);
      }
      this.voxelWorld.destroyVoxels();
      this.voxelWorld = null;
      cube.destroy();
      return ok;
    }
  }]);
  return SSIsosurfaceGeometry2;
}(IsoSurfaceGeometry);
function _createSuper$1y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1y() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function createLabel(fieldTxt, className) {
  var text = document.createElement("div");
  text.className = className;
  if (typeof fieldTxt === "string") {
    var spanText = document.createElement("span");
    spanText.style.fontSize = "150%";
    var strings = fieldTxt.split("\n");
    for (var i2 = 0, n2 = strings.length; i2 < n2; ++i2) {
      var spanNodeP = document.createElement("span");
      var spanNodeText = document.createTextNode(strings[i2]);
      spanNodeP.appendChild(spanNodeText);
      spanText.appendChild(spanNodeP);
      if (i2 < n2 - 1) {
        spanText.appendChild(document.createElement("br"));
      }
    }
    text.appendChild(spanText);
  } else {
    text.appendChild(fieldTxt);
  }
  text.worldPos = new Vector3();
  return text;
}
var LabelsGeometry = function(_EventDispatcher) {
  _inherits(LabelsGeometry2, _EventDispatcher);
  var _super = _createSuper$1y(LabelsGeometry2);
  function LabelsGeometry2(instanceCount, opts) {
    var _this;
    _classCallCheck(this, LabelsGeometry2);
    _this = _super.call(this);
    _this._opts = opts;
    _this.items = [];
    _this.needsUpdate = false;
    var xTranslation = -50;
    var yTranslation = -50;
    switch (opts.horizontalAlign) {
      case "left":
        xTranslation = 0;
        break;
      case "right":
        xTranslation = -100;
        break;
    }
    switch (opts.verticalAlign) {
      case "top":
        yTranslation = -100;
        break;
      case "bottom":
        yTranslation = 0;
        break;
    }
    var deltaPos = new Vector3(opts.dx || 0, opts.dy || 0, opts.dz || 0);
    _this.userData = {
      translation: "translate(".concat(xTranslation, "%, ").concat(yTranslation, "%)"),
      offset: deltaPos
    };
    return _this;
  }
  _createClass(LabelsGeometry2, [{
    key: "setItem",
    value: function setItem(itemIdx, itemPos, fieldTxt) {
      var opts = this._opts;
      var text = this.items[itemIdx] || createLabel(fieldTxt, "label");
      text.worldPos.copy(itemPos);
      text.style.textAlign = opts.horizontalAlign;
      text.style.verticalAlign = opts.verticalAlign;
      this.items[itemIdx] = text;
    }
  }, {
    key: "setColor",
    value: function setColor(itemIdx, fColor, bColor) {
      var text = this.items[itemIdx];
      text.opts = {
        color: fColor,
        background: bColor
      };
    }
  }, {
    key: "startUpdate",
    value: function startUpdate() {
      return true;
    }
  }, {
    key: "finishUpdate",
    value: function finishUpdate() {
      this.needsUpdate = true;
      this.dispatchEvent({
        type: "update"
      });
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.finishUpdate();
    }
  }, {
    key: "raycast",
    value: function raycast() {
    }
  }, {
    key: "setOpacity",
    value: function setOpacity() {
    }
  }, {
    key: "getSubset",
    value: function getSubset2() {
      return [];
    }
  }]);
  return LabelsGeometry2;
}(EventDispatcher2);
var geometries = {
  InstancedSpheresGeometry,
  SimpleSpheresGeometry,
  Simple2CCylindersGeometry,
  Instanced2CCylindersGeometry,
  ExtrudedObjectsGeometry,
  ChunkedLinesGeometry,
  TwoColorLinesGeometry,
  CrossGeometry,
  QuickSurfGeometry,
  ContactSurfaceGeometry,
  SSIsosurfaceGeometry,
  LabelsGeometry
};
var vertexShader = "float INSTANCED_SPRITE_OVERSCALE = 1.3;\r\n\r\nattribute vec3 normal;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec4 position; // W contains vert pos or neg offset\r\n#else\r\n  attribute vec3 position;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition;\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  attribute float alphaColor;\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n	#if NUM_DIR_LIGHTS > 0\r\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n		varying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n	#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  attribute vec3 color;\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  attribute vec3 color2;\r\n  varying vec3 vColor2;\r\n  attribute vec2 uv;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_POS\r\n  attribute vec4 offset;\r\n  #ifdef SPHERE_SPRITE\r\n    varying vec4 instOffset;\r\n  varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  attribute vec4 matVector1;\r\n  attribute vec4 matVector2;\r\n  attribute vec4 matVector3;\r\n  attribute vec4 invmatVector1;\r\n  attribute vec4 invmatVector2;\r\n  attribute vec4 invmatVector3;\r\n\r\n  #ifdef CYLINDER_SPRITE\r\n    varying vec4 matVec1;\r\n    varying vec4 matVec2;\r\n    varying vec4 matVec3;\r\n    varying vec4 invmatVec1;\r\n    varying vec4 invmatVec2;\r\n    varying vec4 invmatVec3;\r\n    varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\nuniform mat4 modelViewMatrix; // optional\r\nuniform mat4 projectionMatrix; // optional\r\nuniform mat3 normalMatrix; // optional\r\nuniform mat4 modelMatrix; // optional\r\n\r\n#ifdef DASHED_LINE\r\n  attribute float lineDistance;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec3 direction;\r\n  uniform mat4 projMatrixInv;\r\n  uniform vec2 viewport;\r\n  uniform float lineWidth;\r\n\r\n  vec4 transform(vec4 coord){\r\n    return projectionMatrix * modelViewMatrix * coord;\r\n  }\r\n\r\n  vec2 project(vec4 device){\r\n    vec3 device_normal = device.xyz/device.w;\r\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r\n    return clip_pos * viewport;\r\n  }\r\n\r\n  vec4 unproject(vec2 screen, float z, float w){\r\n    vec2 clip_pos = screen/viewport;\r\n    vec2 device_normal = clip_pos*2.0-1.0;\r\n    return vec4(device_normal*w, z, w);\r\n  }\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  alphaCol = alphaColor;\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  vec3 objectNormal = vec3(\r\n    dot(normal, matVector1.xyz),\r\n    dot(normal, matVector2.xyz),\r\n    dot(normal, matVector3.xyz));\r\n#else\r\n  vec3 objectNormal = vec3( normal );\r\n#endif\r\n\r\nvec3 transformedNormal = normalMatrix * objectNormal;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  vNormal = normalize(transformedNormal);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r\n#endif\r\n\r\n  vec4 localPos = vec4(position.xyz, 1.0);\r\n  vec4 worldPos = modelMatrix * localPos;\r\n  vec4 mvPosition = modelViewMatrix * localPos;\r\n\r\n// make thick line offset\r\n#ifdef THICK_LINE\r\n   // get screen pos\r\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\r\n   vec2 sPos = project(dPos);\r\n   // move pos forward\r\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\r\n   // get screen offset pos\r\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r\n   vec2 sPos2 = project(dPos2);\r\n   // screen line direction\r\n   vec2 sDir = normalize(sPos2 - sPos);\r\n   // vertex offset (orthogonal to line direction)\r\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\r\n   // move screen vertex\r\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r\n   // get moved pos in view space\r\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r\n#endif // THICK_LINE\r\n\r\n#ifdef INSTANCED_POS\r\n  #ifdef SPHERE_SPRITE\r\n    instOffset = offset;\r\n\r\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r\n    float scale = length(modelViewMatrix[0]);\r\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r\n    posEye.w = offset.w * scale;\r\n\r\n    spritePosEye = posEye;\r\n #else\r\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  #ifdef CYLINDER_SPRITE\r\n    matVec1 = matVector1;\r\n    matVec2 = matVector2;\r\n    matVec3 = matVector3;\r\n    invmatVec1 = invmatVector1;\r\n    invmatVec2 = invmatVector2;\r\n    invmatVec3 = invmatVector3;\r\n\r\n    // calculate eye coords of cylinder endpoints\r\n    vec4 v = vec4(0, -0.5, 0, 1);\r\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n    v.y = 0.5;\r\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n\r\n    // sprite is placed at the center of cylinder\r\n    vec4 posEye;\r\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r\n    posEye.w = 1.0;\r\n    spritePosEye = posEye;\r\n\r\n    // cylinder radius in eye space\r\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r\n    vec2 spriteSize;\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // In ortho projection we skip z coordinate\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\r\n\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\r\n    #else\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r\n\r\n      // full sprite size in eye coords\r\n      float minZ = min(abs(p1.z), abs(p2.z));\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\r\n    #endif\r\n\r\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r\n  #else\r\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n  gl_Position = projectionMatrix * mvPosition;\r\n\r\n  vWorldPosition = worldPos.xyz;\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n	#if NUM_DIR_LIGHTS > 0\r\n	  vec4 worldPosition;\r\n	  // see THREE.WebGLProgram.unrollLoops\r\n	  #pragma unroll_loop_start\r\n	  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\r\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\r\n	  }\r\n	  #pragma unroll_loop_end\r\n	#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  vColor = color.xyz;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  vColor2 = color2;\r\n  #ifndef CYLINDER_SPRITE\r\n    vUv = uv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef DASHED_LINE\r\n  vLineDistance = lineDistance;\r\n#endif\r\n}\r\n";
var fragmentShader$6 = "#if defined (NORMALS_TO_G_BUFFER)\r\n  #define fragColor gl_FragData[0]\r\n#else\r\n  #define fragColor gl_FragColor\r\n#endif\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  uniform mat4 world2colorMatrix;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n	#if NUM_DIR_LIGHTS > 0\r\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\r\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n		varying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\r\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\r\n\r\n    #ifdef SHADOWMAP_PCF_RAND\r\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\r\n      // unroll_loop and unroll_loop has pattern:\r\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\r\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n      uniform sampler2D noiseTex;\r\n      uniform vec2 noiseTexelSize;\r\n      uniform vec2 srcTexelSize;\r\n      uniform mat4 projectionMatrix;\r\n    #endif\r\n	#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  varying vec3 vColor2;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform vec3 fixedColor;\r\nuniform float opacity;\r\nuniform float zClipValue;\r\nuniform float clipPlaneValue;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n#ifdef USE_FOG\r\n  uniform vec3 fogColor;\r\n  uniform float fogAlpha;\r\n  uniform float fogNear;\r\n  uniform float fogFar;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r\nvarying vec3 vViewPosition;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n  uniform float nearPlaneValue;\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 spritePosEye;\r\n#endif\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  uniform float zOffset;\r\n\r\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\r\n    uniform mat4 projectionMatrix;\r\n  #endif\r\n\r\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r\n  }\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 instOffset;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n\r\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, origin);\r\n    float c = dot(origin, origin) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point inside frustum\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\r\n      // t1 is always smaller than t2 (from calculations)\r\n      point = p1;\r\n      frontFaced = 1.0;\r\n      return true;\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into sphere local coords\r\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\r\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\r\n\r\n      // transform camera orientation vector into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into sphere local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\r\n\r\n      // transform vector from camera pos to curPixel into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  varying vec4 matVec1;\r\n  varying vec4 matVec2;\r\n  varying vec4 matVec3;\r\n  varying vec4 invmatVec1;\r\n  varying vec4 invmatVec2;\r\n  varying vec4 invmatVec3;\r\n\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  varying vec4 spritePosEye;\r\n\r\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray.xz, ray.xz);\r\n    float b = dot(ray.xz, origin.xz);\r\n    float c = dot(origin.xz, origin.xz) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    float halfHeight = 0.5;\r\n\r\n    // choose nearest point\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\r\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\r\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n    vec4 v;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform camera orientation vector into cylinder local coords\r\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into cylinder local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform vector from camera pos to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\r\nconst float ShiftRight8 = 1. / 256.;\r\n\r\nvec4 packDepthToRGBA( const in float v ) {\r\n  vec4 r = vec4( fract( v * PackFactors ), v );\r\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n  return r * PackUpscale;\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n  return dot( v, UnpackFactors );\r\n}\r\n\r\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\r\n#ifdef TOON_SHADING\r\n  #define LOW_TOON_BORDER 0.0\r\n  #define MEDIUM_TOON_BORDER 0.7\r\n  #define HIGH_TOON_BORDER 1.0\r\n\r\n  #define MEDIUM_TOON_RANGE 0.5\r\n  #define HIGH_TOON_RANGE 0.95\r\n#endif\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  struct ReflectedLight {\r\n    vec3 directDiffuse;\r\n    vec3 directSpecular;\r\n    vec3 indirectDiffuse;\r\n  };\r\n\r\n  struct BlinnPhongMaterial {\r\n    vec3  diffuseColor;\r\n    vec3  specularColor;\r\n    float specularShininess;\r\n  };\r\n\r\n  struct GeometricContext {\r\n    vec3 normal;\r\n    vec3 viewDir;\r\n  };\r\n\r\n  struct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n  };\r\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n  struct DirectionalLightShadow {\r\n     vec2 shadowMapSize;\r\n     float shadowBias;\r\n     float shadowRadius;\r\n   };\r\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\r\n\r\n  uniform vec3 ambientLightColor;\r\n\r\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\r\n\r\n  #if defined(SHADOWMAP)\r\n  	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n  		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n  	}\r\n\r\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\r\n   	  float shadow = 0.0;\r\n\r\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\r\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\r\n      shadowCoord.xyz /= shadowCoord.w;\r\n\r\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n      bool inFrustum = all( inFrustumVec );\r\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n      bool frustumTest = all( frustumTestVec );\r\n\r\n      if ( frustumTest ) {\r\n        #ifdef SHADOWMAP_BASIC\r\n      	  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n      	#endif\r\n\r\n      	#ifdef SHADOWMAP_PCF_SHARP\r\n      	  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\r\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\r\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\r\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\r\n\r\n            shadow = (\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n            ) * ( 1.0 / 9.0 );\r\n        #endif\r\n\r\n        #ifdef SHADOWMAP_PCF_RAND\r\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\r\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\r\n\r\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\r\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\r\n\r\n          vec2 offset;\r\n          #pragma unroll_loop_start\r\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\r\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\r\n          }\r\n          #pragma unroll_loop_end\r\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n        #endif\r\n      }\r\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\r\n   }\r\n  #endif\r\n\r\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\r\n\r\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n    return RECIPROCAL_PI * diffuseColor;\r\n  } // validated\r\n\r\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n    // Original approximation by Christophe Schlick '94\r\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\r\n  } // validated\r\n\r\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n    return 0.25;\r\n  }\r\n\r\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n  }\r\n\r\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\r\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r\n\r\n    vec3 F = F_Schlick( specularColor, dotLH );\r\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n    float D = D_BlinnPhong( shininess, dotNH );\r\n\r\n    return F * ( G * D );\r\n  } // validated\r\n\r\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\r\n\r\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r\n    #ifdef TOON_SHADING\r\n      if(dotNL < MEDIUM_TOON_RANGE){\r\n        dotNL = LOW_TOON_BORDER;\r\n      }\r\n      else if(dotNL < HIGH_TOON_RANGE){\r\n        dotNL = MEDIUM_TOON_BORDER;\r\n      }\r\n      else{\r\n        dotNL = HIGH_TOON_BORDER;\r\n      }\r\n    #endif\r\n\r\n    vec3 irradiance = dotNL * directLight.color * PI;\r\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r\n  }\r\n\r\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n  }\r\n\r\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r\n    vec3 irradiance = ambientLightColor * PI;\r\n\r\n    float shadowMask = 1.0;\r\n    // see THREE.WebGLProgram.unrollLoops\r\n  	#pragma unroll_loop_start\r\n  	  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n  	    #ifdef SHADOWMAP\r\n  	      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\r\n        #endif\r\n\r\n  		  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\r\n  		}\r\n  		#pragma unroll_loop_end\r\n\r\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r\n\r\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r\n#ifdef DASHED_LINE\r\n  uniform float dashedLineSize;\r\n  uniform float dashedLinePeriod;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef CLIP_PLANE\r\n  if (vViewPosition.z < clipPlaneValue) discard;\r\n#endif\r\n\r\n#ifdef ZCLIP\r\n  if (vViewPosition.z < zClipValue) discard;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n  #if NUM_DIR_LIGHTS > 0\r\n    // see THREE.WebGLProgram.unrollLoops\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\r\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n#endif\r\n\r\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r\n  vec4 pixelPosEye;\r\n\r\n#ifdef SPHERE_SPRITE\r\n\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  vec3 normal;\r\n\r\n/* quick-and-dirty method\r\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r\n  float r2 = dot(normal.xy, normal.xy);\r\n  if (r2 > 1.0) discard;\r\n  float normalZ = sqrt(1.0 - r2);\r\n  normal.z = normalZ;\r\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n  pixelPosEye.z += spritePosEye.w * normalZ;\r\n*/\r\n\r\n  // ray-trace sphere surface\r\n  {\r\n    vec3 p;\r\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\r\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n    normal = normalize(normalMatrix * p);\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  vec3 normal;\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  float cylinderY = 0.0;\r\n\r\n  // ray-trace cylinder surface\r\n  {\r\n    vec3 p;\r\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\r\n\r\n    cylinderY = 0.5 * (p.y + 1.0);\r\n\r\n    vec4 v = vec4(p, 1.0);\r\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n\r\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r\n    normal = vec3(\r\n      dot(localNormal, matVec1.xyz),\r\n      dot(localNormal, matVec2.xyz),\r\n      dot(localNormal, matVec3.xyz));\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n\r\n    normal = normalize(normalMatrix * normal);\r\n  }\r\n#endif\r\n\r\n  #ifdef ATTR_COLOR\r\n    vec3 vertexColor = vColor;\r\n  #else\r\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r\n  #endif\r\n\r\n  #ifdef ATTR_COLOR2\r\n    #ifdef CYLINDER_SPRITE\r\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r\n    #else\r\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r\n    #endif\r\n      // choose either color or color2\r\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r\n  #endif\r\n\r\n  // negative red component is a special condition\r\n  if (vertexColor.x < 0.0) discard;\r\n\r\n  #ifdef DASHED_LINE\r\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r\n  #endif\r\n\r\n  // transparency prepass writes only z, so we don't need to calc the color\r\n  #ifdef PREPASS_TRANSP\r\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n    #endif\r\n    return;\r\n  #endif\r\n\r\n    float totalOpacity = opacity;\r\n\r\n  #ifdef ATTR_ALPHA_COLOR\r\n    totalOpacity *= alphaCol;\r\n  #endif\r\n\r\n  // discard fully transparent pixels\r\n  if (totalOpacity == 0.0) discard;\r\n\r\n  #ifdef FAKE_OPACITY\r\n    // discard pixels in checker pattern\r\n    vec2 dm_coord = floor(gl_FragCoord.xy);\r\n    dm_coord = fract(dm_coord * 0.5);\r\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r\n    vec4 diffuseColor = vec4(diffuse, 1.0);\r\n  #else\r\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\r\n  #endif\r\n\r\n  float flipNormal;\r\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n    flipNormal = 1.0;\r\n    #ifdef DOUBLE_SIDED\r\n      flipNormal = float( gl_FrontFacing );\r\n    #endif\r\n    vec3 normal = normalize( vNormal ) * flipNormal;\r\n  #endif\r\n\r\n    diffuseColor.rgb *= vertexColor;\r\n\r\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n  #endif\r\n\r\n  #ifdef NORMALS_TO_G_BUFFER\r\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n      vec3 viewNormaInColor = viewNormalSprites;\r\n    #else\r\n      vec3 viewNormaInColor = viewNormal;\r\n      float frontFaced = float( gl_FrontFacing );\r\n    #endif\r\n    // [-1, 1] -> [0, 1]\r\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\r\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\r\n  #endif\r\n\r\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n    vec3 viewDir;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      viewDir = -pixelPosEye.xyz;\r\n    #else\r\n      viewDir = vViewPosition;\r\n    #endif\r\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\r\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\r\n  #else\r\n    vec3 outgoingLight = diffuseColor.rgb;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_DEPTH\r\n    float depth = 0.0;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n      depth = gl_FragDepthEXT;\r\n    #else\r\n      depth = gl_FragCoord.z;\r\n    #endif\r\n    fragColor = packDepthToRGBA(depth);\r\n    return;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_POS\r\n    fragColor = world2colorMatrix * pixelPosWorld;\r\n  #else\r\n    #ifdef OVERRIDE_COLOR\r\n      fragColor = vec4(fixedColor, diffuseColor.a);\r\n    #else\r\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r\n    #endif\r\n\r\n    #ifdef USE_FOG\r\n      float viewDistance;\r\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n        viewDistance = abs(pixelPosEye.z);\r\n      #else\r\n        viewDistance = vViewPosition.z;\r\n      #endif\r\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r\n      #ifdef FOG_TRANSPARENT\r\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\r\n      #else\r\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r\n      #endif\r\n    #endif\r\n\r\n  #endif\r\n}\r\n";
var capabilities = {
  precision: "mediump",
  init: function init(renderer) {
    this.precision = renderer.capabilities.getMaxPrecision("highp");
  }
};
var noiseWidth = 4;
var noiseHeight = 4;
var _noiseData = new Uint8Array([24, 52, 0, 254, 145, 0, 122, 0, 0, 7, 170, 0, 34, 214, 0, 173, 8, 0, 86, 249, 0, 160, 4, 0, 226, 46, 0, 224, 211, 0, 3, 157, 0, 174, 247, 0, 12, 182, 0, 220, 216, 0, 1, 109, 0, 253, 154, 0]);
var _noiseWrapS = RepeatWrapping;
var _noiseWrapT = RepeatWrapping;
var _noiseMinFilter = NearestFilter;
var _noiseMagFilter = NearestFilter;
var _noiseMapping = UVMapping;
var noiseTexture = new DataTexture(_noiseData, noiseWidth, noiseHeight, RGBFormat, UnsignedByteType, _noiseMapping, _noiseWrapS, _noiseWrapT, _noiseMagFilter, _noiseMinFilter, 1);
noiseTexture.needsUpdate = true;
var noise = {
  noiseWidth,
  noiseHeight,
  noiseTexture
};
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1x(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1x();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1x() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _samplesKernel$1 = [new Vector2(-0.541978, 0.840393), new Vector2(0.125533, -0.992089), new Vector2(0.374329, 0.927296), new Vector2(-0.105475, 0.994422)];
var defaultUniforms = UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights, {
  diffuse: {
    value: new Color(15658734)
  },
  opacity: {
    value: 1
  },
  specular: {
    type: "c",
    value: new Color(1118481)
  },
  shininess: {
    type: "f",
    value: 30
  },
  fixedColor: {
    type: "c",
    value: new Color(16777215)
  },
  zOffset: {
    type: "f",
    value: 0
  },
  zClipValue: {
    type: "f",
    value: 0
  },
  clipPlaneValue: {
    type: "f",
    value: 0
  },
  nearPlaneValue: {
    type: "f",
    value: -0.5
  },
  invModelViewMatrix: {
    type: "4fv",
    value: new Matrix4()
  },
  world2colorMatrix: {
    type: "4fv",
    value: new Matrix4()
  },
  dashedLineSize: {
    type: "f",
    value: 0.1
  },
  dashedLinePeriod: {
    type: "f",
    value: 0.2
  },
  projMatrixInv: {
    type: "4fv",
    value: new Matrix4()
  },
  viewport: {
    type: "v2",
    value: new Vector2()
  },
  lineWidth: {
    type: "f",
    value: 2
  },
  fogAlpha: {
    type: "f",
    value: 1
  },
  samplesKernel: {
    type: "v2v",
    value: null
  },
  noiseTex: {
    type: "t",
    value: null
  },
  noiseTexelSize: {
    type: "v2",
    value: null
  },
  srcTexelSize: {
    type: "v2",
    value: null
  }
}]);
var uberOptionNames = ["shininess", "opacity", "zOffset", "diffuse", "specular", "fixedColor", "zClipCoef", "zClipValue", "clipPlaneValue", "world2colorMatrix", "dashedLineSize", "dashedLinePeriod", "projMatrixInv", "viewport", "lineWidth", "fogAlpha", "samplesKernel", "noiseTex", "noiseTexelSize", "srcTexelSize"];
var uberOptions = {
  diffuse: new Color(16777215),
  specular: new Color(1118481),
  shininess: 30,
  opacity: 1,
  fixedColor: new Color(16777215),
  zOffset: 0,
  zClipCoef: 2,
  zClipValue: 0,
  clipPlaneValue: 0,
  world2colorMatrix: new Matrix4(),
  dashedLineSize: 0.1,
  dashedLinePeriod: 0.3,
  projMatrixInv: new Matrix4(),
  viewport: new Vector2(800, 600),
  lineWidth: 2,
  fogAlpha: 1,
  samplesKernel: _samplesKernel$1,
  noiseTex: noise.noiseTexture,
  noiseTexelSize: new Vector2(1 / noise.noiseWidth, 1 / noise.noiseHeight),
  srcTexelSize: new Vector2(1 / 800, 1 / 600),
  copy: function copy(source) {
    this.diffuse.copy(source.diffuse);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.opacity = source.opacity;
    this.fixedColor.copy(source.fixedColor);
    this.zOffset = source.zOffset;
    this.zClipCoef = source.zClipCoef;
    this.zClipValue = source.zClipValue;
    this.clipPlaneValue = source.clipPlaneValue;
    this.world2colorMatrix.copy(source.world2colorMatrix);
    this.dashedLineSize = source.dashedLineSize;
    this.dashedLinePeriod = source.dashedLinePeriod;
    this.projMatrixInv = source.projMatrixInv;
    this.viewport = source.viewport;
    this.lineWidth = source.lineWidth;
    this.toonShading = source.toonShading;
    this.fogAlpha = source.fogAlpha;
    this.samplesKernel = source.samplesKernel;
    this.noiseTex = source.noiseTex;
    this.noiseTexelSize = source.noiseTexelSize;
    this.srcTexelSize = source.srcTexelSize;
  }
};
var UberMaterial = function(_RawShaderMaterial) {
  _inherits(UberMaterial2, _RawShaderMaterial);
  var _super = _createSuper$1x(UberMaterial2);
  function UberMaterial2(params) {
    var _this;
    _classCallCheck(this, UberMaterial2);
    _this = _super.call(this, params);
    _this.fog = true;
    _this.instancedPos = false;
    _this.instancedMatrix = false;
    _this.attrColor = false;
    _this.attrColor2 = false;
    _this.attrAlphaColor = false;
    _this.overrideColor = false;
    _this.sphereSprite = false;
    _this.cylinderSprite = false;
    _this.zClip = false;
    _this.clipPlane = false;
    _this.fakeOpacity = false;
    _this.prepassTransparancy = false;
    _this.colorFromPos = false;
    _this.shadowmap = false;
    _this.shadowmapType = "random";
    _this.colorFromDepth = false;
    _this.orthoCam = false;
    _this.dashedLine = false;
    _this.transparent = true;
    _this.thickLine = false;
    _this.fogTransparent = false;
    _this.normalsToGBuffer = false;
    _this.toonShading = false;
    _this.uberOptions = uberOptions;
    _this.setValues(_objectSpread({
      uniforms: UniformsUtils.clone(defaultUniforms),
      vertexShader: _this.precisionString() + vertexShader,
      fragmentShader: _this.precisionString() + fragmentShader$6,
      lights: true,
      fog: true,
      side: DoubleSide
    }, params));
    return _this;
  }
  _createClass(UberMaterial2, [{
    key: "precisionString",
    value: function precisionString() {
      var precision = capabilities.precision;
      var str = "precision ".concat(precision, " float;\n") + "precision ".concat(precision, " int;\n\n");
      return str;
    }
  }, {
    key: "copy",
    value: function copy2(source) {
      _get(_getPrototypeOf(UberMaterial2.prototype), "copy", this).call(this, source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = UniformsUtils.clone(source.uniforms);
      this.defines = _objectSpread({}, source.defines);
      this.extensions = source.extensions;
      this.fog = source.fog;
      this.instancedPos = source.instancedPos;
      this.instancedMatrix = source.instancedMatrix;
      this.attrColor = source.attrColor;
      this.attrColor2 = source.attrColor2;
      this.attrAlphaColor = source.attrAlphaColor;
      this.overrideColor = source.overrideColor;
      this.sphereSprite = source.sphereSprite;
      this.cylinderSprite = source.cylinderSprite;
      this.zClip = source.zClip;
      this.clipPlane = source.clipPlane;
      this.fakeOpacity = source.fakeOpacity;
      this.colorFromPos = source.colorFromPos;
      this.shadowmap = source.shadowmap;
      this.shadowmapType = source.shadowmapType;
      this.colorFromDepth = source.colorFromDepth;
      this.orthoCam = source.orthoCam;
      this.prepassTransparancy = source.prepassTransparancy;
      this.dashedLine = source.dashedLine;
      this.thickLine = source.thickLine;
      this.fogTransparent = source.fogTransparent;
      this.normalsToGBuffer = source.normalsToGBuffer;
      this.toonShading = source.toonShading;
      this.uberOptions.copy(source.uberOptions);
      return this;
    }
  }, {
    key: "createInstance",
    value: function createInstance() {
      var inst = new UberMaterial2();
      inst.copy(this);
      inst.uberOptions = Object.create(this.uberOptions);
      return inst;
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      if (typeof values === "undefined") {
        return;
      }
      _get(_getPrototypeOf(UberMaterial2.prototype), "setValues", this).call(this, values);
      var defines = {};
      var extensions = {};
      if (this.fog) {
        defines.USE_FOG = 1;
      }
      if (this.instancedPos) {
        defines.INSTANCED_POS = 1;
      }
      if (this.instancedMatrix) {
        defines.INSTANCED_MATRIX = 1;
      }
      if (this.attrColor) {
        defines.ATTR_COLOR = 1;
      }
      if (this.attrColor2) {
        defines.ATTR_COLOR2 = 1;
      }
      if (this.attrAlphaColor) {
        defines.ATTR_ALPHA_COLOR = 1;
      }
      if (this.overrideColor) {
        defines.OVERRIDE_COLOR = 1;
      }
      if (this.sphereSprite) {
        defines.SPHERE_SPRITE = 1;
        extensions.fragDepth = 1;
      }
      if (this.cylinderSprite) {
        defines.CYLINDER_SPRITE = 1;
        extensions.fragDepth = 1;
      }
      if (this.zClip) {
        defines.ZCLIP = 1;
      }
      if (this.clipPlane) {
        defines.CLIP_PLANE = 1;
      }
      if (this.fakeOpacity) {
        defines.FAKE_OPACITY = 1;
      }
      if (this.lights) {
        defines.USE_LIGHTS = 1;
      }
      if (this.colorFromPos) {
        defines.COLOR_FROM_POS = 1;
      }
      if (this.shadowmap) {
        defines.SHADOWMAP = 1;
        if (this.shadowmapType === "pcf") {
          defines.SHADOWMAP_PCF_SHARP = 1;
        } else if (this.shadowmapType === "random") {
          defines.SHADOWMAP_PCF_RAND = 1;
        } else {
          defines.SHADOWMAP_BASIC = 1;
        }
      }
      if (this.colorFromDepth) {
        defines.COLOR_FROM_DEPTH = 1;
      }
      if (this.orthoCam) {
        defines.ORTHOGRAPHIC_CAMERA = 1;
      }
      if (this.prepassTransparancy) {
        defines.PREPASS_TRANSP = 1;
      }
      if (this.dashedLine) {
        defines.DASHED_LINE = 1;
      }
      if (this.thickLine) {
        defines.THICK_LINE = 1;
      }
      if (this.fogTransparent) {
        defines.FOG_TRANSPARENT = 1;
      }
      if (this.normalsToGBuffer) {
        extensions.drawBuffers = 1;
        defines.NORMALS_TO_G_BUFFER = 1;
      }
      if (this.toonShading) {
        defines.TOON_SHADING = 1;
      }
      this.defines = defines;
      this.extensions = extensions;
    }
  }, {
    key: "setUberOptions",
    value: function setUberOptions(values) {
      if (typeof values === "undefined") {
        return;
      }
      for (var key in values) {
        if (!values.hasOwnProperty(key)) {
          continue;
        }
        if (this.uberOptions[key] instanceof Color) {
          this.uberOptions[key] = values[key].clone();
        } else {
          this.uberOptions[key] = values[key];
        }
      }
    }
  }, {
    key: "clone",
    value: function clone2(shallow) {
      if (!shallow) {
        return Material.prototype.clone.call(this);
      }
      return this.createInstance();
    }
  }, {
    key: "updateUniforms",
    value: function updateUniforms() {
      var self2 = this;
      uberOptionNames.forEach(function(p2) {
        if (self2.uniforms.hasOwnProperty(p2)) {
          if (self2.uberOptions[p2] instanceof Color || self2.uberOptions[p2] instanceof Matrix4) {
            self2.uniforms[p2].value = self2.uberOptions[p2].clone();
          } else {
            self2.uniforms[p2].value = self2.uberOptions[p2];
          }
        }
      });
    }
  }]);
  return UberMaterial2;
}(RawShaderMaterial);
function _createSuper$1w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1w();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1w() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function UberObject(SuperClass) {
  var NewObjectType = function(_SuperClass) {
    _inherits(NewObjectType2, _SuperClass);
    var _super = _createSuper$1w(NewObjectType2);
    function NewObjectType2() {
      var _this;
      _classCallCheck(this, NewObjectType2);
      for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(rest));
      _this.onBeforeRender = NewObjectType2.prototype.onBeforeRender;
      return _this;
    }
    _createClass(NewObjectType2, [{
      key: "onBeforeRender",
      value: function onBeforeRender(renderer, scene, camera, geometry, material2, group) {
        this._onBeforeRender(renderer, scene, camera, geometry, material2, group);
        this._update();
      }
    }, {
      key: "_onBeforeRender",
      value: function _onBeforeRender() {
      }
    }, {
      key: "_update",
      value: function _update() {
        var material2 = this.material;
        if (!material2) {
          return;
        }
        if (material2 instanceof UberMaterial) {
          material2.updateUniforms();
        }
      }
    }]);
    return NewObjectType2;
  }(SuperClass);
  return NewObjectType;
}
function _createSuper$1v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1v() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OurMesh$4 = UberObject(Mesh);
var ZSpriteMesh = function(_OurMesh) {
  _inherits(ZSpriteMesh2, _OurMesh);
  var _super = _createSuper$1v(ZSpriteMesh2);
  function ZSpriteMesh2() {
    var _this;
    _classCallCheck(this, ZSpriteMesh2);
    for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
      rest[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(rest));
    _this.castShadow = true;
    _this.receiveShadow = true;
    return _this;
  }
  _createClass(ZSpriteMesh2, [{
    key: "_onBeforeRender",
    value: function _onBeforeRender(renderer, scene, camera, _geometry2, _material, _group) {
      OurMesh$4.prototype._onBeforeRender.call(this, renderer, scene, camera);
      var material2 = this.material;
      if (!material2) {
        return;
      }
      if (material2.uniforms.invModelViewMatrix) {
        this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
        material2.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert();
        material2.uniforms.nearPlaneValue.value = camera.near;
        material2.uniformsNeedUpdate = true;
      }
    }
  }]);
  return ZSpriteMesh2;
}(OurMesh$4);
function _createSuper$1u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1u() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OurMesh$3 = UberObject(Mesh);
var ZClippedMesh = function(_OurMesh) {
  _inherits(ZClippedMesh2, _OurMesh);
  var _super = _createSuper$1u(ZClippedMesh2);
  function ZClippedMesh2(geometry, material2) {
    var _this;
    _classCallCheck(this, ZClippedMesh2);
    _this = _super.call(this, geometry, material2);
    _this.castShadow = true;
    _this.receiveShadow = true;
    return _this;
  }
  _createClass(ZClippedMesh2, [{
    key: "_onBeforeRender",
    value: function _onBeforeRender(renderer, scene, camera) {
      OurMesh$3.prototype._onBeforeRender.call(this, renderer, scene, camera);
      var geo = this.geometry;
      var material2 = this.material;
      if (!geo.zClip || !material2.uberOptions) {
        return;
      }
      var zClipCoef = 0.5;
      var modelView = ZClippedMesh2._modelView;
      var mvLength = ZClippedMesh2._mvLength;
      var center = ZClippedMesh2._center;
      modelView.multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
      var s2 = mvLength.setFromMatrixColumn(modelView, 0).length();
      center.copy(geo.boundingSphere.center);
      this.localToWorld(center);
      material2.uberOptions.zClipValue = camera.position.z - center.z - s2 * (zClipCoef * geo.boundingSphere.radius);
    }
  }]);
  return ZClippedMesh2;
}(OurMesh$3);
_defineProperty2(ZClippedMesh, "_mvLength", new Vector3());
_defineProperty2(ZClippedMesh, "_center", new Vector3());
_defineProperty2(ZClippedMesh, "_modelView", new Matrix4());
function _createSuper$1t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1t() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var TextMesh = function(_Group) {
  _inherits(TextMesh2, _Group);
  var _super = _createSuper$1t(TextMesh2);
  function TextMesh2(geometry, _material) {
    var _this;
    _classCallCheck(this, TextMesh2);
    _this = _super.call(this);
    _this.geometry = geometry;
    var self2 = _assertThisInitialized(_this);
    self2.initialized = false;
    _this.geometry.addEventListener("update", function() {
      self2.update();
    });
    return _this;
  }
  _createClass(TextMesh2, [{
    key: "init",
    value: function init2() {
      var children = this.children;
      for (var i2 = children.length - 1; i2 >= 0; --i2) {
        this.remove(children[i2]);
      }
      var _this$geometry = this.geometry, items = _this$geometry.items, userData = _this$geometry.userData;
      for (var _i = 0, n2 = items.length; _i < n2; ++_i) {
        var srcItem = items[_i];
        if (!srcItem) {
          continue;
        }
        var item = utils.shallowCloneNode(srcItem);
        var label = new CSS2DObject(item);
        label.userData = (0, import_lodash.clone)(userData);
        var el = label.getElement();
        el.style.visibility = "visible";
        label.source = srcItem;
        this.add(label);
      }
      this.initialized = true;
    }
  }, {
    key: "update",
    value: function update() {
      var geo = this.geometry;
      if (!geo.needsUpdate) {
        return;
      }
      var children = this.children;
      if (!this.initialized) {
        this.init();
      }
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        var child = children[i2];
        var item = child.source;
        child.position.copy(item.worldPos);
        child.userData.color = item.opts.color;
        child.userData.background = item.opts.background;
      }
    }
  }]);
  return TextMesh2;
}(Group);
function _createSuper$1s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1s() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OurMesh$2 = UberObject(Mesh);
var SimpleMesh = function(_OurMesh) {
  _inherits(SimpleMesh2, _OurMesh);
  var _super = _createSuper$1s(SimpleMesh2);
  function SimpleMesh2(geometry, material2) {
    var _this;
    _classCallCheck(this, SimpleMesh2);
    _this = _super.call(this, geometry, material2);
    _this.castShadow = true;
    _this.receiveShadow = true;
    return _this;
  }
  return _createClass(SimpleMesh2);
}(OurMesh$2);
function _createSuper$1r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1r() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OurMesh$1 = UberObject(Mesh);
var _viewport = new Vector2();
var ThickLineMesh = function(_OurMesh) {
  _inherits(ThickLineMesh2, _OurMesh);
  var _super = _createSuper$1r(ThickLineMesh2);
  function ThickLineMesh2() {
    _classCallCheck(this, ThickLineMesh2);
    return _super.apply(this, arguments);
  }
  _createClass(ThickLineMesh2, [{
    key: "_onBeforeRender",
    value: function _onBeforeRender(renderer, scene, camera, _geometry2, _material, _group) {
      var material2 = this.material;
      if (!material2.uberOptions) {
        return;
      }
      material2.uberOptions.projMatrixInv.copy(camera.projectionMatrix).invert();
      renderer.getSize(_viewport);
      material2.uberOptions.viewport.set(_viewport.width, _viewport.height);
    }
  }]);
  return ThickLineMesh2;
}(OurMesh$1);
function _createSuper$1q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OurMesh = UberObject(Mesh);
var InstancedMesh2 = function(_OurMesh) {
  _inherits(InstancedMesh3, _OurMesh);
  var _super = _createSuper$1q(InstancedMesh3);
  function InstancedMesh3() {
    var _this;
    _classCallCheck(this, InstancedMesh3);
    for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
      rest[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(rest));
    _this.castShadow = true;
    _this.receiveShadow = true;
    return _this;
  }
  return _createClass(InstancedMesh3);
}(OurMesh);
var meshes = {
  ZClipped: ZClippedMesh,
  ZSprite: ZSpriteMesh,
  Text: TextMesh,
  Line: UberObject(Line),
  LineSegments: UberObject(LineSegments),
  Mesh: SimpleMesh,
  ThickLineMesh,
  Instanced: InstancedMesh2
};
function setMatParams(params, uniforms) {
  return function(material2) {
    material2.setValues(params);
    material2.setUberOptions(uniforms);
  };
}
function _createInstancedCylinders(useZSprites, openEnded) {
  return {
    Geometry: function Geometry(a2, b2) {
      return new geometries.Instanced2CCylindersGeometry(a2, b2, useZSprites, openEnded);
    },
    Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
    initMaterial: setMatParams({
      instancedMatrix: true,
      attrColor: true,
      attrColor2: true,
      attrAlphaColor: true,
      cylinderSprite: useZSprites
    })
  };
}
function _createLineSegmentsGeoTriplet(geo, renderParams) {
  var thickLines = geo.prototype instanceof ThickLinesGeometry;
  var lineWidth = renderParams.lineWidth || 0;
  return {
    Geometry: geo,
    Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
    initMaterial: setMatParams({
      lights: false,
      attrColor: true,
      attrAlphaColor: true,
      thickLine: thickLines
    }, {
      lineWidth
    })
  };
}
function _createSimpleGeoTriplet(geoClass) {
  return {
    Geometry: geoClass,
    Object: meshes.Mesh,
    initMaterial: setMatParams({
      attrColor: true,
      attrAlphaColor: true
    })
  };
}
function _createIsoSurfaceGeoTriplet(geoClass, caps, settings2, renderParams) {
  var surfaceOpts = {
    wireframe: !!renderParams.wireframe,
    fakeOpacity: settings2.now.isoSurfaceFakeOpacity,
    zClip: renderParams.zClip
  };
  return {
    Geometry: geoClass,
    Object: meshes.ZClipped,
    initMaterial: setMatParams({
      attrColor: true,
      attrAlphaColor: false,
      wireframe: surfaceOpts.wireframe,
      fakeOpacity: surfaceOpts.fakeOpacity,
      zClip: surfaceOpts.zClip
    })
  };
}
var MeshCreator = function() {
  function MeshCreator2() {
    _classCallCheck(this, MeshCreator2);
  }
  _createClass(MeshCreator2, null, [{
    key: "createSpheres",
    value: function createSpheres(caps, settings2) {
      var useZSprites = settings2.now.zSprites;
      return {
        Geometry: function Geometry(a2, b2) {
          return new geometries.InstancedSpheresGeometry(a2, b2, useZSprites);
        },
        Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
        initMaterial: setMatParams({
          instancedPos: true,
          attrColor: true,
          attrAlphaColor: true,
          sphereSprite: useZSprites
        })
      };
    }
  }, {
    key: "create2CClosedCylinders",
    value: function create2CClosedCylinders(_caps, _settings) {
      return _createInstancedCylinders(false, false);
    }
  }, {
    key: "create2CCylinders",
    value: function create2CCylinders(caps, settings2) {
      return _createInstancedCylinders(settings2.now.zSprites, true);
    }
  }, {
    key: "create2CLines",
    value: function create2CLines(_caps, _settings, renderParams) {
      return _createLineSegmentsGeoTriplet(geometries.TwoColorLinesGeometry, renderParams);
    }
  }, {
    key: "createCrosses",
    value: function createCrosses(_caps, _settings, renderParams) {
      return _createLineSegmentsGeoTriplet(geometries.CrossGeometry, renderParams);
    }
  }, {
    key: "createExtrudedChains",
    value: function createExtrudedChains(_caps, _settings) {
      return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry);
    }
  }, {
    key: "createChunkedLines",
    value: function createChunkedLines(_caps, _settings, renderParams) {
      return _createLineSegmentsGeoTriplet(geometries.ChunkedLinesGeometry, renderParams);
    }
  }, {
    key: "createQuickSurface",
    value: function createQuickSurface(caps, settings2, renderParams) {
      return _createIsoSurfaceGeoTriplet(geometries.QuickSurfGeometry, caps, settings2, renderParams);
    }
  }, {
    key: "createContactSurface",
    value: function createContactSurface(caps, settings2, renderParams) {
      return _createIsoSurfaceGeoTriplet(geometries.ContactSurfaceGeometry, caps, settings2, renderParams);
    }
  }, {
    key: "createSASSES",
    value: function createSASSES(caps, settings2, renderParams) {
      return _createIsoSurfaceGeoTriplet(geometries.SSIsosurfaceGeometry, caps, settings2, renderParams);
    }
  }, {
    key: "createLabels",
    value: function createLabels(_caps, _settings) {
      return {
        Geometry: geometries.LabelsGeometry,
        Object: meshes.Text,
        initMaterial: function initMaterial() {
        }
      };
    }
  }]);
  return MeshCreator2;
}();
function _createSuper$1p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1p() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var TransformGroup = function(_Object3D) {
  _inherits(TransformGroup2, _Object3D);
  var _super = _createSuper$1p(TransformGroup2);
  function TransformGroup2(geometry, geoParams, material2, transforms) {
    var _this;
    _classCallCheck(this, TransformGroup2);
    _this = _super.call(this);
    _this._geometry = geometry;
    _this._geoParams = geoParams;
    var mat = material2.createInstance();
    geoParams.initMaterial(mat);
    _this._material = mat;
    _this._transforms = transforms.length > 0 ? transforms : [new Matrix4()];
    var meshes2 = _this._createMeshes(geometry);
    for (var i2 = 0, n2 = meshes2.length; i2 < n2; ++i2) {
      _this.add(meshes2[i2]);
    }
    return _this;
  }
  _createClass(TransformGroup2, [{
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var ray = TransformGroup2._ray;
      var inverseMatrix = TransformGroup2._inverseMatrix;
      var children = this.children;
      ray.copy(raycaster.ray);
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        var child = children[i2];
        if (!gfxutils.belongToSelectLayers(child)) {
          continue;
        }
        child.updateMatrixWorld();
        var mtx = child.matrixWorld;
        inverseMatrix.copy(mtx).invert();
        raycaster.ray.copy(ray).applyMatrix4(inverseMatrix);
        var childIntersects = [];
        this._geometry.raycast(raycaster, childIntersects);
        for (var j2 = 0, ciCount = childIntersects.length; j2 < ciCount; ++j2) {
          var inters = childIntersects[j2];
          if (inters.point) {
            inters.point.applyMatrix4(mtx);
            inters.distance = ray.origin.distanceTo(inters.point);
          }
          inters.object = child;
          intersects2[intersects2.length] = inters;
        }
      }
      raycaster.ray.copy(ray);
    }
  }, {
    key: "getSubset",
    value: function getSubset2(chunkIndices) {
      var geos = this._geometry.getSubset(chunkIndices);
      var subset = [];
      var subIdx = 0;
      for (var i2 = 0, n2 = geos.length; i2 < n2; ++i2) {
        var meshes2 = this._createMeshes(geos[i2]);
        for (var j2 = 0, meshCnt = meshes2.length; j2 < meshCnt; ++j2) {
          subset[subIdx++] = meshes2[j2];
        }
      }
      return subset;
    }
  }, {
    key: "_createMeshes",
    value: function _createMeshes(geometry) {
      var transforms = this._transforms;
      var Mesh2 = this._geoParams.Object;
      var material2 = this._material;
      var meshes2 = [];
      for (var i2 = 0, n2 = transforms.length; i2 < n2; ++i2) {
        var mesh = new Mesh2(geometry, material2);
        mesh.applyMatrix4(transforms[i2]);
        meshes2[i2] = mesh;
      }
      return meshes2;
    }
  }]);
  return TransformGroup2;
}(Object3D);
_defineProperty2(TransformGroup, "_inverseMatrix", new Matrix4());
_defineProperty2(TransformGroup, "_ray", new Ray());
function _createSuper$1o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1o() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function wrapper(Name, args) {
  var params = [Name].concat(args);
  return Name.bind.apply(Name, _toConsumableArray(params));
}
var ChemGroup = function(_RCGroup) {
  _inherits(ChemGroup2, _RCGroup);
  var _super = _createSuper$1o(ChemGroup2);
  function ChemGroup2(geoParams, selection, colorer, mode2, transforms, polyComplexity, material2) {
    var _this;
    _classCallCheck(this, ChemGroup2);
    _this = _super.call(this);
    if (_this.constructor === ChemGroup2) {
      throw new Error("Can not instantiate abstract class!");
    }
    _this._selection = selection;
    _this._mode = mode2;
    _this._colorer = colorer;
    _this._chunksIdc = selection.chunks;
    _this._polyComplexity = polyComplexity;
    _this._geo = new (wrapper(geoParams.Geometry, _this._makeGeoArgs()))();
    _this._mesh = new TransformGroup(_this._geo, geoParams, material2, transforms);
    _this.add(_this._mesh);
    _this._build();
    return _this;
  }
  _createClass(ChemGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      throw new Error("ChemGroup subclass must override _makeGeoArgs() method");
    }
  }, {
    key: "getSubset",
    value: function getSubset2(mask, innerOnly) {
      innerOnly = innerOnly !== void 0 ? innerOnly : false;
      var chunksList = this._calcChunksList(mask, innerOnly);
      if (chunksList.length === 0) {
        return [];
      }
      return this._mesh.getSubset(chunksList);
    }
  }, {
    key: "_changeSubsetOpacity",
    value: function _changeSubsetOpacity(mask, value, innerOnly) {
      var chunksList = this._calcChunksList(mask, innerOnly);
      if (chunksList.length === 0) {
        return;
      }
      this._geo.setOpacity(chunksList, value);
    }
  }, {
    key: "enableSubset",
    value: function enableSubset(mask, innerOnly) {
      innerOnly = innerOnly !== void 0 ? innerOnly : true;
      this._changeSubsetOpacity(mask, 1, innerOnly);
    }
  }, {
    key: "disableSubset",
    value: function disableSubset(mask, innerOnly) {
      innerOnly = innerOnly !== void 0 ? innerOnly : true;
      this._changeSubsetOpacity(mask, 0, innerOnly);
    }
  }]);
  return ChemGroup2;
}(RCGroup);
function _createSuper$1n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1n() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AtomsGroup = function(_ChemGroup) {
  _inherits(AtomsGroup2, _ChemGroup);
  var _super = _createSuper$1n(AtomsGroup2);
  function AtomsGroup2() {
    _classCallCheck(this, AtomsGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(AtomsGroup2, [{
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var atoms = this._selection.atoms;
      var inters = [];
      this._mesh.raycast(raycaster, inters);
      var atomsIdc = this._chunksIdc;
      for (var i2 = 0, n2 = inters.length; i2 < n2; ++i2) {
        if (!inters[i2].hasOwnProperty("chunkIdx")) {
          continue;
        }
        var atomIdx = atomsIdc[inters[i2].chunkIdx];
        if (atomIdx < atoms.length) {
          inters[i2].atom = atoms[atomIdx];
          intersects2.push(inters[i2]);
        }
      }
    }
  }, {
    key: "_calcChunksList",
    value: function _calcChunksList(mask) {
      var chunksList = [];
      var atoms = this._selection.atoms;
      var atomsIdc = this._chunksIdc;
      for (var i2 = 0, n2 = atomsIdc.length; i2 < n2; ++i2) {
        var atom = atoms[atomsIdc[i2]];
        if ((atom.mask & mask) !== 0) {
          chunksList.push(i2);
        }
      }
      return chunksList;
    }
  }]);
  return AtomsGroup2;
}(ChemGroup);
function _createSuper$1m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1m() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AtomsSphereGroup = function(_AtomsGroup) {
  _inherits(AtomsSphereGroup2, _AtomsGroup);
  var _super = _createSuper$1m(AtomsSphereGroup2);
  function AtomsSphereGroup2() {
    _classCallCheck(this, AtomsSphereGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(AtomsSphereGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      return [this._selection.chunks.length, this._polyComplexity];
    }
  }, {
    key: "_build",
    value: function _build() {
      var atomsIdc = this._selection.chunks;
      var _this$_selection = this._selection, atoms = _this$_selection.atoms, parent = _this$_selection.parent;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var geo = this._geo;
      for (var i2 = 0, n2 = atomsIdc.length; i2 < n2; ++i2) {
        var atom = atoms[atomsIdc[i2]];
        geo.setItem(i2, atom.position, mode2.calcAtomRadius(atom));
        geo.setColor(i2, colorer.getAtomColor(atom, parent));
      }
      geo.finalize();
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var atomsIdc = this._selection.chunks;
      var atoms = this._selection.atoms;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var updateColor = frameData.needsColorUpdate(colorer);
      var geo = this._geo;
      for (var i2 = 0, n2 = atomsIdc.length; i2 < n2; ++i2) {
        var atom = atoms[atomsIdc[i2]];
        geo.setItem(i2, frameData.getAtomPos(atomsIdc[i2]), mode2.calcAtomRadius(atom));
        if (updateColor) {
          geo.setColor(i2, frameData.getAtomColor(colorer, atom));
        }
      }
      geo.finalize();
    }
  }]);
  return AtomsSphereGroup2;
}(AtomsGroup);
function _createSuper$1l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1l() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AtomsSurfaceGroup = function(_AtomsSphereGroup) {
  _inherits(AtomsSurfaceGroup2, _AtomsSphereGroup);
  var _super = _createSuper$1l(AtomsSurfaceGroup2);
  function AtomsSurfaceGroup2() {
    _classCallCheck(this, AtomsSurfaceGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(AtomsSurfaceGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      var selectedAtoms = [];
      var _this$_selection = this._selection, atoms = _this$_selection.atoms, chunks = _this$_selection.chunks;
      var n2 = chunks.length;
      for (var i2 = 0; i2 < n2; ++i2) {
        selectedAtoms[i2] = atoms[chunks[i2]];
      }
      var opts = this._mode.getSurfaceOpts();
      opts.atoms = selectedAtoms;
      return [n2, opts];
    }
  }]);
  return AtomsSurfaceGroup2;
}(AtomsSphereGroup);
function _createSuper$1k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1k() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AtomsSASSESGroupStub = function(_AtomsSphereGroup) {
  _inherits(AtomsSASSESGroupStub2, _AtomsSphereGroup);
  var _super = _createSuper$1k(AtomsSASSESGroupStub2);
  function AtomsSASSESGroupStub2() {
    _classCallCheck(this, AtomsSASSESGroupStub2);
    return _super.apply(this, arguments);
  }
  _createClass(AtomsSASSESGroupStub2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      var selectedAtoms = [];
      var _this$_selection = this._selection, atoms = _this$_selection.atoms, chunks = _this$_selection.chunks;
      var n2 = chunks.length;
      for (var i2 = 0; i2 < n2; ++i2) {
        selectedAtoms[i2] = atoms[chunks[i2]];
      }
      var opts = this._mode.getSurfaceOpts();
      opts.atoms = selectedAtoms;
      opts.selection = this._selection;
      opts.colorMode = this._colorer;
      return [n2, opts];
    }
  }]);
  return AtomsSASSESGroupStub2;
}(AtomsSphereGroup);
function _createSuper$1j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1j() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function adjustColor(color2) {
  var r2 = color2 >> 16 & 255;
  var g2 = color2 >> 8 & 255;
  var b2 = color2 & 255;
  if (0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2 > 127) {
    r2 = r2 * 3 / 10;
    g2 = g2 * 3 / 10;
    b2 = b2 * 3 / 10;
  } else {
    r2 = 255 - (255 - r2) * 3 / 10;
    g2 = 255 - (255 - g2) * 3 / 10;
    b2 = 255 - (255 - b2) * 3 / 10;
  }
  return r2 << 16 | g2 << 8 | b2;
}
function inverseColor(color2) {
  var r2 = color2 >> 16 & 255;
  var g2 = color2 >> 8 & 255;
  var b2 = color2 & 255;
  return 255 - r2 << 16 | 255 - g2 << 8 | 255 - b2;
}
function getAtomText(atom) {
  if (atom.name.getNode() !== null) {
    return atom.name.getNode();
  }
  return atom.getVisualName();
}
var colorMappings = {
  none: function none2(c2) {
    return c2;
  },
  adjust: adjustColor,
  inverse: inverseColor
};
function propagateColor(color2, rule) {
  var result;
  if (colorMappings.hasOwnProperty(rule)) {
    result = utils.hexColor(colorMappings[rule](color2));
  } else {
    var val = parseInt(rule, 16);
    if (!Number.isNaN(val) && rule.toLowerCase().startsWith("0x")) {
      result = utils.hexColor(val);
    } else {
      result = "#000000";
    }
  }
  return result;
}
var templateMappings = {
  serial: function serial(a2) {
    return a2.serial;
  },
  name: function name(a2) {
    return a2.getVisualName();
  },
  elem: function elem(a2) {
    return a2.element.name;
  },
  residue: function residue(a2) {
    return a2.residue.getType().getName();
  },
  sequence: function sequence(a2) {
    return a2.residue.getSequence();
  },
  chain: function chain(a2) {
    return a2.residue.getChain().getName();
  },
  hetatm: function hetatm(a2) {
    return a2.isHet();
  },
  water: function water(a2) {
    return a2.residue.getType().getName() === "HOH" || a2.residue.getType().getName() === "WAT";
  }
};
var parseTemplate = function parseTemplate2(atom, str) {
  return str.replace(/\{\{(\s*\w+\s*)\}\}/g, function(m2) {
    var key = m2.replace(/\s+/g, "");
    key = key.substring(2, key.length - 2).toLowerCase();
    if (templateMappings.hasOwnProperty(key)) {
      return templateMappings[key](atom);
    }
    return "null";
  });
};
var AtomsTextGroup = function(_AtomsGroup) {
  _inherits(AtomsTextGroup2, _AtomsGroup);
  var _super = _createSuper$1j(AtomsTextGroup2);
  function AtomsTextGroup2() {
    _classCallCheck(this, AtomsTextGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(AtomsTextGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      var opts = this._mode.getLabelOpts();
      return [this._selection.chunks.length, opts];
    }
  }, {
    key: "_build",
    value: function _build() {
      var opts = this._mode.getLabelOpts();
      var atomsIdc = this._selection.chunks;
      var _this$_selection = this._selection, atoms = _this$_selection.atoms, parent = _this$_selection.parent;
      var colorer = this._colorer;
      var geo = this._geo;
      for (var i2 = 0, n2 = atomsIdc.length; i2 < n2; ++i2) {
        var atom = atoms[atomsIdc[i2]];
        var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
        if (!text) {
          continue;
        }
        var color2 = colorer.getAtomColor(atom, parent);
        var fgColor = parseInt(propagateColor(color2, opts.fg).substring(1), 16);
        var bgColor = opts.showBg ? parseInt(propagateColor(color2, opts.bg).substring(1), 16) : "transparent";
        geo.setItem(i2, atom.position, text);
        geo.setColor(i2, fgColor, bgColor);
      }
      geo.finalize();
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var opts = this._mode.getLabelOpts();
      var atomsIdc = this._selection.chunks;
      var atoms = this._selection.atoms;
      var colorer = this._colorer;
      var geo = this._geo;
      var updateColor = frameData.needsColorUpdate(colorer);
      for (var i2 = 0, n2 = atomsIdc.length; i2 < n2; ++i2) {
        var atom = atoms[atomsIdc[i2]];
        var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
        if (!text) {
          continue;
        }
        var color2 = frameData.getAtomColor(colorer, atom);
        var fgColor = parseInt(propagateColor(color2, opts.fg).substring(1), 16);
        var bgColor = opts.showBg ? parseInt(propagateColor(color2, opts.bg).substring(1), 16) : "transparent";
        geo.setItem(i2, frameData.getAtomPos(atomsIdc[i2]), text);
        if (updateColor) {
          geo.setColor(i2, fgColor, bgColor);
        }
      }
      geo.finalize();
    }
  }]);
  return AtomsTextGroup2;
}(AtomsGroup);
function _createSuper$1i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1i() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _slerp(omega, v1, v2, t2) {
  var oSin = Math.sin(omega);
  return v1.clone().multiplyScalar(Math.sin((1 - t2) * omega) / oSin).addScaledVector(v2, Math.sin(t2 * omega) / oSin);
}
var AromaticGroup = function(_AtomsGroup) {
  _inherits(AromaticGroup2, _AtomsGroup);
  var _super = _createSuper$1i(AromaticGroup2);
  function AromaticGroup2() {
    _classCallCheck(this, AromaticGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(AromaticGroup2, [{
    key: "_buildInner",
    value: function _buildInner(radOffset, addChunk) {
      var chunksToIdx = this._selection.chunks;
      var prevVector = new Vector3();
      var currVector = new Vector3();
      var segmentsHeight = this._segmentsHeight;
      var leprStep = 1 / segmentsHeight;
      var colorer = this._colorer;
      var _this$_selection = this._selection, cycles = _this$_selection.cycles, parent = _this$_selection.parent;
      var chunkIdx = 0;
      var currAtomIdx = chunksToIdx[chunkIdx];
      for (var cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
        var cycle = cycles[cIdx];
        var cycAtoms = cycle.atoms;
        var chunkPoints = [];
        var tmpDir = [];
        var center = cycle.center;
        var cycleRad = cycle.radius - radOffset;
        var n2 = cycAtoms.length;
        var i2 = 0;
        var prevPos = cycAtoms[n2 - 1].position;
        var currPos = cycAtoms[i2].position;
        prevVector.subVectors(prevPos, center);
        currVector.subVectors(currPos, center);
        var upDir = currVector.clone().cross(prevVector).normalize();
        for (; i2 < n2; ++i2) {
          var omega = prevVector.angleTo(currVector);
          tmpDir[i2] = _slerp(omega, prevVector, currVector, 0.5).normalize();
          currPos = cycAtoms[(i2 + 1) % n2].position;
          prevVector.copy(currVector);
          currVector.subVectors(currPos, center);
        }
        for (i2 = 0; i2 < n2; ++i2) {
          if (cycAtoms[i2].index !== currAtomIdx) {
            continue;
          }
          var start = tmpDir[i2];
          var end = tmpDir[(i2 + 1) % n2];
          var color2 = colorer.getAtomColor(cycAtoms[i2], parent);
          var currAngle = start.angleTo(end);
          for (var j2 = 0; j2 <= segmentsHeight; ++j2) {
            chunkPoints[j2] = _slerp(currAngle, start, end, j2 * leprStep).multiplyScalar(cycleRad).add(center);
          }
          addChunk(chunkIdx++, color2, chunkPoints, center, upDir);
          currAtomIdx = chunksToIdx[chunkIdx];
        }
      }
    }
  }]);
  return AromaticGroup2;
}(AtomsGroup);
function _createSuper$1h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1h() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _createShape$1(rad, parts) {
  var pts = [];
  for (var i2 = 0; i2 < parts; ++i2) {
    var a2 = -2 * i2 / parts * Math.PI;
    pts.push(new Vector3(Math.cos(a2) * rad, Math.sin(a2) * rad, 0));
  }
  return pts;
}
var calcChunkMatrix = gfxutils.calcChunkMatrix;
var AromaticTorusGroup = function(_AromaticGroup) {
  _inherits(AromaticTorusGroup2, _AromaticGroup);
  var _super = _createSuper$1h(AromaticTorusGroup2);
  function AromaticTorusGroup2() {
    _classCallCheck(this, AromaticTorusGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(AromaticTorusGroup2, [{
    key: "_build",
    value: function _build() {
      var segmentsHeight = this._segmentsHeight;
      var torusRad = this._mode.getAromRadius();
      var radiusV = new Vector2(torusRad, torusRad);
      var radOffset = this._mode.calcStickRadius() + 2 * torusRad;
      var lookAtVector = new Vector3();
      var mtc = [];
      var geo = this._geo;
      this._buildInner(radOffset, function(chunkIdx, color2, points, center, upDir) {
        for (var j2 = 0; j2 <= segmentsHeight; ++j2) {
          var currPoint = points[j2];
          var currDir = currPoint.clone().sub(center).cross(upDir);
          lookAtVector.addVectors(currPoint, currDir);
          mtc[j2] = calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV);
        }
        geo.setItem(chunkIdx, mtc);
        geo.setColor(chunkIdx, color2);
      });
      geo.finalize();
    }
  }, {
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      this._segmentsHeight = this._polyComplexity;
      return [_createShape$1(1, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length];
    }
  }]);
  return AromaticTorusGroup2;
}(AromaticGroup);
function _createSuper$1g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1g() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AromaticLinesGroup = function(_AromaticGroup) {
  _inherits(AromaticLinesGroup2, _AromaticGroup);
  var _super = _createSuper$1g(AromaticLinesGroup2);
  function AromaticLinesGroup2() {
    _classCallCheck(this, AromaticLinesGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(AromaticLinesGroup2, [{
    key: "_build",
    value: function _build() {
      var _this = this;
      var geo = this._geo;
      var radOffset = this._mode.getAromaticOffset();
      this._buildInner(radOffset, function(chunkIdx, color2, points) {
        var prevPt = points[0];
        for (var j2 = 1; j2 <= _this._segmentsHeight; ++j2) {
          var currPoint = points[j2];
          geo.setSegment(chunkIdx, j2 - 1, prevPt, currPoint);
          prevPt = currPoint;
        }
        geo.setColor(chunkIdx, color2);
      });
      geo.finalize();
    }
  }, {
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      this._segmentsHeight = this._mode.getAromaticArcChunks();
      return [this._selection.chunks.length, this._segmentsHeight, true];
    }
  }]);
  return AromaticLinesGroup2;
}(AromaticGroup);
function _createSuper$1f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1f() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ResiduesGroup = function(_ChemGroup) {
  _inherits(ResiduesGroup2, _ChemGroup);
  var _super = _createSuper$1f(ResiduesGroup2);
  function ResiduesGroup2() {
    _classCallCheck(this, ResiduesGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(ResiduesGroup2, [{
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var residues = this._selection.residues;
      var inters = [];
      this._mesh.raycast(raycaster, inters);
      var chunksIdc = this._chunksIdc;
      for (var i2 = 0, n2 = inters.length; i2 < n2; ++i2) {
        if (!inters[i2].hasOwnProperty("chunkIdx")) {
          continue;
        }
        var resIdx = chunksIdc[inters[i2].chunkIdx];
        if (resIdx < residues.length) {
          inters[i2].residue = residues[resIdx];
          intersects2.push(inters[i2]);
        }
      }
    }
  }, {
    key: "_calcChunksList",
    value: function _calcChunksList(mask) {
      var chunksList = [];
      var residues = this._selection.residues;
      var resIdc = this._chunksIdc;
      for (var i2 = 0, n2 = resIdc.length; i2 < n2; ++i2) {
        var res = residues[resIdc[i2]];
        if ((res._mask & mask) !== 0) {
          chunksList.push(i2);
        }
      }
      return chunksList;
    }
  }]);
  return ResiduesGroup2;
}(ChemGroup);
function _createSuper$1e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1e() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var NucleicItemGroup = function(_ResiduesGroup) {
  _inherits(NucleicItemGroup2, _ResiduesGroup);
  var _super = _createSuper$1e(NucleicItemGroup2);
  function NucleicItemGroup2() {
    _classCallCheck(this, NucleicItemGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(NucleicItemGroup2, [{
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var residues = this._selection.residues;
      var inters = [];
      this._mesh.raycast(raycaster, inters);
      var chunksIdc = this._chunksIdc;
      for (var i2 = 0, n2 = inters.length; i2 < n2; ++i2) {
        if (!inters[i2].hasOwnProperty("chunkIdx")) {
          continue;
        }
        var resIdx = chunksIdc[Math.floor(inters[i2].chunkIdx / 2)];
        if (resIdx < residues.length) {
          inters[i2].residue = residues[resIdx];
          intersects2.push(inters[i2]);
        }
      }
    }
  }, {
    key: "_build",
    value: function _build() {
      var _this$_selection = this._selection, residues = _this$_selection.residues, parent = _this$_selection.parent;
      var colorer = this._colorer;
      var geo = this._geo;
      var stickRad = this._mode.calcStickRadius();
      var chunkIdx = 0;
      var resIdc = this._selection.chunks;
      for (var i2 = 0, n2 = resIdc.length; i2 < n2; ++i2) {
        var res = residues[resIdc[i2]];
        var color2 = colorer.getResidueColor(res, parent);
        this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color2);
      }
      geo.finalize();
    }
  }, {
    key: "_calcChunksList",
    value: function _calcChunksList(mask) {
      var chunksList = [];
      var chunkIdx = 0;
      var residues = this._selection.residues;
      var resIdc = this._chunksIdc;
      for (var i2 = 0, n2 = resIdc.length; i2 < n2; ++i2) {
        var res = residues[resIdc[i2]];
        if ((res._mask & mask) !== 0) {
          chunksList[chunkIdx++] = 2 * i2;
          chunksList[chunkIdx++] = 2 * i2 + 1;
        }
      }
      return chunksList;
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var residues = frameData.getResidues();
      var parent = this._selection.parent;
      var colorer = this._colorer;
      var geo = this._geo;
      var stickRad = this._mode.calcStickRadius();
      var chunkIdx = 0;
      var resIdc = this._selection.chunks;
      for (var i2 = 0, n2 = resIdc.length; i2 < n2; ++i2) {
        var res = residues[resIdc[i2]];
        var color2 = colorer.getResidueColor(res, parent);
        this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color2);
      }
      geo.finishUpdate();
    }
  }]);
  return NucleicItemGroup2;
}(ResiduesGroup);
function _createSuper$1d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var NucleicCylindersGroup = function(_NucleicItemGroup) {
  _inherits(NucleicCylindersGroup2, _NucleicItemGroup);
  var _super = _createSuper$1d(NucleicCylindersGroup2);
  function NucleicCylindersGroup2() {
    _classCallCheck(this, NucleicCylindersGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(NucleicCylindersGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      return [this._selection.chunks.length, this._polyComplexity];
    }
  }, {
    key: "_processItem",
    value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color2) {
      var geo = this._geo;
      geo.setItem(chunkIdx, cyl1, cyl2, stickRad);
      geo.setColor(chunkIdx, color2, color2);
    }
  }]);
  return NucleicCylindersGroup2;
}(NucleicItemGroup);
function _createSuper$1c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1c() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var NucleicSpheresGroup = function(_NucleicItemGroup) {
  _inherits(NucleicSpheresGroup2, _NucleicItemGroup);
  var _super = _createSuper$1c(NucleicSpheresGroup2);
  function NucleicSpheresGroup2() {
    _classCallCheck(this, NucleicSpheresGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(NucleicSpheresGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      return [this._selection.chunks.length * 2, this._polyComplexity];
    }
  }, {
    key: "_processItem",
    value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color2) {
      var geo = this._geo;
      var idx = chunkIdx * 2;
      geo.setItem(idx, cyl1, stickRad);
      geo.setColor(idx, color2);
      idx++;
      geo.setItem(idx, cyl2, stickRad);
      geo.setColor(idx, color2);
    }
  }]);
  return NucleicSpheresGroup2;
}(NucleicItemGroup);
var Smooth = {};
(function(exports) {
  (function() {
    var AbstractInterpolator, CubicInterpolator, Enum, LinearInterpolator, NearestInterpolator, PI, SincFilterInterpolator, _Smooth, clipClamp, clipMirror, clipPeriodic, defaultConfig, getColumn, getType, isValidNumber, k2, makeLanczosWindow, makeScaledFunction, makeSincKernel, normalizeScaleTo, shallowCopy, sin, sinc, v2, validateNumber, validateVector, __hasProp = Object.prototype.hasOwnProperty, __extends2 = function __extends3(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Enum = {
      METHOD_NEAREST: "nearest",
      METHOD_LINEAR: "linear",
      METHOD_CUBIC: "cubic",
      METHOD_LANCZOS: "lanczos",
      METHOD_SINC: "sinc",
      CLIP_CLAMP: "clamp",
      CLIP_ZERO: "zero",
      CLIP_PERIODIC: "periodic",
      CLIP_MIRROR: "mirror",
      CUBIC_TENSION_DEFAULT: 0,
      CUBIC_TENSION_CATMULL_ROM: 0
    };
    defaultConfig = {
      method: Enum.METHOD_CUBIC,
      cubicTension: Enum.CUBIC_TENSION_DEFAULT,
      clip: Enum.CLIP_CLAMP,
      scaleTo: 0,
      sincFilterSize: 2,
      sincWindow: void 0
    };
    clipClamp = function clipClamp2(i2, n2) {
      return Math.max(0, Math.min(i2, n2 - 1));
    };
    clipPeriodic = function clipPeriodic2(i2, n2) {
      i2 = i2 % n2;
      if (i2 < 0) i2 += n2;
      return i2;
    };
    clipMirror = function clipMirror2(i2, n2) {
      var period;
      period = 2 * (n2 - 1);
      i2 = clipPeriodic(i2, period);
      if (i2 > n2 - 1) i2 = period - i2;
      return i2;
    };
    AbstractInterpolator = function() {
      function AbstractInterpolator2(array4, config) {
        this.array = array4.slice(0);
        this.length = this.array.length;
        if (!(this.clipHelper = {
          clamp: this.clipHelperClamp,
          zero: this.clipHelperZero,
          periodic: this.clipHelperPeriodic,
          mirror: this.clipHelperMirror
        }[config.clip])) {
          throw "Invalid clip: " + config.clip;
        }
      }
      AbstractInterpolator2.prototype.getClippedInput = function(i2) {
        if (0 <= i2 && i2 < this.length) {
          return this.array[i2];
        } else {
          return this.clipHelper(i2);
        }
      };
      AbstractInterpolator2.prototype.clipHelperClamp = function(i2) {
        return this.array[clipClamp(i2, this.length)];
      };
      AbstractInterpolator2.prototype.clipHelperZero = function(i2) {
        return 0;
      };
      AbstractInterpolator2.prototype.clipHelperPeriodic = function(i2) {
        return this.array[clipPeriodic(i2, this.length)];
      };
      AbstractInterpolator2.prototype.clipHelperMirror = function(i2) {
        return this.array[clipMirror(i2, this.length)];
      };
      AbstractInterpolator2.prototype.interpolate = function(t2) {
        throw "Subclasses of AbstractInterpolator must override the interpolate() method.";
      };
      return AbstractInterpolator2;
    }();
    NearestInterpolator = function(_super) {
      __extends2(NearestInterpolator2, _super);
      function NearestInterpolator2() {
        NearestInterpolator2.__super__.constructor.apply(this, arguments);
      }
      NearestInterpolator2.prototype.interpolate = function(t2) {
        return this.getClippedInput(Math.round(t2));
      };
      return NearestInterpolator2;
    }(AbstractInterpolator);
    LinearInterpolator = function(_super) {
      __extends2(LinearInterpolator2, _super);
      function LinearInterpolator2() {
        LinearInterpolator2.__super__.constructor.apply(this, arguments);
      }
      LinearInterpolator2.prototype.interpolate = function(t2) {
        var k3;
        k3 = Math.floor(t2);
        t2 -= k3;
        return (1 - t2) * this.getClippedInput(k3) + t2 * this.getClippedInput(k3 + 1);
      };
      return LinearInterpolator2;
    }(AbstractInterpolator);
    CubicInterpolator = function(_super) {
      __extends2(CubicInterpolator2, _super);
      function CubicInterpolator2(array4, config) {
        this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
        CubicInterpolator2.__super__.constructor.apply(this, arguments);
      }
      CubicInterpolator2.prototype.getTangent = function(k3) {
        return this.tangentFactor * (this.getClippedInput(k3 + 1) - this.getClippedInput(k3 - 1)) / 2;
      };
      CubicInterpolator2.prototype.interpolate = function(t2) {
        var k3, m2, p2, t22, t3;
        k3 = Math.floor(t2);
        m2 = [this.getTangent(k3), this.getTangent(k3 + 1)];
        p2 = [this.getClippedInput(k3), this.getClippedInput(k3 + 1)];
        t2 -= k3;
        t22 = t2 * t2;
        t3 = t2 * t22;
        return (2 * t3 - 3 * t22 + 1) * p2[0] + (t3 - 2 * t22 + t2) * m2[0] + (-2 * t3 + 3 * t22) * p2[1] + (t3 - t22) * m2[1];
      };
      return CubicInterpolator2;
    }(AbstractInterpolator);
    sin = Math.sin, PI = Math.PI;
    sinc = function sinc2(x2) {
      if (x2 === 0) {
        return 1;
      } else {
        return sin(PI * x2) / (PI * x2);
      }
    };
    makeLanczosWindow = function makeLanczosWindow2(a2) {
      return function(x2) {
        return sinc(x2 / a2);
      };
    };
    makeSincKernel = function makeSincKernel2(window2) {
      return function(x2) {
        return sinc(x2) * window2(x2);
      };
    };
    SincFilterInterpolator = function(_super) {
      __extends2(SincFilterInterpolator2, _super);
      function SincFilterInterpolator2(array4, config) {
        SincFilterInterpolator2.__super__.constructor.apply(this, arguments);
        this.a = config.sincFilterSize;
        if (!config.sincWindow) throw "No sincWindow provided";
        this.kernel = makeSincKernel(config.sincWindow);
      }
      SincFilterInterpolator2.prototype.interpolate = function(t2) {
        var k3, n2, sum, _ref, _ref2;
        k3 = Math.floor(t2);
        sum = 0;
        for (n2 = _ref = k3 - this.a + 1, _ref2 = k3 + this.a; _ref <= _ref2 ? n2 <= _ref2 : n2 >= _ref2; _ref <= _ref2 ? n2++ : n2--) {
          sum += this.kernel(t2 - n2) * this.getClippedInput(n2);
        }
        return sum;
      };
      return SincFilterInterpolator2;
    }(AbstractInterpolator);
    getColumn = function getColumn2(arr, i2) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        row = arr[_i];
        _results.push(row[i2]);
      }
      return _results;
    };
    makeScaledFunction = function makeScaledFunction2(f2, baseScale, scaleRange) {
      var scaleFactor, translation;
      if (scaleRange.join === "0,1") {
        return f2;
      } else {
        scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
        translation = scaleRange[0];
        return function(t2) {
          return f2(scaleFactor * (t2 - translation));
        };
      }
    };
    getType = function getType3(x2) {
      return Object.prototype.toString.call(x2).slice("[object ".length, -1);
    };
    validateNumber = function validateNumber2(n2) {
      if (isNaN(n2)) throw "NaN in Smooth() input";
      if (getType(n2) !== "Number") throw "Non-number in Smooth() input";
      if (!isFinite(n2)) throw "Infinity in Smooth() input";
    };
    validateVector = function validateVector2(v3, dimension) {
      var n2, _i, _len;
      if (getType(v3) !== "Array") throw "Non-vector in Smooth() input";
      if (v3.length !== dimension) throw "Inconsistent dimension in Smooth() input";
      for (_i = 0, _len = v3.length; _i < _len; _i++) {
        n2 = v3[_i];
        validateNumber(n2);
      }
    };
    isValidNumber = function isValidNumber2(n2) {
      return getType(n2) === "Number" && isFinite(n2) && !isNaN(n2);
    };
    normalizeScaleTo = function normalizeScaleTo2(s2) {
      var invalidErr;
      invalidErr = "scaleTo param must be number or array of two numbers";
      switch (getType(s2)) {
        case "Number":
          if (!isValidNumber(s2)) throw invalidErr;
          s2 = [0, s2];
          break;
        case "Array":
          if (s2.length !== 2) throw invalidErr;
          if (!(isValidNumber(s2[0]) && isValidNumber(s2[1]))) throw invalidErr;
          break;
        default:
          throw invalidErr;
      }
      return s2;
    };
    shallowCopy = function shallowCopy2(obj) {
      var copy2, k3, v3;
      copy2 = {};
      for (k3 in obj) {
        if (!__hasProp.call(obj, k3)) continue;
        v3 = obj[k3];
        copy2[k3] = v3;
      }
      return copy2;
    };
    _Smooth = function Smooth2(arr, config) {
      var baseDomainEnd, dimension, i2, interpolator, interpolatorClass, interpolators, k3, n2, properties, smoothFunc, v3;
      if (config == null) config = {};
      properties = {};
      config = shallowCopy(config);
      properties.config = shallowCopy(config);
      if (config.scaleTo == null) config.scaleTo = config.period;
      if (config.sincFilterSize == null) {
        config.sincFilterSize = config.lanczosFilterSize;
      }
      for (k3 in defaultConfig) {
        if (!__hasProp.call(defaultConfig, k3)) continue;
        v3 = defaultConfig[k3];
        if (config[k3] == null) config[k3] = v3;
      }
      if (!(interpolatorClass = {
        nearest: NearestInterpolator,
        linear: LinearInterpolator,
        cubic: CubicInterpolator,
        lanczos: SincFilterInterpolator,
        sinc: SincFilterInterpolator
      }[config.method])) {
        throw "Invalid method: " + config.method;
      }
      if (config.method === "lanczos") {
        config.sincWindow = makeLanczosWindow(config.sincFilterSize);
      }
      if (arr.length < 2) throw "Array must have at least two elements";
      properties.count = arr.length;
      smoothFunc = function() {
        var _i, _j, _len, _len2;
        switch (getType(arr[0])) {
          case "Number":
            properties.dimension = "scalar";
            if (_Smooth.deepValidation) {
              for (_i = 0, _len = arr.length; _i < _len; _i++) {
                n2 = arr[_i];
                validateNumber(n2);
              }
            }
            interpolator = new interpolatorClass(arr, config);
            return function(t2) {
              return interpolator.interpolate(t2);
            };
          case "Array":
            properties.dimension = dimension = arr[0].length;
            if (!dimension) throw "Vectors must be non-empty";
            if (_Smooth.deepValidation) {
              for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
                v3 = arr[_j];
                validateVector(v3, dimension);
              }
            }
            interpolators = function() {
              var _results;
              _results = [];
              for (i2 = 0; 0 <= dimension ? i2 < dimension : i2 > dimension; 0 <= dimension ? i2++ : i2--) {
                _results.push(new interpolatorClass(getColumn(arr, i2), config));
              }
              return _results;
            }();
            return function(t2) {
              var interpolator2, _k, _len3, _results;
              _results = [];
              for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
                interpolator2 = interpolators[_k];
                _results.push(interpolator2.interpolate(t2));
              }
              return _results;
            };
          default:
            throw "Invalid element type: " + getType(arr[0]);
        }
      }();
      if (config.clip === "periodic") {
        baseDomainEnd = arr.length;
      } else {
        baseDomainEnd = arr.length - 1;
      }
      config.scaleTo || (config.scaleTo = baseDomainEnd);
      properties.domain = normalizeScaleTo(config.scaleTo);
      smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
      properties.domain.sort();
      for (k3 in properties) {
        if (!__hasProp.call(properties, k3)) continue;
        v3 = properties[k3];
        smoothFunc[k3] = v3;
      }
      return smoothFunc;
    };
    for (k2 in Enum) {
      if (!__hasProp.call(Enum, k2)) continue;
      v2 = Enum[k2];
      _Smooth[k2] = v2;
    }
    _Smooth.deepValidation = true;
    (exports !== null ? exports : window).Smooth = _Smooth;
  }).call(commonjsGlobal);
})(Smooth);
var ResidueType = chem.ResidueType;
var calcMatrix = gfxutils.calcChunkMatrix;
function _buildStructureInterpolator(points, tension) {
  var path = Smooth.Smooth(points, {
    method: Smooth.Smooth.METHOD_CUBIC,
    clip: Smooth.Smooth.CLIP_CLAMP,
    cubicTension: tension,
    scaleTo: 1
  });
  return function(t2, argTrans) {
    var transformT = argTrans;
    if (transformT === null) {
      transformT = function transformT2(tt) {
        return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
      };
    }
    var newt = transformT(t2);
    var ans = path(newt);
    return new Vector3(ans[0], ans[1], ans[2]);
  };
}
function _addPoints(centerPoints, topPoints, idx, residue2) {
  if (!residue2._isValid) {
    centerPoints[idx] = centerPoints[idx - 1];
    topPoints[idx] = topPoints[idx - 1];
    return;
  }
  var cp = residue2._controlPoint;
  centerPoints[idx] = [cp.x, cp.y, cp.z];
  var tp = cp.clone().add(residue2._wingVector);
  topPoints[idx] = [tp.x, tp.y, tp.z];
}
function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue2) {
  var nucleic = (residue2._type.flags & ResidueType.Flags.NUCLEIC) !== 0;
  var nameFrom = nucleic ? "C5'" : "N";
  var nameTo = nucleic ? "C3'" : "C";
  var posFrom;
  var posTo;
  residue2.forEachAtom(function(atom) {
    var name2 = atom.getVisualName();
    if (!posFrom && name2 === nameFrom) {
      posFrom = atom.position;
    } else if (!posTo && name2 === nameTo) {
      posTo = atom.position;
    }
  });
  if (!(posFrom && posTo)) {
    posFrom = residue2._firstAtom.position;
    posTo = residue2._lastAtom.position;
  }
  if (posFrom && posTo) {
    var shift = posTo.clone().sub(posFrom);
    var wing = residue2._wingVector;
    var cp = residue2._controlPoint;
    var tp = cp.clone().add(wing);
    var cpPrev = cp.clone().sub(shift);
    var tpPrev = cpPrev.clone().add(wing);
    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
    ++idx;
    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
    ++idx;
    centerPoints[idx] = [cp.x, cp.y, cp.z];
    topPoints[idx] = [tp.x, tp.y, tp.z];
    ++idx;
    var cpNext = cp.clone().add(shift);
    var tpNext = cpNext.clone().add(wing);
    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
    ++idx;
    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
  }
}
function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
  var left = boundaries.start;
  var right = boundaries.end;
  function _prevIdx(idx2) {
    return idx2 > left && residues[idx2 - 1]._isValid ? idx2 - 1 : idx2;
  }
  function _nextIdx(idx2) {
    return idx2 < right && residues[idx2 + 1]._isValid ? idx2 + 1 : idx2;
  }
  var topPoints = [];
  var centerPoints = [];
  var arrIdx = 0;
  function _extrapolate2(currIdx, otherIdx) {
    var cp = residues[currIdx]._controlPoint.clone().lerp(residues[otherIdx]._controlPoint, -0.25);
    var tp = cp.clone().add(residues[currIdx]._wingVector);
    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
  }
  var prevIdx = _prevIdx(firstIdx);
  var nextIdx = _nextIdx(lastIdx);
  if (prevIdx === nextIdx) {
    _addPointsForLoneResidue(centerPoints, topPoints, arrIdx, residues[firstIdx]);
    return {
      centerPoints,
      topPoints
    };
  }
  if (firstIdx === prevIdx) {
    _extrapolate2(firstIdx, _nextIdx(firstIdx));
  } else {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);
    _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
  }
  for (var idx = firstIdx; idx <= lastIdx; ++idx) {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
  }
  if (nextIdx === _nextIdx(nextIdx)) {
    _extrapolate2(lastIdx, _prevIdx(lastIdx));
  } else {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);
    _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
  }
  return {
    centerPoints,
    topPoints
  };
}
var CartoonHelper = function() {
  function CartoonHelper2(residues, startIdx, endIdx, segmentsCount, tension, boundaries) {
    _classCallCheck(this, CartoonHelper2);
    var pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries);
    this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
    this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);
    this._shift = 0.5 / (endIdx - startIdx + 2);
    this._valueStep = (1 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
    this._segmentsCount = segmentsCount;
  }
  _createClass(CartoonHelper2, [{
    key: "prepareMatrices",
    value: function prepareMatrices(idx, firstRad, secondRad) {
      var mtcCount = this._segmentsCount;
      var outMtc = new Array(mtcCount);
      var currRad = new Vector2(0, 0);
      var topInterp = this._topInterp;
      var cenInterp = this._centerInterp;
      var currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;
      for (var mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
        var lerpVal = Math.min(1, mtxIdx / (mtcCount - 1));
        currRad.lerpVectors(firstRad, secondRad, lerpVal);
        var currTop = topInterp(currentValue, null);
        var currCenter = cenInterp(currentValue, null);
        currentValue += this._valueStep;
        var nextCenter = cenInterp(currentValue, null);
        outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
      }
      return outMtc;
    }
  }]);
  return CartoonHelper2;
}();
function _createSuper$1b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1b() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _createShape(rad, parts) {
  var pts = [];
  for (var i2 = 0; i2 < parts; ++i2) {
    var a2 = Math.PI / 2 - 2 * Math.PI * i2 / parts;
    pts.push(new Vector3(Math.cos(a2) * rad, Math.sin(a2) * rad, 0));
  }
  return pts;
}
function _loopThrough(subDiv, residues, segmentsHeight, tension, mode2, callback) {
  for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
    var subs = subDiv[subDivI].arr;
    var boundaries = subDiv[subDivI].boundaries;
    for (var i2 = 0, n2 = subs.length; i2 < n2; ++i2) {
      var idc = [subs[i2].start, subs[i2].end];
      var matrixHelper = new CartoonHelper(residues, idc[0], idc[1], segmentsHeight, tension, boundaries);
      var prevLast = null;
      var startIdx = subs[i2].start * 2;
      var endIdx = subs[i2].end * 2 + 1;
      var prevSecondRad = mode2.getResidueRadius(residues[0], 0);
      for (var idx = startIdx; idx <= endIdx; ++idx) {
        var resIdx = idx / 2 | 0;
        var currRes = residues[resIdx];
        var firstRad = mode2.getResidueRadius(currRes, idx % 2);
        var secondRad = mode2.getResidueRadius(currRes, 1 + idx % 2);
        var mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
        mtc.unshift(prevLast === null ? mtc[0] : prevLast);
        var hasSlope = firstRad.x !== secondRad.x || firstRad.y !== secondRad.y;
        var hasCut = firstRad.x !== prevSecondRad.x || firstRad.y !== prevSecondRad.y;
        callback(currRes, mtc, hasSlope, hasCut);
        prevLast = mtc[segmentsHeight];
        prevSecondRad = secondRad;
      }
    }
  }
}
var ResiduesSubseqGroup = function(_ResiduesGroup) {
  _inherits(ResiduesSubseqGroup2, _ResiduesGroup);
  var _super = _createSuper$1b(ResiduesSubseqGroup2);
  function ResiduesSubseqGroup2() {
    _classCallCheck(this, ResiduesSubseqGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(ResiduesSubseqGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      var cmpMultiplier = this._mode.getHeightSegmentsRatio();
      this._segmentsHeight = this._polyComplexity * cmpMultiplier | 0;
      return [_createShape(1, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length * 2];
    }
  }, {
    key: "_build",
    value: function _build() {
      var _this$_selection = this._selection, residues = _this$_selection.residues, parent = _this$_selection.parent;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var tension = mode2.getTension();
      var geo = this._geo;
      var chunkIdx = 0;
      var chunkIdc = [];
      _loopThrough(this._selection.subdivs, residues, this._segmentsHeight, tension, mode2, function(currRes, mtc) {
        var hasSlope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var hasCut = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        var color2 = colorer.getResidueColor(currRes, parent);
        chunkIdc[chunkIdx] = currRes._index;
        geo.setItem(chunkIdx, mtc, hasSlope, hasCut);
        geo.setColor(chunkIdx++, color2);
      });
      this._chunksIdc = chunkIdc;
      geo.finalize();
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var parent = this._selection.parent;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var tension = mode2.getTension();
      var geo = this._geo;
      var frameRes = frameData.getResidues();
      var chunkIdx = 0;
      var updateColor = frameData.needsColorUpdate(colorer);
      _loopThrough(this._selection.subdivs, frameRes, this._segmentsHeight, tension, mode2, function(currRes, mtc) {
        geo.setItem(chunkIdx, mtc);
        if (updateColor) {
          geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent));
        }
        chunkIdx++;
      });
      geo.finalize();
    }
  }]);
  return ResiduesSubseqGroup2;
}(ResiduesGroup);
function _createSuper$1a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ResiduesTraceGroup = function(_ChemGroup) {
  _inherits(ResiduesTraceGroup2, _ChemGroup);
  var _super = _createSuper$1a(ResiduesTraceGroup2);
  function ResiduesTraceGroup2() {
    _classCallCheck(this, ResiduesTraceGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(ResiduesTraceGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      var subDiv = this._selection.subdivs;
      var chunksCount = 0;
      for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
        var subs = subDiv[subDivI].arr;
        for (var i2 = 0, n2 = subs.length; i2 < n2; ++i2) {
          chunksCount += subs[i2].end - subs[i2].start;
        }
      }
      return [chunksCount, this._polyComplexity];
    }
  }, {
    key: "_build",
    value: function _build() {
      var _this$_selection = this._selection, residues = _this$_selection.residues, parent = _this$_selection.parent;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var geo = this._geo;
      var chunkIdx = 0;
      var chunkIdc = [];
      var subDiv = this._selection.subdivs;
      var stickRad = mode2.calcStickRadius();
      for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
        var subs = subDiv[subDivI].arr;
        for (var i2 = 0, n2 = subs.length; i2 < n2; ++i2) {
          var startIdx = subs[i2].start;
          var endIdx = subs[i2].end;
          var prevRes = residues[startIdx];
          for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
            var currRes = residues[idx];
            chunkIdc[chunkIdx] = {
              first: prevRes._index,
              second: currRes._index
            };
            geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
            geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
            chunkIdx++;
            prevRes = currRes;
          }
        }
      }
      this._chunksIdc = chunkIdc;
      geo.finalize();
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var residues = frameData.getResidues();
      var parent = this._selection.parent;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var geo = this._geo;
      var chunkIdx = 0;
      var subDiv = this._selection.subdivs;
      var stickRad = mode2.calcStickRadius();
      var updateColor = frameData.needsColorUpdate(colorer);
      for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
        var subs = subDiv[subDivI].arr;
        for (var i2 = 0, n2 = subs.length; i2 < n2; ++i2) {
          var startIdx = subs[i2].start;
          var endIdx = subs[i2].end;
          var prevRes = residues[startIdx];
          for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
            var currRes = residues[idx];
            geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
            if (updateColor) {
              geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
            }
            chunkIdx++;
            prevRes = currRes;
          }
        }
      }
      geo.finalize();
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var inters = [];
      var residues = this._selection.residues;
      this._mesh.raycast(raycaster, inters);
      var chunksToIdx = this._chunksIdc;
      for (var i2 = 0, n2 = inters.length; i2 < n2; ++i2) {
        if (!inters[i2].hasOwnProperty("chunkIdx")) {
          continue;
        }
        var chunkIdx = inters[i2].chunkIdx;
        var chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
        var resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;
        if (resIdx < residues.length) {
          inters[i2].residue = residues[resIdx];
          intersects2.push(inters[i2]);
        }
      }
    }
  }, {
    key: "_calcChunksList",
    value: function _calcChunksList(mask) {
      var chunksList = [];
      var chunksToIdx = this._chunksIdc;
      var residues = this._selection.residues;
      for (var i2 = 0, n2 = chunksToIdx.length; i2 < n2; ++i2) {
        var chunk = chunksToIdx[i2];
        if (residues[chunk.first]._mask & mask) {
          chunksList.push(i2 * 2);
        }
        if (residues[chunk.second]._mask & mask) {
          chunksList.push(i2 * 2 + 1);
        }
      }
      return chunksList;
    }
  }]);
  return ResiduesTraceGroup2;
}(ChemGroup);
function _createSuper$19(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$19();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$19() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function getCylinderCount(bondOrder) {
  return bondOrder < 2 ? 1 : bondOrder;
}
var BondsGroup = function(_ChemGroup) {
  _inherits(BondsGroup2, _ChemGroup);
  var _super = _createSuper$19(BondsGroup2);
  function BondsGroup2() {
    _classCallCheck(this, BondsGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(BondsGroup2, [{
    key: "_makeGeoArgs",
    value: function _makeGeoArgs() {
      var drawMultiple = this._mode.drawMultiorderBonds();
      var showAromatic = this._mode.showAromaticLoops();
      var bondsIdc = this._selection.chunks;
      var bonds = this._selection.bonds;
      var bondsCount = 0;
      for (var i2 = 0, n2 = bondsIdc.length; i2 < n2; ++i2) {
        bondsCount += this.getBondOrder(bonds[bondsIdc[i2]], drawMultiple, showAromatic);
      }
      return [bondsCount, this._polyComplexity];
    }
  }, {
    key: "getBondOrder",
    value: function getBondOrder(bond, drawMultiple, showAromatic) {
      var bondOrder = 1;
      if (drawMultiple && (!showAromatic || bond._type !== Bond$5.BondType.AROMATIC)) {
        bondOrder = getCylinderCount(bond._order);
      }
      return bondOrder;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects2) {
      var bonds = this._selection.bonds;
      var inters = [];
      this._mesh.raycast(raycaster, inters);
      var bondsIdc = this._chunksIdc;
      for (var i2 = 0, n2 = inters.length; i2 < n2; ++i2) {
        if (!inters[i2].hasOwnProperty("chunkIdx")) {
          continue;
        }
        var chunkIdx = inters[i2].chunkIdx;
        var bondIdx = bondsIdc[Math.floor(chunkIdx / 2)];
        if (bondIdx < bonds.length) {
          var bond = bonds[bondIdx];
          inters[i2].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
          intersects2.push(inters[i2]);
        }
      }
    }
  }, {
    key: "_calcChunksList",
    value: function _calcChunksList(mask, innerOnly) {
      var chunksList = [];
      var bonds = this._selection.bonds;
      var chunksToIdx = this._chunksIdc;
      for (var i2 = 0, n2 = chunksToIdx.length; i2 < n2; ++i2) {
        var bond = bonds[chunksToIdx[i2]];
        if (bond._left.mask & mask && (!innerOnly || bond._right.mask & mask)) {
          chunksList.push(2 * i2);
        }
        if (bond._right.mask & mask && (!innerOnly || bond._left.mask & mask)) {
          chunksList.push(2 * i2 + 1);
        }
      }
      return chunksList;
    }
  }]);
  return BondsGroup2;
}(ChemGroup);
function _createSuper$18(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$18();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$18() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var BondsCylinderGroup = function(_BondsGroup) {
  _inherits(BondsCylinderGroup2, _BondsGroup);
  var _super = _createSuper$18(BondsCylinderGroup2);
  function BondsCylinderGroup2() {
    _classCallCheck(this, BondsCylinderGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(BondsCylinderGroup2, [{
    key: "_build",
    value: function _build() {
      var bondsIdc = this._selection.chunks;
      var _this$_selection = this._selection, bonds = _this$_selection.bonds, parent = _this$_selection.parent;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var geo = this._geo;
      var drawMultiple = mode2.drawMultiorderBonds();
      var showAromatic = mode2.showAromaticLoops();
      var stickRad = mode2.calcStickRadius();
      var emptyOffset = mode2.calcSpaceFraction();
      var normDir;
      var leftPos = new Vector3();
      var rightPos = new Vector3();
      var currBondIdx = 0;
      var chunksToIdx = [];
      for (var i2 = 0, n2 = bondsIdc.length; i2 < n2; ++i2) {
        var bond = bonds[bondsIdc[i2]];
        var atom1 = bond._left;
        var atom2 = bond._right;
        var a1Pos = atom1.position;
        var a2Pos = atom2.position;
        normDir = bond.calcNormalDir();
        var order = this.getBondOrder(bond, drawMultiple, showAromatic);
        var minRad = Math.min(mode2.calcAtomRadius(atom1), mode2.calcAtomRadius(atom2));
        var dist = 2 * minRad / order;
        var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1 - emptyOffset)) : stickRad;
        for (var j2 = 0; j2 < order; ++j2) {
          var scale = dist * (order % 2 === 0 ? ((j2 / 2 | 0) + 0.5) * (1 - 2 * (j2 % 2)) : ((j2 + 1) / 2 | 0) * (-1 + 2 * (j2 % 2)));
          chunksToIdx[currBondIdx] = bond._index;
          leftPos.copy(a1Pos);
          leftPos.addScaledVector(normDir, scale);
          rightPos.copy(a2Pos);
          rightPos.addScaledVector(normDir, scale);
          geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
          geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
        }
      }
      geo.finalize();
      this._chunksIdc = chunksToIdx;
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var bondsIdc = this._selection.chunks;
      var bonds = this._selection.bonds;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var geo = this._geo;
      var drawMultiple = mode2.drawMultiorderBonds();
      var showAromatic = mode2.showAromaticLoops();
      var stickRad = mode2.calcStickRadius();
      var emptyOffset = mode2.calcSpaceFraction();
      var normDir;
      var leftPos = new Vector3();
      var rightPos = new Vector3();
      var currBondIdx = 0;
      var updateColor = frameData.needsColorUpdate(colorer);
      for (var i2 = 0, n2 = bondsIdc.length; i2 < n2; ++i2) {
        var bond = bonds[bondsIdc[i2]];
        var atom1 = bond._left;
        var atom2 = bond._right;
        var a1Pos = frameData.getAtomPos(atom1.index).clone();
        var a2Pos = frameData.getAtomPos(atom2.index);
        normDir = bond.calcNormalDir();
        var order = this.getBondOrder(bond, drawMultiple, showAromatic);
        var minRad = Math.min(mode2.calcAtomRadius(atom1), mode2.calcAtomRadius(atom2));
        var dist = 2 * minRad / order;
        var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1 - emptyOffset)) : stickRad;
        for (var j2 = 0; j2 < order; ++j2) {
          var scale = dist * (order % 2 === 0 ? ((j2 / 2 | 0) + 0.5) * (1 - 2 * (j2 % 2)) : ((j2 + 1) / 2 | 0) * (-1 + 2 * (j2 % 2)));
          leftPos.copy(a1Pos);
          leftPos.addScaledVector(normDir, scale);
          rightPos.copy(a2Pos);
          rightPos.addScaledVector(normDir, scale);
          geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
          if (updateColor) {
            geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
          }
          currBondIdx++;
        }
      }
      geo.finalize();
    }
  }]);
  return BondsCylinderGroup2;
}(BondsGroup);
function _createSuper$17(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$17();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$17() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var STEP_SIZE = 0.15;
var BondsLinesGroup = function(_BondsGroup) {
  _inherits(BondsLinesGroup2, _BondsGroup);
  var _super = _createSuper$17(BondsLinesGroup2);
  function BondsLinesGroup2() {
    _classCallCheck(this, BondsLinesGroup2);
    return _super.apply(this, arguments);
  }
  _createClass(BondsLinesGroup2, [{
    key: "_build",
    value: function _build() {
      var bondsIdc = this._selection.chunks;
      var _this$_selection = this._selection, bonds = _this$_selection.bonds, parent = _this$_selection.parent;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var geo = this._geo;
      var drawMultiple = mode2.drawMultiorderBonds();
      var showAromatic = mode2.showAromaticLoops();
      var bondDir = new Vector3();
      var leftPos = new Vector3();
      var rightPos = new Vector3();
      var currBondIdx = 0;
      var chunksToIdx = [];
      for (var i2 = 0, n2 = bondsIdc.length; i2 < n2; ++i2) {
        var bond = bonds[bondsIdc[i2]];
        var atom1 = bond._left;
        var atom2 = bond._right;
        var a1Pos = atom1.position;
        var a2Pos = atom2.position;
        var a1Hangs = atom1.bonds.length === 1;
        var a2Hangs = atom2.bonds.length === 1;
        bondDir.subVectors(a2Pos, a1Pos);
        var len = bondDir.length();
        var normDir = bond.calcNormalDir();
        var order = this.getBondOrder(bond, drawMultiple, showAromatic);
        for (var j2 = 0; j2 < order; ++j2) {
          leftPos.copy(a1Pos);
          rightPos.copy(a2Pos);
          var scale = order % 2 === 0 ? ((j2 / 2 | 0) + 0.5) * (1 - 2 * (j2 % 2)) : ((j2 + 1) / 2 | 0) * (-1 + 2 * (j2 % 2));
          chunksToIdx[currBondIdx] = bond._index;
          if (order === 2 && !a1Hangs && !a2Hangs) {
            scale -= 0.5;
            scale *= -1;
          }
          if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
            leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
            rightPos.lerpVectors(a1Pos, a2Pos, 1 - STEP_SIZE / len);
          }
          scale *= STEP_SIZE;
          leftPos.addScaledVector(normDir, scale);
          rightPos.addScaledVector(normDir, scale);
          geo.setItem(currBondIdx, leftPos, rightPos);
          geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
        }
      }
      geo.finalize();
      this._chunksIdc = chunksToIdx;
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      var bondsIdc = this._selection.chunks;
      var bonds = this._selection.bonds;
      var mode2 = this._mode;
      var colorer = this._colorer;
      var geo = this._geo;
      var drawMultiple = mode2.drawMultiorderBonds();
      var showAromatic = mode2.showAromaticLoops();
      var bondDir = new Vector3();
      var leftPos = new Vector3();
      var rightPos = new Vector3();
      var currBondIdx = 0;
      var updateColor = frameData.needsColorUpdate(colorer);
      for (var i2 = 0, n2 = bondsIdc.length; i2 < n2; ++i2) {
        var bond = bonds[bondsIdc[i2]];
        var atom1 = bond._left;
        var atom2 = bond._right;
        var a1Pos = frameData.getAtomPos(atom1.index).clone();
        var a2Pos = frameData.getAtomPos(atom2.index);
        var a1Hangs = atom1.bonds.length === 1;
        var a2Hangs = atom2.bonds.length === 1;
        bondDir.subVectors(a2Pos, a1Pos);
        var len = bondDir.length();
        var normDir = bond.calcNormalDir();
        var order = this.getBondOrder(bond, drawMultiple, showAromatic);
        for (var j2 = 0; j2 < order; ++j2) {
          leftPos.copy(a1Pos);
          rightPos.copy(a2Pos);
          var scale = order % 2 === 0 ? ((j2 / 2 | 0) + 0.5) * (1 - 2 * (j2 % 2)) : ((j2 + 1) / 2 | 0) * (-1 + 2 * (j2 % 2));
          if (order === 2 && !a1Hangs && !a2Hangs) {
            scale -= 0.5;
            scale *= -1;
          }
          if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
            leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
            rightPos.lerpVectors(a1Pos, a2Pos, 1 - STEP_SIZE / len);
          }
          scale *= STEP_SIZE;
          leftPos.addScaledVector(normDir, scale);
          rightPos.addScaledVector(normDir, scale);
          geo.setItem(currBondIdx, leftPos, rightPos);
          if (updateColor) {
            geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
          }
          currBondIdx++;
        }
      }
      geo.finalize();
    }
  }]);
  return BondsLinesGroup2;
}(BondsGroup);
var groups = {
  AtomsSphereGroup,
  AtomsSurfaceGroup,
  AtomsSASSESGroupStub,
  AtomsTextGroup,
  AromaticTorusGroup,
  AromaticLinesGroup,
  NucleicCylindersGroup,
  NucleicSpheresGroup,
  ResiduesSubseqGroup,
  ResiduesTraceGroup,
  BondsCylinderGroup,
  BondsLinesGroup
};
function _createSuper$16(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$16();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$16() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AtomsProcessor = function(_RCGroup) {
  _inherits(AtomsProcessor2, _RCGroup);
  var _super = _createSuper$16(AtomsProcessor2);
  function AtomsProcessor2(AtomsGroup2, geoParams, complex, colorer, mode2, polyComplexity, mask, material2) {
    var _this;
    _classCallCheck(this, AtomsProcessor2);
    _this = _super.call(this);
    var self2 = _assertThisInitialized(_this);
    _this._complex = complex;
    _this._mode = mode2;
    var atoms = complex.getAtoms();
    var transforms = complex.getTransforms();
    complex.forEachComponent(function(component) {
      var atomsIdc = [];
      var atomCount = 0;
      component.forEachAtom(function(atom) {
        if (!self2._checkAtom(atom, mask)) {
          return;
        }
        atomsIdc[atomCount++] = atom.index;
      });
      if (atomCount === 0) {
        return;
      }
      var atomsGroup = new AtomsGroup2(geoParams, {
        atoms,
        chunks: atomsIdc,
        parent: complex
      }, colorer, mode2, transforms, polyComplexity, material2);
      atomsGroup._component = component;
      self2.add(atomsGroup);
    });
    return _this;
  }
  _createClass(AtomsProcessor2, [{
    key: "_checkAtom",
    value: function _checkAtom(atom, mask) {
      return atom.mask & mask;
    }
  }, {
    key: "getSubset",
    value: function getSubset2(mask, innerOnly) {
      var totalSubset = [];
      var children = this.children;
      var meshIdx = 0;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].getSubset) {
          var chSubset = children[i2].getSubset(mask, innerOnly);
          for (var j2 = 0, m2 = chSubset.length; j2 < m2; ++j2) {
            var subsetEl = chSubset[j2];
            subsetEl._component = children[i2]._component;
            totalSubset[meshIdx++] = subsetEl;
          }
        }
      }
      return totalSubset;
    }
  }]);
  return AtomsProcessor2;
}(RCGroup);
function _createSuper$15(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$15();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$15() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OrphanAtomsProcessor = function(_AtomsProcessor) {
  _inherits(OrphanAtomsProcessor2, _AtomsProcessor);
  var _super = _createSuper$15(OrphanAtomsProcessor2);
  function OrphanAtomsProcessor2() {
    _classCallCheck(this, OrphanAtomsProcessor2);
    return _super.apply(this, arguments);
  }
  _createClass(OrphanAtomsProcessor2, [{
    key: "_checkAtom",
    value: function _checkAtom(atom, mask) {
      if (!(atom.mask & mask)) {
        return false;
      }
      var bonds = atom.bonds;
      for (var i2 = 0, n2 = bonds.length; i2 < n2; ++i2) {
        if (bonds[i2]._left.mask & mask && bonds[i2]._right.mask & mask) {
          return false;
        }
      }
      return true;
    }
  }]);
  return OrphanAtomsProcessor2;
}(AtomsProcessor);
function _createSuper$14(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$14();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$14() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ResiduesProcessor = function(_RCGroup) {
  _inherits(ResiduesProcessor2, _RCGroup);
  var _super = _createSuper$14(ResiduesProcessor2);
  function ResiduesProcessor2(ResidueGroup, geoParams, complex, colorer, mode2, polyComplexity, mask, material2) {
    var _this;
    _classCallCheck(this, ResiduesProcessor2);
    _this = _super.call(this);
    var self2 = _assertThisInitialized(_this);
    _this._complex = complex;
    var residues = complex.getResidues();
    var transforms = complex.getTransforms();
    complex.forEachComponent(function(component) {
      var chunksCount = 0;
      var resIdc = [];
      component.forEachResidue(function(residue2) {
        if (self2._checkResidue(residue2, mask)) {
          resIdc[chunksCount++] = residue2._index;
        }
      });
      if (chunksCount === 0) {
        return;
      }
      var residuesGroup = new ResidueGroup(geoParams, {
        residues,
        chunks: resIdc,
        parent: complex
      }, colorer, mode2, transforms, polyComplexity, material2);
      residuesGroup._component = component;
      self2.add(residuesGroup);
    });
    return _this;
  }
  _createClass(ResiduesProcessor2, [{
    key: "checkResidue",
    value: function checkResidue(residue2, mask) {
      return residue2._mask & mask;
    }
  }, {
    key: "getSubset",
    value: function getSubset2(mask, innerOnly) {
      var totalSubset = [];
      var children = this.children;
      var meshIdx = 0;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].getSubset) {
          var chSubset = children[i2].getSubset(mask, innerOnly);
          for (var j2 = 0, m2 = chSubset.length; j2 < m2; ++j2) {
            var subsetEl = chSubset[j2];
            subsetEl._component = children[i2]._component;
            totalSubset[meshIdx++] = subsetEl;
          }
        }
      }
      return totalSubset;
    }
  }]);
  return ResiduesProcessor2;
}(RCGroup);
function _createSuper$13(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$13();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$13() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var NucleicProcessor = function(_ResidueProcessor) {
  _inherits(NucleicProcessor2, _ResidueProcessor);
  var _super = _createSuper$13(NucleicProcessor2);
  function NucleicProcessor2() {
    _classCallCheck(this, NucleicProcessor2);
    return _super.apply(this, arguments);
  }
  _createClass(NucleicProcessor2, [{
    key: "_checkResidue",
    value: function _checkResidue(residue2, mask) {
      return mask & residue2._mask && residue2._cylinders !== null;
    }
  }]);
  return NucleicProcessor2;
}(ResiduesProcessor);
function _createSuper$12(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$12();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$12() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var SubseqsProcessor = function(_RCGroup) {
  _inherits(SubseqsProcessor2, _RCGroup);
  var _super = _createSuper$12(SubseqsProcessor2);
  function SubseqsProcessor2(ResidueGroup, geoParams, complex, colorer, mode2, polyComplexity, mask, material2) {
    var _this;
    _classCallCheck(this, SubseqsProcessor2);
    _this = _super.call(this);
    var self2 = _assertThisInitialized(_this);
    _this._complex = complex;
    var residues = complex.getResidues();
    var transforms = complex.getTransforms();
    complex.forEachComponent(function(component) {
      var subDivs = component.getMaskedSubdivSequences(mask);
      var chunksCount = 0;
      var resIdc = [];
      for (var subDivI = 0, subDivN = subDivs.length; subDivI < subDivN; ++subDivI) {
        var subs = subDivs[subDivI].arr;
        for (var i2 = 0, n2 = subs.length; i2 < n2; ++i2) {
          for (var j2 = subs[i2].start, jEnd = subs[i2].end; j2 <= jEnd; ++j2) {
            resIdc[chunksCount++] = residues[j2]._index;
          }
        }
      }
      if (chunksCount === 0) {
        return;
      }
      var residuesGroup = new ResidueGroup(geoParams, {
        residues,
        chunks: resIdc,
        subdivs: subDivs,
        parent: complex
      }, colorer, mode2, transforms, polyComplexity, material2);
      residuesGroup._component = component;
      self2.add(residuesGroup);
    });
    return _this;
  }
  _createClass(SubseqsProcessor2, [{
    key: "getSubset",
    value: function getSubset2(mask, innerOnly) {
      var totalSubset = [];
      var children = this.children;
      var meshIdx = 0;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].getSubset) {
          var chSubset = children[i2].getSubset(mask, innerOnly);
          for (var j2 = 0, m2 = chSubset.length; j2 < m2; ++j2) {
            var subsetEl = chSubset[j2];
            subsetEl._component = children[i2]._component;
            totalSubset[meshIdx++] = subsetEl;
          }
        }
      }
      return totalSubset;
    }
  }]);
  return SubseqsProcessor2;
}(RCGroup);
function _createSuper$11(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$11();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$11() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var BondsProcessor = function(_RCGroup) {
  _inherits(BondsProcessor2, _RCGroup);
  var _super = _createSuper$11(BondsProcessor2);
  function BondsProcessor2(BondsGroup2, geoParams, complex, colorer, mode2, polyComplexity, mask, material2) {
    var _this;
    _classCallCheck(this, BondsProcessor2);
    _this = _super.call(this);
    var self2 = _assertThisInitialized(_this);
    _this._complex = complex;
    var bonds = complex.getBonds();
    var transforms = complex.getTransforms();
    complex.forEachComponent(function(component) {
      var bondsIdc = [];
      var bondsCount = 0;
      component.forEachBond(function(bond) {
        var atom1 = bond._left;
        var atom2 = bond._right;
        if (!(atom1.mask & mask) || !(atom2.mask & mask)) {
          return;
        }
        bondsIdc[bondsCount++] = bond._index;
      });
      if (bondsCount === 0) {
        return;
      }
      var bondsGroup = new BondsGroup2(geoParams, {
        bonds,
        chunks: bondsIdc,
        parent: complex
      }, colorer, mode2, transforms, polyComplexity, material2);
      bondsGroup._component = component;
      self2.add(bondsGroup);
    });
    return _this;
  }
  _createClass(BondsProcessor2, [{
    key: "getSubset",
    value: function getSubset2(mask, innerOnly) {
      var totalSubset = [];
      var children = this.children;
      var meshIdx = 0;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].getSubset) {
          var chSubset = children[i2].getSubset(mask, innerOnly);
          for (var j2 = 0, m2 = chSubset.length; j2 < m2; ++j2) {
            var subsetEl = chSubset[j2];
            subsetEl._component = children[i2]._component;
            totalSubset[meshIdx++] = subsetEl;
          }
        }
      }
      return totalSubset;
    }
  }]);
  return BondsProcessor2;
}(RCGroup);
function _createSuper$10(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$10();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$10() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AromaticProcessor = function(_RCGroup) {
  _inherits(AromaticProcessor2, _RCGroup);
  var _super = _createSuper$10(AromaticProcessor2);
  function AromaticProcessor2(AromaticGroup2, geoParams, complex, colorer, mode2, polyComplexity, mask, material2) {
    var _this;
    _classCallCheck(this, AromaticProcessor2);
    _this = _super.call(this);
    var self2 = _assertThisInitialized(_this);
    _this._complex = complex;
    var atoms = complex.getAtoms();
    var transforms = complex.getTransforms();
    if (!mode2.showAromaticLoops()) {
      return _possibleConstructorReturn(_this);
    }
    complex.forEachComponent(function(component) {
      var atomsIdc = [];
      var chunksCount = 0;
      var cycles = [];
      var cycleIdx = 0;
      component.forEachCycle(function(cycle) {
        var cycAtoms = cycle.atoms;
        var perCycle = 0;
        for (var i2 = 0, n2 = cycAtoms.length; i2 < n2; ++i2) {
          if ((cycAtoms[i2].mask & mask) !== 0) {
            ++perCycle;
            atomsIdc[chunksCount++] = cycAtoms[i2].index;
          }
        }
        if (perCycle > 0) {
          cycles[cycleIdx++] = cycle;
        }
      });
      var atomsGroup = new AromaticGroup2(geoParams, {
        cycles,
        atoms,
        chunks: atomsIdc,
        parent: complex
      }, colorer, mode2, transforms, polyComplexity, material2);
      atomsGroup._component = component;
      self2.add(atomsGroup);
    });
    return _this;
  }
  _createClass(AromaticProcessor2, [{
    key: "getSubset",
    value: function getSubset2(mask, innerOnly) {
      var totalSubset = [];
      var children = this.children;
      var meshIdx = 0;
      for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        if (children[i2].getSubset) {
          var chSubset = children[i2].getSubset(mask, innerOnly);
          for (var j2 = 0, m2 = chSubset.length; j2 < m2; ++j2) {
            var subsetEl = chSubset[j2];
            subsetEl._component = children[i2]._component;
            totalSubset[meshIdx++] = subsetEl;
          }
        }
      }
      return totalSubset;
    }
  }]);
  return AromaticProcessor2;
}(RCGroup);
var processors = {
  Atoms: AtomsProcessor,
  OrphanAtoms: OrphanAtomsProcessor,
  Residues: ResiduesProcessor,
  Nucleic: NucleicProcessor,
  Subseqs: SubseqsProcessor,
  Bonds: BondsProcessor,
  Aromatic: AromaticProcessor
};
function _bakeGroup(triplet, Processor, Group2) {
  return function(complex, colorer, mode2, polyComplexity, mask, material2) {
    return new Processor(Group2, triplet, complex, colorer, mode2, polyComplexity, mask, material2);
  };
}
var GroupsFactory = function() {
  function GroupsFactory2() {
    _classCallCheck(this, GroupsFactory2);
  }
  _createClass(GroupsFactory2, null, [{
    key: "AtomsSpheres",
    value: function AtomsSpheres(caps, settings2) {
      var gfxTriplet = MeshCreator.createSpheres(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSphereGroup);
    }
  }, {
    key: "OrphanedAtomsCrosses",
    value: function OrphanedAtomsCrosses(caps, settings2, renderParams) {
      var gfxTriplet = MeshCreator.createCrosses(caps, settings2, renderParams);
      return _bakeGroup(gfxTriplet, processors.OrphanAtoms, groups.AtomsSphereGroup);
    }
  }, {
    key: "BondsCylinders",
    value: function BondsCylinders(caps, settings2) {
      var gfxTriplet = MeshCreator.create2CCylinders(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsCylinderGroup);
    }
  }, {
    key: "BondsLines",
    value: function BondsLines(caps, settings2, renderParams) {
      var gfxTriplet = MeshCreator.create2CLines(caps, settings2, renderParams);
      return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsLinesGroup);
    }
  }, {
    key: "CartoonChains",
    value: function CartoonChains(caps, settings2) {
      var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesSubseqGroup);
    }
  }, {
    key: "TraceChains",
    value: function TraceChains(caps, settings2) {
      var gfxTriplet = MeshCreator.create2CClosedCylinders(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesTraceGroup);
    }
  }, {
    key: "NucleicSpheres",
    value: function NucleicSpheres(caps, settings2) {
      var gfxTriplet = MeshCreator.createSpheres(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicSpheresGroup);
    }
  }, {
    key: "NucleicCylinders",
    value: function NucleicCylinders(caps, settings2) {
      var gfxTriplet = MeshCreator.create2CCylinders(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicCylindersGroup);
    }
  }, {
    key: "ALoopsTorus",
    value: function ALoopsTorus(caps, settings2) {
      var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticTorusGroup);
    }
  }, {
    key: "ALoopsLines",
    value: function ALoopsLines(caps, settings2, renderParams) {
      var gfxTriplet = MeshCreator.createChunkedLines(caps, settings2, renderParams);
      return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticLinesGroup);
    }
  }, {
    key: "QuickSurfGeo",
    value: function QuickSurfGeo(caps, settings2, renderParams) {
      var gfxTriplet = MeshCreator.createQuickSurface(caps, settings2, renderParams);
      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
    }
  }, {
    key: "ContactSurfaceGeo",
    value: function ContactSurfaceGeo(caps, settings2, renderParams) {
      var gfxTriplet = MeshCreator.createContactSurface(caps, settings2, renderParams);
      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
    }
  }, {
    key: "SASSESSurfaceGeo",
    value: function SASSESSurfaceGeo(caps, settings2, renderParams) {
      var gfxTriplet = MeshCreator.createSASSES(caps, settings2, renderParams);
      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSASSESGroupStub);
    }
  }, {
    key: "TextLabelsGeo",
    value: function TextLabelsGeo(caps, settings2) {
      var gfxTriplet = MeshCreator.createLabels(caps, settings2);
      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup);
    }
  }]);
  return GroupsFactory2;
}();
var Mode = function() {
  function Mode2(opts) {
    _classCallCheck(this, Mode2);
    if (this.constructor === Mode2) {
      throw new Error("Can not instantiate abstract class!");
    }
    this.opts = (0, import_lodash.merge)(utils.deriveDeep(this.settings.now.modes[this.id], true), opts);
  }
  _createClass(Mode2, [{
    key: "identify",
    value: function identify() {
      var diff = utils.objectsDiff(this.opts, this.settings.now.modes[this.id]);
      if (!(0, import_lodash.isEmpty)(diff)) {
        return [this.id, diff];
      }
      return this.id;
    }
  }, {
    key: "buildGeometry",
    value: function buildGeometry(complex, colorer, mask, material2) {
      var polyComplexity = this.opts.polyComplexity ? this.opts.polyComplexity[this.settings.now.resolution] : 0;
      var groupList = this.depGroups;
      var groupCount = groupList.length;
      var group = new gfxutils.RCGroup();
      var self2 = this;
      for (var i2 = 0; i2 < groupCount; ++i2) {
        var currGroup = groupList[i2];
        var renderParams = {};
        if ((0, import_lodash.isArray)(currGroup)) {
          renderParams = currGroup[1].call(this);
          var _currGroup = currGroup;
          var _currGroup2 = _slicedToArray(_currGroup, 1);
          currGroup = _currGroup2[0];
        }
        var Group2 = GroupsFactory[currGroup](null, this.settings, renderParams);
        var newGroup = new Group2(complex, colorer, self2, polyComplexity, mask, material2);
        if (newGroup.children.length > 0) {
          group.add(newGroup);
        }
      }
      return group;
    }
  }]);
  return Mode2;
}();
makeContextDependent(Mode.prototype);
Mode.prototype.id = "__";
Mode.prototype.depGroups = [];
function _createSuper$$(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$$();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$$() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function getRenderParams$1() {
  return {
    lineWidth: this.opts.lineWidth
  };
}
var LinesMode = function(_Mode) {
  _inherits(LinesMode2, _Mode);
  var _super = _createSuper$$(LinesMode2);
  function LinesMode2(opts) {
    var _this;
    _classCallCheck(this, LinesMode2);
    _this = _super.call(this, opts);
    _this.depGroups = _this.depGroups.slice(0);
    var groups2 = _this.depGroups;
    for (var i2 = 0, n2 = groups2.length; i2 < n2; ++i2) {
      groups2[i2] = [groups2[i2], getRenderParams$1];
    }
    return _this;
  }
  _createClass(LinesMode2, [{
    key: "drawMultiorderBonds",
    value: function drawMultiorderBonds() {
      return this.opts.multibond;
    }
  }, {
    key: "calcAtomRadius",
    value: function calcAtomRadius() {
      return this.opts.atom;
    }
  }, {
    key: "getAromaticOffset",
    value: function getAromaticOffset() {
      return this.opts.offsarom;
    }
  }, {
    key: "getAromaticArcChunks",
    value: function getAromaticArcChunks() {
      return this.opts.chunkarom;
    }
  }, {
    key: "showAromaticLoops",
    value: function showAromaticLoops() {
      return this.opts.showarom;
    }
  }]);
  return LinesMode2;
}(Mode);
_defineProperty2(LinesMode, "id", "LN");
LinesMode.prototype.id = "LN";
LinesMode.prototype.name = "Lines";
LinesMode.prototype.shortName = "Lines";
LinesMode.prototype.depGroups = ["ALoopsLines", "BondsLines", "OrphanedAtomsCrosses"];
function _createSuper$_(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$_();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$_() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var LicoriceMode = function(_Mode) {
  _inherits(LicoriceMode2, _Mode);
  var _super = _createSuper$_(LicoriceMode2);
  function LicoriceMode2() {
    _classCallCheck(this, LicoriceMode2);
    return _super.apply(this, arguments);
  }
  _createClass(LicoriceMode2, [{
    key: "calcAtomRadius",
    value: function calcAtomRadius(_atom) {
      return this.opts.bond;
    }
  }, {
    key: "calcStickRadius",
    value: function calcStickRadius() {
      return this.opts.bond;
    }
  }, {
    key: "calcSpaceFraction",
    value: function calcSpaceFraction() {
      return this.opts.space;
    }
  }, {
    key: "getAromRadius",
    value: function getAromRadius() {
      return this.opts.aromrad;
    }
  }, {
    key: "showAromaticLoops",
    value: function showAromaticLoops() {
      return this.opts.showarom;
    }
  }, {
    key: "drawMultiorderBonds",
    value: function drawMultiorderBonds() {
      return this.opts.multibond;
    }
  }]);
  return LicoriceMode2;
}(Mode);
_defineProperty2(LicoriceMode, "id", "LC");
LicoriceMode.prototype.id = "LC";
LicoriceMode.prototype.name = "Licorice";
LicoriceMode.prototype.shortName = "Licorice";
LicoriceMode.prototype.depGroups = ["AtomsSpheres", "BondsCylinders", "ALoopsTorus"];
function _createSuper$Z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$Z() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var BallsAndSticksMode = function(_Mode) {
  _inherits(BallsAndSticksMode2, _Mode);
  var _super = _createSuper$Z(BallsAndSticksMode2);
  function BallsAndSticksMode2() {
    _classCallCheck(this, BallsAndSticksMode2);
    return _super.apply(this, arguments);
  }
  _createClass(BallsAndSticksMode2, [{
    key: "calcAtomRadius",
    value: function calcAtomRadius(atom) {
      return atom.element.radius * this.opts.atom;
    }
  }, {
    key: "calcStickRadius",
    value: function calcStickRadius() {
      return this.opts.bond;
    }
  }, {
    key: "getAromRadius",
    value: function getAromRadius() {
      return this.opts.aromrad;
    }
  }, {
    key: "showAromaticLoops",
    value: function showAromaticLoops() {
      return this.opts.showarom;
    }
  }, {
    key: "calcSpaceFraction",
    value: function calcSpaceFraction() {
      return this.opts.space;
    }
  }, {
    key: "drawMultiorderBonds",
    value: function drawMultiorderBonds() {
      return this.opts.multibond;
    }
  }]);
  return BallsAndSticksMode2;
}(Mode);
_defineProperty2(BallsAndSticksMode, "id", "BS");
BallsAndSticksMode.prototype.id = "BS";
BallsAndSticksMode.prototype.name = "Balls and Sticks";
BallsAndSticksMode.prototype.shortName = "Balls";
BallsAndSticksMode.prototype.depGroups = ["AtomsSpheres", "BondsCylinders", "ALoopsTorus"];
function _createSuper$Y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$Y() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VanDerWaalsMode = function(_Mode) {
  _inherits(VanDerWaalsMode2, _Mode);
  var _super = _createSuper$Y(VanDerWaalsMode2);
  function VanDerWaalsMode2() {
    _classCallCheck(this, VanDerWaalsMode2);
    return _super.apply(this, arguments);
  }
  _createClass(VanDerWaalsMode2, [{
    key: "calcAtomRadius",
    value: function calcAtomRadius(atom) {
      return atom.element.radius;
    }
  }]);
  return VanDerWaalsMode2;
}(Mode);
_defineProperty2(VanDerWaalsMode, "id", "VW");
VanDerWaalsMode.prototype.id = "VW";
VanDerWaalsMode.prototype.name = "Van der Waals";
VanDerWaalsMode.prototype.shortName = "VDW";
VanDerWaalsMode.prototype.depGroups = ["AtomsSpheres"];
function _createSuper$X(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$X();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$X() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var TraceMode = function(_Mode) {
  _inherits(TraceMode2, _Mode);
  var _super = _createSuper$X(TraceMode2);
  function TraceMode2() {
    _classCallCheck(this, TraceMode2);
    return _super.apply(this, arguments);
  }
  _createClass(TraceMode2, [{
    key: "calcStickRadius",
    value: function calcStickRadius() {
      return this.opts.radius;
    }
  }]);
  return TraceMode2;
}(Mode);
_defineProperty2(TraceMode, "id", "TR");
TraceMode.prototype.id = "TR";
TraceMode.prototype.name = "Trace";
TraceMode.prototype.shortName = "Trace";
TraceMode.prototype.depGroups = ["TraceChains"];
function _createSuper$W(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$W();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$W() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var TubeMode = function(_Mode) {
  _inherits(TubeMode2, _Mode);
  var _super = _createSuper$W(TubeMode2);
  function TubeMode2() {
    _classCallCheck(this, TubeMode2);
    return _super.apply(this, arguments);
  }
  _createClass(TubeMode2, [{
    key: "getResidueRadius",
    value: function getResidueRadius(_residue) {
      return this.TUBE_RADIUS;
    }
  }, {
    key: "getHeightSegmentsRatio",
    value: function getHeightSegmentsRatio() {
      return this.opts.heightSegmentsRatio;
    }
  }, {
    key: "getTension",
    value: function getTension() {
      return this.opts.tension;
    }
  }, {
    key: "buildGeometry",
    value: function buildGeometry(complex, colorer, mask, material2) {
      var rad = this.opts.radius;
      this.TUBE_RADIUS = new Vector2(rad, rad);
      return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material2);
    }
  }]);
  return TubeMode2;
}(Mode);
_defineProperty2(TubeMode, "id", "TU");
TubeMode.prototype.id = "TU";
TubeMode.prototype.name = "Tube";
TubeMode.prototype.shortName = "Tube";
TubeMode.prototype.depGroups = ["CartoonChains"];
function _createSuper$V(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$V();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$V() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var CartoonMode = function(_Mode) {
  _inherits(CartoonMode2, _Mode);
  var _super = _createSuper$V(CartoonMode2);
  function CartoonMode2(opts) {
    var _this;
    _classCallCheck(this, CartoonMode2);
    _this = _super.call(this, opts);
    _this.secCache = {};
    return _this;
  }
  _createClass(CartoonMode2, [{
    key: "getResidueStartRadius",
    value: function getResidueStartRadius(residue2) {
      var second = residue2.getSecondary();
      if (!second || !second.generic) {
        return this.TUBE_RADIUS;
      }
      var secOpts = this.secCache[second.generic];
      if (!secOpts) {
        return this.TUBE_RADIUS;
      }
      if (second.term === residue2) {
        return secOpts.start;
      }
      return secOpts.center;
    }
  }, {
    key: "getResidueEndRadius",
    value: function getResidueEndRadius(residue2) {
      var second = residue2.getSecondary();
      if (second === null || !second.generic) {
        return this.TUBE_RADIUS;
      }
      var secOpts = this.secCache[second.generic];
      if (!secOpts) {
        return this.TUBE_RADIUS;
      }
      if (second.term === residue2) {
        return this.ARROW_END;
      }
      return secOpts.center;
    }
  }, {
    key: "getResidueRadius",
    value: function getResidueRadius(residue2, val) {
      var startRad = this.getResidueStartRadius(residue2);
      if (val === 0) {
        return startRad;
      }
      var endRad = this.getResidueEndRadius(residue2);
      if (val === 2) {
        return endRad;
      }
      return startRad.clone().lerp(endRad, val / 2);
    }
  }, {
    key: "calcStickRadius",
    value: function calcStickRadius(_res) {
      return this.opts.radius;
    }
  }, {
    key: "getHeightSegmentsRatio",
    value: function getHeightSegmentsRatio() {
      return this.opts.heightSegmentsRatio;
    }
  }, {
    key: "getTension",
    value: function getTension() {
      return this.opts.tension;
    }
  }, {
    key: "buildGeometry",
    value: function buildGeometry(complex, colorer, mask, material2) {
      var tubeRad = this.opts.radius;
      var secHeight = this.opts.depth;
      this.TUBE_RADIUS = new Vector2(tubeRad, tubeRad);
      this.ARROW_END = new Vector2(secHeight, tubeRad);
      var secCache = {};
      var secData = this.opts.ss;
      for (var prop in secData) {
        secCache[prop] = {
          center: new Vector2(secHeight, secData[prop].width),
          start: new Vector2(secHeight, secData[prop].arrow)
        };
      }
      this.secCache = secCache;
      return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material2);
    }
  }]);
  return CartoonMode2;
}(Mode);
_defineProperty2(CartoonMode, "id", "CA");
CartoonMode.prototype.id = "CA";
CartoonMode.prototype.name = "Cartoon";
CartoonMode.prototype.shortName = "Cartoon";
CartoonMode.prototype.depGroups = ["CartoonChains", "NucleicSpheres", "NucleicCylinders"];
function _createSuper$U(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$U();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$U() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var selectors$4 = chem.selectors;
function getRenderParams() {
  return {
    wireframe: this.opts.wireframe,
    zClip: this.opts.zClip
  };
}
var SurfaceMode = function(_Mode) {
  _inherits(SurfaceMode2, _Mode);
  var _super = _createSuper$U(SurfaceMode2);
  function SurfaceMode2(opts) {
    var _this;
    _classCallCheck(this, SurfaceMode2);
    _this = _super.call(this, opts);
    _this.depGroups = _this.depGroups.slice(0);
    var surfaces = _this.surfaceNames;
    var groups2 = _this.depGroups;
    for (var i2 = 0, n2 = surfaces.length; i2 < n2; ++i2) {
      groups2[groups2.length] = [surfaces[i2], getRenderParams];
    }
    return _this;
  }
  _createClass(SurfaceMode2, [{
    key: "calcAtomRadius",
    value: function calcAtomRadius(atom) {
      return atom.element.radius;
    }
  }, {
    key: "getVisibilitySelector",
    value: function getVisibilitySelector() {
      var visibilitySelector = null;
      if (this.opts.subset !== "") {
        var res = selectors$4.parse(this.opts.subset);
        if (!res.error) {
          visibilitySelector = res.selector;
        }
      }
      return visibilitySelector;
    }
  }]);
  return SurfaceMode2;
}(Mode);
SurfaceMode.prototype.isSurface = true;
SurfaceMode.prototype.surfaceNames = [];
function _createSuper$T(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$T();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$T() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var QuickSurfaceMode = function(_SurfaceMode) {
  _inherits(QuickSurfaceMode2, _SurfaceMode);
  var _super = _createSuper$T(QuickSurfaceMode2);
  function QuickSurfaceMode2() {
    _classCallCheck(this, QuickSurfaceMode2);
    return _super.apply(this, arguments);
  }
  _createClass(QuickSurfaceMode2, [{
    key: "getSurfaceOpts",
    value: function getSurfaceOpts() {
      return {
        useBeads: false,
        isoValue: this.opts.isoValue,
        gaussLim: this.opts.gaussLim[this.settings.now.resolution],
        radScale: this.opts.scale,
        gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
        zClip: this.opts.zClip,
        visibilitySelector: this.getVisibilitySelector()
      };
    }
  }]);
  return QuickSurfaceMode2;
}(SurfaceMode);
_defineProperty2(QuickSurfaceMode, "id", "QS");
QuickSurfaceMode.prototype.id = "QS";
QuickSurfaceMode.prototype.name = "Quick Surface";
QuickSurfaceMode.prototype.shortName = "Quick Surf";
QuickSurfaceMode.prototype.surfaceNames = ["QuickSurfGeo"];
function _createSuper$S(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$S();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$S() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var IsoSurfaceMode = function(_SurfaceMode) {
  _inherits(IsoSurfaceMode2, _SurfaceMode);
  var _super = _createSuper$S(IsoSurfaceMode2);
  function IsoSurfaceMode2(excludeProbe, opts) {
    var _this;
    _classCallCheck(this, IsoSurfaceMode2);
    _this = _super.call(this, opts);
    _this._excludeProbe = excludeProbe;
    return _this;
  }
  _createClass(IsoSurfaceMode2, [{
    key: "calcAtomRadius",
    value: function calcAtomRadius(atom) {
      return atom.element.radius;
    }
  }, {
    key: "getSurfaceOpts",
    value: function getSurfaceOpts() {
      return {
        gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
        radScale: this._radScale,
        zClip: this.opts.zClip,
        visibilitySelector: this.getVisibilitySelector(),
        probeRadius: this.opts.probeRadius,
        excludeProbe: this._excludeProbe
      };
    }
  }]);
  return IsoSurfaceMode2;
}(SurfaceMode);
IsoSurfaceMode.prototype.id = "SU";
IsoSurfaceMode.prototype.name = "Surface";
IsoSurfaceMode.prototype.shortName = "Surface";
IsoSurfaceMode.prototype.surfaceNames = ["SASSESSurfaceGeo"];
IsoSurfaceMode.prototype._radScale = 1;
IsoSurfaceMode.prototype._excludeProbe = false;
function _createSuper$R(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$R();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$R() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var IsoSurfaceSASMode = function(_IsoSurfaceMode) {
  _inherits(IsoSurfaceSASMode2, _IsoSurfaceMode);
  var _super = _createSuper$R(IsoSurfaceSASMode2);
  function IsoSurfaceSASMode2(opts) {
    _classCallCheck(this, IsoSurfaceSASMode2);
    return _super.call(this, false, opts);
  }
  return _createClass(IsoSurfaceSASMode2);
}(IsoSurfaceMode);
_defineProperty2(IsoSurfaceSASMode, "id", "SA");
IsoSurfaceSASMode.prototype.id = "SA";
IsoSurfaceSASMode.prototype.name = "Solvent Accessible Surface";
IsoSurfaceSASMode.prototype.shortName = "SAS";
function _createSuper$Q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$Q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$Q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var IsoSurfaceSESMode = function(_IsoSurfaceMode) {
  _inherits(IsoSurfaceSESMode2, _IsoSurfaceMode);
  var _super = _createSuper$Q(IsoSurfaceSESMode2);
  function IsoSurfaceSESMode2(opts) {
    _classCallCheck(this, IsoSurfaceSESMode2);
    return _super.call(this, true, opts);
  }
  return _createClass(IsoSurfaceSESMode2);
}(IsoSurfaceMode);
_defineProperty2(IsoSurfaceSESMode, "id", "SE");
IsoSurfaceSESMode.prototype.id = "SE";
IsoSurfaceSESMode.prototype.name = "Solvent Excluded Surface";
IsoSurfaceSESMode.prototype.shortName = "SES";
function _createSuper$P(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$P();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$P() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ContactSurfaceMode = function(_SurfaceMode) {
  _inherits(ContactSurfaceMode2, _SurfaceMode);
  var _super = _createSuper$P(ContactSurfaceMode2);
  function ContactSurfaceMode2() {
    _classCallCheck(this, ContactSurfaceMode2);
    return _super.apply(this, arguments);
  }
  _createClass(ContactSurfaceMode2, [{
    key: "getSurfaceOpts",
    value: function getSurfaceOpts() {
      return {
        probeRadius: this.opts.probeRadius,
        radScale: this.opts.polyComplexity[this.settings.now.resolution],
        scaleFactor: this.opts.polyComplexity[this.settings.now.resolution],
        gridSpacing: 1 / this.opts.polyComplexity[this.settings.now.resolution],
        isoValue: this.opts.isoValue,
        probePositions: this.opts.probePositions,
        zClip: this.opts.zClip,
        visibilitySelector: this.getVisibilitySelector()
      };
    }
  }]);
  return ContactSurfaceMode2;
}(SurfaceMode);
_defineProperty2(ContactSurfaceMode, "id", "CS");
ContactSurfaceMode.prototype.id = "CS";
ContactSurfaceMode.prototype.name = "Contact Surface";
ContactSurfaceMode.prototype.shortName = "Contact Surf";
ContactSurfaceMode.prototype.isSurface = true;
ContactSurfaceMode.prototype.surfaceNames = ["ContactSurfaceGeo"];
function _createSuper$O(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$O();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$O() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var TextMode = function(_Mode) {
  _inherits(TextMode2, _Mode);
  var _super = _createSuper$O(TextMode2);
  function TextMode2() {
    _classCallCheck(this, TextMode2);
    return _super.apply(this, arguments);
  }
  _createClass(TextMode2, [{
    key: "getTemplateOptions",
    value: function getTemplateOptions() {
      return this.opts.template;
    }
  }, {
    key: "getLabelOpts",
    value: function getLabelOpts() {
      return (0, import_lodash.merge)(this.opts, {
        colors: true,
        adjustColor: true,
        transparent: true
      });
    }
  }]);
  return TextMode2;
}(Mode);
_defineProperty2(TextMode, "id", "TX");
TextMode.prototype.id = "TX";
TextMode.prototype.name = "Text mode";
TextMode.prototype.shortName = "Text";
TextMode.prototype.depGroups = ["TextLabelsGeo"];
var modes$1 = new EntityList([LinesMode, LicoriceMode, BallsAndSticksMode, VanDerWaalsMode, TraceMode, TubeMode, CartoonMode, QuickSurfaceMode, IsoSurfaceSASMode, IsoSurfaceSESMode, ContactSurfaceMode, TextMode]);
function clamp2(x2, a2, b2) {
  return x2 <= b2 ? x2 < 0 ? 0 : x2 : b2;
}
function lerpColor(c1, c2, alpha) {
  var beta = 1 - alpha;
  var r1 = c1 >> 16 & 255;
  var g1 = c1 >> 8 & 255;
  var b1 = c1 & 255;
  var r2 = c2 >> 16 & 255;
  var g2 = c2 >> 8 & 255;
  var b2 = c2 & 255;
  var r3 = beta * r1 + alpha * r2;
  var g3 = beta * g1 + alpha * g2;
  var b3 = beta * b1 + alpha * b2;
  return r3 << 16 | g3 << 8 | b3;
}
var Palette = function() {
  function Palette2(name2, id) {
    _classCallCheck(this, Palette2);
    this.name = name2 || "Custom";
    this.id = id || "CP";
  }
  _createClass(Palette2, [{
    key: "getElementColor",
    value: function getElementColor(name2) {
      var asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var color2 = this.elementColors[name2];
      return color2 === void 0 && !asIs ? this.defaultElementColor : color2;
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(name2) {
      var asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var color2 = this.residueColors[name2];
      return color2 === void 0 && !asIs ? this.defaultResidueColor : color2;
    }
  }, {
    key: "getChainColor",
    value: function getChainColor(name2) {
      var chain2 = name2.charCodeAt(0);
      chain2 = ((chain2 < 0 ? 0 : chain2 >= 256 ? chain2 - 256 : chain2) & 31) % this.chainColors.length;
      return this.chainColors[chain2];
    }
  }, {
    key: "getSecondaryColor",
    value: function getSecondaryColor(type) {
      var asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var color2 = this.secondaryColors[type];
      return color2 === void 0 && !asIs ? this.defaultSecondaryColor : color2;
    }
  }, {
    key: "getSequentialColor",
    value: function getSequentialColor(index) {
      var colors = this.colors;
      var len = colors.length;
      return index < 0 ? colors[index % len + len] : colors[index % len];
    }
  }, {
    key: "getGradientColor",
    value: function getGradientColor(value, gradientName) {
      var gradient = this.gradients[gradientName];
      if (!gradient) {
        return this.defaultNamedColor;
      }
      var count = gradient.length;
      var index = value * (count - 1);
      var left = Math.floor(index);
      var right = clamp2(left + 1, 0, count - 1);
      left = clamp2(left, 0, count - 1);
      return lerpColor(gradient[left], gradient[right], index - left);
    }
  }, {
    key: "getNamedColor",
    value: function getNamedColor(name2) {
      var asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var color2 = this.namedColors[name2];
      return color2 === void 0 && !asIs ? this.defaultNamedColor : color2;
    }
  }]);
  return Palette2;
}();
(0, import_lodash.assign)(Palette.prototype, {
  colors: [16777215, 16711680, 65280, 255, 8421504],
  minRangeColor: 0,
  midRangeColor: 8355711,
  maxRangeColor: 16777215,
  defaultElementColor: 16777215,
  elementColors: {},
  defaultResidueColor: 16777215,
  residueColors: {},
  chainColors: [16777215],
  defaultSecondaryColor: 16777215,
  secondaryColors: {},
  defaultGradientColor: 0,
  defaultNamedColor: 16777215,
  namedColorsArray: [
    ["indianred", 13458524],
    ["lightcoral", 15761536],
    ["salmon", 16416882],
    ["darksalmon", 15308410],
    ["lightsalmon", 16752762],
    ["crimson", 14423100],
    ["red", 16711680],
    ["firebrick", 11674146],
    ["darkred", 9109504],
    ["pink", 16761035],
    ["lightpink", 16758465],
    ["hotpink", 16738740],
    ["deeppink", 16716947],
    ["mediumvioletred", 13047173],
    ["palevioletred", 14381203],
    ["coral", 16744272],
    ["tomato", 16737095],
    ["orangered", 16729344],
    ["darkorange", 16747520],
    ["orange", 16753920],
    ["gold", 16766720],
    ["yellow", 16776960],
    ["lightyellow", 16777184],
    ["lemonchiffon", 16775885],
    ["lightgoldenrodyellow", 16448210],
    ["papayawhip", 16773077],
    ["moccasin", 16770229],
    ["peachpuff", 16767673],
    ["palegoldenrod", 15657130],
    ["khaki", 15787660],
    ["darkkhaki", 12433259],
    ["lavender", 15132410],
    ["thistle", 14204888],
    ["plum", 14524637],
    ["violet", 15631086],
    ["orchid", 14315734],
    ["fuchsia", 16711935],
    ["magenta", 16711935],
    ["mediumorchid", 12211667],
    ["mediumpurple", 9662683],
    ["rebeccapurple", 6697881],
    ["blueviolet", 9055202],
    ["darkviolet", 9699539],
    ["darkorchid", 10040012],
    ["darkmagenta", 9109643],
    ["purple", 8388736],
    ["indigo", 4915330],
    ["slateblue", 6970061],
    ["mediumslateblue", 8087790],
    ["darkslateblue", 4734347],
    ["greenyellow", 11403055],
    ["chartreuse", 8388352],
    ["lawngreen", 8190976],
    ["lime", 65280],
    ["limegreen", 3329330],
    ["palegreen", 10025880],
    ["lightgreen", 9498256],
    ["mediumspringgreen", 64154],
    ["springgreen", 65407],
    ["mediumseagreen", 3978097],
    ["seagreen", 3050327],
    ["forestgreen", 2263842],
    ["green", 32768],
    ["darkgreen", 25600],
    ["yellowgreen", 10145074],
    ["olivedrab", 7048739],
    ["olive", 8421376],
    ["darkolivegreen", 5597999],
    ["mediumaquamarine", 6737322],
    ["darkseagreen", 9419919],
    ["lightseagreen", 2142890],
    ["darkcyan", 35723],
    ["teal", 32896],
    ["aqua", 65535],
    ["cyan", 65535],
    ["lightcyan", 14745599],
    ["paleturquoise", 11529966],
    ["aquamarine", 8388564],
    ["turquoise", 4251856],
    ["mediumturquoise", 4772300],
    ["darkturquoise", 52945],
    ["cadetblue", 6266528],
    ["steelblue", 4620980],
    ["lightsteelblue", 11584734],
    ["powderblue", 11591910],
    ["lightblue", 11393254],
    ["skyblue", 8900331],
    ["lightskyblue", 8900346],
    ["deepskyblue", 49151],
    ["dodgerblue", 2003199],
    ["cornflowerblue", 6591981],
    ["royalblue", 4286945],
    ["blue", 255],
    ["mediumblue", 205],
    ["darkblue", 139],
    ["navy", 128],
    ["midnightblue", 1644912],
    ["cornsilk", 16775388],
    ["blanchedalmond", 16772045],
    ["bisque", 16770244],
    ["navajowhite", 16768685],
    ["wheat", 16113331],
    ["burlywood", 14596231],
    ["tan", 13808780],
    ["rosybrown", 12357519],
    ["sandybrown", 16032864],
    ["goldenrod", 14329120],
    ["darkgoldenrod", 12092939],
    ["peru", 13468991],
    ["chocolate", 13789470],
    ["saddlebrown", 9127187],
    ["sienna", 10506797],
    ["brown", 10824234],
    ["maroon", 8388608],
    ["white", 16777215],
    ["snow", 16775930],
    ["honeydew", 15794160],
    ["mintcream", 16121850],
    ["azure", 15794175],
    ["aliceblue", 15792383],
    ["ghostwhite", 16316671],
    ["whitesmoke", 16119285],
    ["seashell", 16774638],
    ["beige", 16119260],
    ["oldlace", 16643558],
    ["floralwhite", 16775920],
    ["ivory", 16777200],
    ["antiquewhite", 16444375],
    ["linen", 16445670],
    ["lavenderblush", 16773365],
    ["mistyrose", 16770273],
    ["gainsboro", 14474460],
    ["lightgray", 13882323],
    ["silver", 12632256],
    ["darkgray", 11119017],
    ["gray", 8421504],
    ["dimgray", 6908265],
    ["lightslategray", 7833753],
    ["slategray", 7372944],
    ["darkslategray", 3100495],
    ["black", 0]
  ],
  namedColors: {},
  gradients: {
    rainbow: [
      255,
      65535,
      65280,
      16776960,
      16711680
    ],
    temp: [
      255,
      32767,
      16777215,
      16744192,
      16711680
    ],
    hot: [
      16777215,
      16744192,
      16711680
    ],
    cold: [
      16777215,
      32767,
      255
    ],
    "blue-red": [
      255,
      16777215,
      16711680
    ],
    reds: [
      16777215,
      16711680
    ],
    blues: [
      16777215,
      255
    ]
  }
});
var _Palette$prototype = Palette.prototype;
var namedColorsArray = _Palette$prototype.namedColorsArray;
var namedColors = _Palette$prototype.namedColors;
for (i2 = 0, length = namedColorsArray.length; i2 < length; ++i2) {
  _namedColorsArray$i = _slicedToArray(namedColorsArray[i2], 2), name2 = _namedColorsArray$i[0], value = _namedColorsArray$i[1];
  namedColors[name2] = value;
}
var _namedColorsArray$i;
var name2;
var value;
var i2;
var length;
var palette$2 = new Palette("CPK", "CP");
palette$2.elementColors = {
  H: 16777215,
  C: 2105376,
  N: 2121983,
  O: 15605776,
  F: 65280,
  P: 8397055,
  S: 16776960,
  CL: 47872,
  FE: 13684944,
  CO: 13684944,
  NI: 13684944,
  CU: 13684944,
  BR: 34816,
  I: 21760
};
var _palette$secondaryCol$1;
var palette$1 = new Palette("Jmol", "JM");
palette$1.colors = [
  255,
  22015,
  44031,
  65535,
  65451,
  65365,
  65280,
  5635840,
  11271936,
  16776960,
  16755456,
  16733440,
  16711680,
  16711765,
  16711851,
  16711935,
  11206911,
  5570815
];
palette$1.elementColors = {
  H: 16777215,
  D: 16777152,
  T: 16777120,
  HE: 14286847,
  LI: 13402367,
  BE: 12779264,
  B: 16758197,
  C: 9474192,
  N: 3166456,
  O: 16715021,
  F: 9494608,
  NE: 11789301,
  NA: 11230450,
  MG: 9109248,
  AL: 12560038,
  SI: 1578e4,
  P: 16744448,
  S: 16777008,
  CL: 2093087,
  AR: 8442339,
  K: 9388244,
  CA: 4062976,
  SC: 15132390,
  TI: 12567239,
  V: 10921643,
  CR: 9083335,
  MN: 10255047,
  FE: 14706227,
  CO: 15765664,
  NI: 5296208,
  CU: 13140019,
  ZN: 8224944,
  GA: 12750735,
  GE: 6721423,
  AS: 12419299,
  SE: 16752896,
  BR: 10889513,
  KR: 6076625,
  RB: 7351984,
  SR: 65280,
  Y: 9764863,
  ZR: 9756896,
  NB: 7586505,
  MO: 5551541,
  TC: 3907230,
  RU: 2396047,
  RH: 687500,
  PD: 27013,
  AG: 12632256,
  CD: 16767375,
  IN: 10909043,
  SN: 6717568,
  SB: 10380213,
  TE: 13924864,
  I: 9699476,
  XE: 4366e3,
  CS: 5707663,
  BA: 51456,
  LA: 7394559,
  CE: 16777159,
  PR: 14286791,
  ND: 13107143,
  PM: 10747847,
  SM: 9437127,
  EU: 6422471,
  GD: 4587463,
  TB: 3211207,
  DY: 2097095,
  HO: 65436,
  ER: 58997,
  TM: 54354,
  YB: 48952,
  LU: 43812,
  HF: 5096191,
  TA: 5089023,
  W: 2200790,
  RE: 2522539,
  OS: 2516630,
  IR: 1528967,
  PT: 13684960,
  AU: 16765219,
  HG: 12105936,
  TL: 10900557,
  PB: 5724513,
  BI: 10375093,
  PO: 11230208,
  AT: 7688005,
  RN: 4358806,
  FR: 4325478,
  RA: 32e3,
  AC: 7384058,
  TH: 47871,
  PA: 41471,
  U: 36863,
  NP: 33023,
  PU: 27647,
  AM: 5528818,
  CM: 7888099,
  BK: 9064419,
  CF: 10565332,
  ES: 11739092,
  FM: 11739066,
  MD: 11734438,
  NO: 12389767,
  LR: 13041766,
  RF: 13369433,
  DB: 13697103,
  SG: 14221381,
  BH: 14680120,
  HS: 15073326,
  MT: 15400998
};
palette$1.defaultResidueColor = 12492910;
palette$1.residueColors = {
  ALA: 13158600,
  ARG: 1334015,
  ASN: 56540,
  ASP: 15075850,
  CYS: 15132160,
  GLN: 56540,
  GLU: 15075850,
  GLY: 15461355,
  HIS: 8553170,
  ILE: 1016335,
  LEU: 1016335,
  LYS: 1334015,
  MET: 15132160,
  PHE: 3289770,
  PRO: 14456450,
  SER: 16422400,
  THR: 16422400,
  TRP: 11819700,
  TYR: 3289770,
  VAL: 1016335,
  A: 10526975,
  C: 16747595,
  G: 16740464,
  I: 8454143,
  T: 10551200,
  U: 16744576,
  DA: 10526975,
  DC: 16747595,
  DG: 16740464,
  DI: 8454143,
  DT: 10551200,
  DU: 16744576,
  "+A": 10526975,
  "+C": 16747595,
  "+G": 16740464,
  "+I": 8454143,
  "+T": 10551200,
  "+U": 16744576
};
palette$1.chainColors = [
  4294967295,
  4290826495,
  4289789872,
  4294951112,
  4294967168,
  4294951167,
  4289786096,
  4294955120,
  4293951616,
  4294303411,
  4278239231,
  4291648604,
  4284927402,
  4288335154,
  4293821166,
  4278243025,
  4278255487,
  4282168177,
  4278190219,
  4290623339,
  4278215680,
  4286578688,
  4286611456,
  4286578816,
  4278222976,
  4290283019,
  4289864226
];
var StructuralElementType$2 = StructuralElement.Type;
palette$1.secondaryColors = (_palette$secondaryCol$1 = {}, _defineProperty2(_palette$secondaryCol$1, StructuralElementType$2.HELIX_ALPHA, 16711808), _defineProperty2(_palette$secondaryCol$1, StructuralElementType$2.HELIX_PI, 6291584), _defineProperty2(_palette$secondaryCol$1, StructuralElementType$2.HELIX_310, 10485888), _defineProperty2(_palette$secondaryCol$1, StructuralElementType$2.STRAND, 16762880), _defineProperty2(_palette$secondaryCol$1, StructuralElementType$2.TURN, 6324479), _defineProperty2(_palette$secondaryCol$1, "dna", 11403518), _defineProperty2(_palette$secondaryCol$1, "rna", 16580962), _palette$secondaryCol$1);
var _palette$secondaryCol;
var palette = new Palette("VMD", "VM");
palette.colors = [
  255,
  16711680,
  6316128,
  16744448,
  16776960,
  8421427,
  10066329,
  65280,
  16777215,
  16751001,
  4243648,
  10879142,
  8447590,
  15099571,
  8408320,
  8421568
];
palette.defaultElementColor = 8408320;
palette.elementColors = {
  H: 16777215,
  C: 4243391,
  N: 255,
  O: 16711680,
  P: 8421427,
  S: 16776960
};
palette.defaultResidueColor = 4243648;
palette.residueColors = {
  ALA: 255,
  ARG: 16777215,
  ASN: 8421427,
  ASP: 16711680,
  CYS: 16776960,
  GLN: 16744448,
  GLU: 16751001,
  GLY: 16777215,
  HIS: 4243648,
  ILE: 65280,
  LEU: 16751001,
  LYS: 4243648,
  MET: 16776960,
  PHE: 10879142,
  PRO: 8408064,
  SER: 16776960,
  THR: 15099571,
  TRP: 10066329,
  TYR: 65280,
  VAL: 8421427,
  A: 255,
  C: 16744448,
  G: 16776960,
  T: 10879142,
  U: 65280,
  DA: 255,
  DC: 16744448,
  DG: 16776960,
  DT: 10879142,
  DU: 65280,
  "+A": 255,
  "+C": 16744448,
  "+G": 16776960,
  "+T": 10879142,
  "+U": 65280,
  WAT: 4243648,
  H2O: 4243648,
  HOH: 4243648
};
palette.chainColors = [16777215].concat(palette.colors);
var StructuralElementType$1 = StructuralElement.Type;
palette.secondaryColors = (_palette$secondaryCol = {}, _defineProperty2(_palette$secondaryCol, StructuralElementType$1.HELIX_ALPHA, 10879142), _defineProperty2(_palette$secondaryCol, StructuralElementType$1.HELIX_310, 255), _defineProperty2(_palette$secondaryCol, StructuralElementType$1.HELIX_PI, 16711680), _defineProperty2(_palette$secondaryCol, StructuralElementType$1.STRAND, 16776960), _defineProperty2(_palette$secondaryCol, StructuralElementType$1.BRIDGE, 8421427), _defineProperty2(_palette$secondaryCol, StructuralElementType$1.TURN, 4243648), _palette$secondaryCol);
var palettes$1 = new EntityList([palette$2, palette$1, palette]);
var Colorer = function() {
  function Colorer2(opts) {
    _classCallCheck(this, Colorer2);
    if (this.constructor === Colorer2) {
      throw new Error("Can not instantiate abstract class!");
    }
    this.opts = (0, import_lodash.merge)(utils.deriveDeep(settings$1.now.colorers[this.id], true), opts);
    this.palette = palettes$1.first;
  }
  _createClass(Colorer2, [{
    key: "identify",
    value: function identify() {
      var diff = utils.objectsDiff(this.opts, settings$1.now.colorers[this.id]);
      if (!(0, import_lodash.isEmpty)(diff)) {
        return [this.id, diff];
      }
      return this.id;
    }
  }]);
  return Colorer2;
}();
Colorer.prototype.id = "__";
function _createSuper$N(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$N();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$N() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ElementColorer = function(_Colorer) {
  _inherits(ElementColorer2, _Colorer);
  var _super = _createSuper$N(ElementColorer2);
  function ElementColorer2() {
    _classCallCheck(this, ElementColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(ElementColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, _complex) {
      var type = atom.element.name;
      if (type === "C" && this.opts.carbon >= 0) {
        return this.opts.carbon;
      }
      return this.palette.getElementColor(type);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(_residue, _complex) {
      return this.palette.defaultResidueColor;
    }
  }]);
  return ElementColorer2;
}(Colorer);
_defineProperty2(ElementColorer, "id", "EL");
ElementColorer.prototype.id = "EL";
ElementColorer.prototype.name = "Element";
ElementColorer.prototype.shortName = "Element";
function _createSuper$M(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$M();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$M() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ResidueTypeColorer = function(_Colorer) {
  _inherits(ResidueTypeColorer2, _Colorer);
  var _super = _createSuper$M(ResidueTypeColorer2);
  function ResidueTypeColorer2() {
    _classCallCheck(this, ResidueTypeColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(ResidueTypeColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, complex) {
      return this.getResidueColor(atom.residue, complex);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      return this.palette.getResidueColor(residue2._type._name);
    }
  }]);
  return ResidueTypeColorer2;
}(Colorer);
_defineProperty2(ResidueTypeColorer, "id", "RT");
ResidueTypeColorer.prototype.id = "RT";
ResidueTypeColorer.prototype.name = "Residue Type";
ResidueTypeColorer.prototype.shortName = "Residue";
function _createSuper$L(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$L();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$L() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var SequenceColorer = function(_Colorer) {
  _inherits(SequenceColorer2, _Colorer);
  var _super = _createSuper$L(SequenceColorer2);
  function SequenceColorer2() {
    _classCallCheck(this, SequenceColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(SequenceColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, complex) {
      return this.getResidueColor(atom.residue, complex);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      var chain2 = residue2._chain;
      if (chain2.minSequence === Number.POSITIVE_INFINITY && chain2.maxSequence === Number.NEGATIVE_INFINITY) {
        return this.palette.defaultNamedColor;
      }
      var min = chain2.minSequence;
      var max = chain2.maxSequence > min ? chain2.maxSequence : min + 1;
      return this.palette.getGradientColor((residue2._sequence - min) / (max - min), this.opts.gradient);
    }
  }]);
  return SequenceColorer2;
}(Colorer);
_defineProperty2(SequenceColorer, "id", "SQ");
SequenceColorer.prototype.id = "SQ";
SequenceColorer.prototype.name = "Sequence";
SequenceColorer.prototype.shortName = "Sequence";
function _createSuper$K(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$K();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$K() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ChainColorer = function(_Colorer) {
  _inherits(ChainColorer2, _Colorer);
  var _super = _createSuper$K(ChainColorer2);
  function ChainColorer2() {
    _classCallCheck(this, ChainColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(ChainColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, complex) {
      return this.getResidueColor(atom.residue, complex);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      return this.palette.getChainColor(residue2.getChain()._name);
    }
  }]);
  return ChainColorer2;
}(Colorer);
_defineProperty2(ChainColorer, "id", "CH");
ChainColorer.prototype.id = "CH";
ChainColorer.prototype.name = "Chain";
ChainColorer.prototype.shortName = "Chain";
function _createSuper$J(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$J();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$J() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var SecondaryStructureColorer = function(_Colorer) {
  _inherits(SecondaryStructureColorer2, _Colorer);
  var _super = _createSuper$J(SecondaryStructureColorer2);
  function SecondaryStructureColorer2() {
    _classCallCheck(this, SecondaryStructureColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(SecondaryStructureColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, complex) {
      return this.getResidueColor(atom.residue, complex);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      if (residue2._type.flags & ResidueType$1.Flags.DNA) {
        return this.palette.getSecondaryColor("dna");
      }
      if (residue2._type.flags & ResidueType$1.Flags.RNA) {
        return this.palette.getSecondaryColor("rna");
      }
      var secondary = residue2.getSecondary();
      if (secondary) {
        var color2 = this.palette.getSecondaryColor(secondary.type, true);
        if (color2 === void 0) {
          color2 = this.palette.getSecondaryColor(secondary.generic);
        }
        return color2;
      }
      return this.palette.defaultSecondaryColor;
    }
  }]);
  return SecondaryStructureColorer2;
}(Colorer);
_defineProperty2(SecondaryStructureColorer, "id", "SS");
SecondaryStructureColorer.prototype.id = "SS";
SecondaryStructureColorer.prototype.name = "Secondary Structure";
SecondaryStructureColorer.prototype.shortName = "Structure";
function _createSuper$I(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$I();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$I() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var UniformColorer = function(_Colorer) {
  _inherits(UniformColorer2, _Colorer);
  var _super = _createSuper$I(UniformColorer2);
  function UniformColorer2() {
    _classCallCheck(this, UniformColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(UniformColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(_atom, _complex) {
      return this.opts.color;
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(_residue, _complex) {
      return this.opts.color;
    }
  }]);
  return UniformColorer2;
}(Colorer);
_defineProperty2(UniformColorer, "id", "UN");
UniformColorer.prototype.id = "UN";
UniformColorer.prototype.name = "Uniform";
UniformColorer.prototype.shortName = "Uniform";
function _createSuper$H(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$H();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$H() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ConditionalColorer = function(_Colorer) {
  _inherits(ConditionalColorer2, _Colorer);
  var _super = _createSuper$H(ConditionalColorer2);
  function ConditionalColorer2(opts) {
    var _this;
    _classCallCheck(this, ConditionalColorer2);
    _this = _super.call(this, opts);
    var parsed = selectors$5.parse(_this.opts.subset);
    _this._subsetCached = parsed.error ? selectors$5.none() : parsed.selector;
    return _this;
  }
  _createClass(ConditionalColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, _complex) {
      return this._subsetCached.includesAtom(atom) ? this.opts.color : this.opts.baseColor;
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      var subset = this._subsetCached;
      var atoms = residue2._atoms;
      for (var i2 = 0, n2 = atoms.length; i2 < n2; ++i2) {
        if (!subset.includesAtom(atoms[i2])) {
          return this.opts.baseColor;
        }
      }
      return this.opts.color;
    }
  }]);
  return ConditionalColorer2;
}(Colorer);
_defineProperty2(ConditionalColorer, "id", "CO");
ConditionalColorer.prototype.id = "CO";
ConditionalColorer.prototype.name = "Conditional";
ConditionalColorer.prototype.shortName = "Conditional";
function _createSuper$G(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$G();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$G() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ConformationColorer = function(_Colorer) {
  _inherits(ConformationColorer2, _Colorer);
  var _super = _createSuper$G(ConformationColorer2);
  function ConformationColorer2() {
    _classCallCheck(this, ConformationColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(ConformationColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, _complex) {
      return this.palette.getChainColor(String.fromCharCode(atom.location));
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(_residue, _complex) {
      return this.palette.defaultResidueColor;
    }
  }]);
  return ConformationColorer2;
}(Colorer);
_defineProperty2(ConformationColorer, "id", "CF");
ConformationColorer.prototype.id = "CF";
ConformationColorer.prototype.name = "Conformation";
ConformationColorer.prototype.shortName = "Conformation";
function _createSuper$F(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$F();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$F() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var TemperatureColorer = function(_Colorer) {
  _inherits(TemperatureColorer2, _Colorer);
  var _super = _createSuper$F(TemperatureColorer2);
  function TemperatureColorer2() {
    _classCallCheck(this, TemperatureColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(TemperatureColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, _complex) {
      var opts = this.opts;
      var factor = 1;
      if (atom.temperature && opts) {
        if (opts.min === opts.max) {
          factor = atom.temperature > opts.max ? 1 : 0;
        } else {
          factor = (atom.temperature - opts.min) / (opts.max - opts.min);
        }
        return this.palette.getGradientColor(factor, opts.gradient);
      }
      return this.palette.defaultGradientColor;
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      var opts = this.opts;
      if (!opts) {
        return this.palette.defaultGradientColor;
      }
      if (residue2.temperature) {
        var factor = 0;
        if (opts.min === opts.max) {
          factor = residue2.temperature > opts.max ? 1 : 0;
        } else {
          factor = (residue2.temperature - opts.min) / (opts.max - opts.min);
        }
        return this.palette.getGradientColor(factor, opts.gradient);
      }
      return this.palette.defaultGradientColor;
    }
  }]);
  return TemperatureColorer2;
}(Colorer);
_defineProperty2(TemperatureColorer, "id", "TM");
TemperatureColorer.prototype.id = "TM";
TemperatureColorer.prototype.name = "Temperature";
TemperatureColorer.prototype.shortName = "Temperature";
function _createSuper$E(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$E();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$E() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OccupancyColorer = function(_Colorer) {
  _inherits(OccupancyColorer2, _Colorer);
  var _super = _createSuper$E(OccupancyColorer2);
  function OccupancyColorer2() {
    _classCallCheck(this, OccupancyColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(OccupancyColorer2, [{
    key: "_getColorByOccupancy",
    value: function _getColorByOccupancy(occupancy, opts) {
      if (occupancy !== void 0) {
        var factor = 1 - occupancy;
        return this.palette.getGradientColor(factor, opts.gradient);
      }
      return this.palette.defaultGradientColor;
    }
  }, {
    key: "getAtomColor",
    value: function getAtomColor(atom, _complex) {
      var opts = this.opts;
      return this._getColorByOccupancy(atom.occupancy, opts);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      var opts = this.opts;
      return this._getColorByOccupancy(residue2.occupancy, opts);
    }
  }]);
  return OccupancyColorer2;
}(Colorer);
_defineProperty2(OccupancyColorer, "id", "OC");
OccupancyColorer.prototype.id = "OC";
OccupancyColorer.prototype.name = "Occupancy";
OccupancyColorer.prototype.shortName = "Occupancy";
function _createSuper$D(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$D();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$D() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var HydrophobicityColorer = function(_Colorer) {
  _inherits(HydrophobicityColorer2, _Colorer);
  var _super = _createSuper$D(HydrophobicityColorer2);
  function HydrophobicityColorer2() {
    _classCallCheck(this, HydrophobicityColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(HydrophobicityColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, complex) {
      return this.getResidueColor(atom.residue, complex);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      var color2 = this.palette.defaultResidueColor;
      if (residue2._type.hydrophobicity !== void 0) {
        var min = -4.5;
        var max = 4.5;
        color2 = this.palette.getGradientColor((residue2._type.hydrophobicity - min) / (max - min), this.opts.gradient);
      }
      return color2;
    }
  }]);
  return HydrophobicityColorer2;
}(Colorer);
_defineProperty2(HydrophobicityColorer, "id", "HY");
HydrophobicityColorer.prototype.id = "HY";
HydrophobicityColorer.prototype.name = "Hydrophobicity";
HydrophobicityColorer.prototype.shortName = "Hydrophobicity";
function _createSuper$C(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$C();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$C() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var MoleculeColorer = function(_Colorer) {
  _inherits(MoleculeColorer2, _Colorer);
  var _super = _createSuper$C(MoleculeColorer2);
  function MoleculeColorer2() {
    _classCallCheck(this, MoleculeColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(MoleculeColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, complex) {
      return this.getResidueColor(atom.residue, complex);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(residue2, _complex) {
      var molecule = residue2._molecule;
      var count = _complex.getMoleculeCount();
      if (count > 1) {
        return this.palette.getGradientColor((molecule.index - 1) / (count - 1), this.opts.gradient);
      }
      return this.palette.getGradientColor(0, this.opts.gradient);
    }
  }]);
  return MoleculeColorer2;
}(Colorer);
_defineProperty2(MoleculeColorer, "id", "MO");
MoleculeColorer.prototype.id = "MO";
MoleculeColorer.prototype.name = "Molecule";
MoleculeColorer.prototype.shortName = "Molecule";
function _createSuper$B(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$B();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$B() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function scaleColor(c2, factor) {
  var r1 = c2 >> 16 & 255;
  var g1 = c2 >> 8 & 255;
  var b1 = c2 & 255;
  var r2 = factor * r1;
  var g2 = factor * g1;
  var b2 = factor * b1;
  return r2 << 16 | g2 << 8 | b2;
}
var CarbonColorer = function(_Colorer) {
  _inherits(CarbonColorer2, _Colorer);
  var _super = _createSuper$B(CarbonColorer2);
  function CarbonColorer2() {
    _classCallCheck(this, CarbonColorer2);
    return _super.apply(this, arguments);
  }
  _createClass(CarbonColorer2, [{
    key: "getAtomColor",
    value: function getAtomColor(atom, _complex) {
      var colorCarbon = this.opts.color;
      var colorNotCarbon = scaleColor(colorCarbon, this.opts.factor);
      return atom.flags & Atom$2.Flags.CARBON ? colorCarbon : colorNotCarbon;
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(_residue, _complex) {
      return this.opts.color;
    }
  }]);
  return CarbonColorer2;
}(Colorer);
_defineProperty2(CarbonColorer, "id", "CB");
CarbonColorer.prototype.id = "CB";
CarbonColorer.prototype.name = "Carbon";
CarbonColorer.prototype.shortName = "Carbon";
var colorers$1 = new EntityList([ElementColorer, ResidueTypeColorer, SequenceColorer, ChainColorer, SecondaryStructureColorer, UniformColorer, ConditionalColorer, ConformationColorer, TemperatureColorer, OccupancyColorer, HydrophobicityColorer, MoleculeColorer, CarbonColorer]);
function neutralColor(intensity) {
  return new Color(intensity, intensity, intensity);
}
var materialList = [{
  id: "DF",
  name: "Diffuse",
  shortName: "Diffuse",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "SF",
  name: "Soft Plastic",
  shortName: "Soft",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0.1),
    shininess: 30,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "PL",
  name: "Glossy Plastic",
  shortName: "Glossy",
  uberOptions: {
    diffuse: neutralColor(0.56),
    specular: neutralColor(0.28),
    shininess: 100,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "ME",
  name: "Metal",
  shortName: "Metal",
  uberOptions: {
    diffuse: neutralColor(0.56),
    specular: neutralColor(0.55),
    shininess: 30,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "TR",
  name: "Transparent",
  shortName: "Transparent",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 0.5
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: true,
    toonShading: false
  }
}, {
  id: "GL",
  name: "Glass",
  shortName: "Glass",
  uberOptions: {
    diffuse: neutralColor(0.5),
    specular: neutralColor(0.65),
    shininess: 100,
    opacity: 0.5
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: true,
    toonShading: false
  }
}, {
  id: "BA",
  name: "Backdrop",
  shortName: "Backdrop",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 1
  },
  values: {
    lights: false,
    fog: false,
    depthWrite: false,
    transparent: false,
    toonShading: false
  }
}, {
  id: "TN",
  name: "Toon",
  shortName: "Toon",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: true
  }
}, {
  id: "FL",
  name: "Flat",
  shortName: "Flat",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 0,
    opacity: 1
  },
  values: {
    lights: false,
    fog: true,
    depthWrite: true,
    transparent: false
  }
}];
var materials$1 = new EntityList(materialList);
function _gatherObjects(root, meshTypes) {
  var meshes2 = [];
  root.traverse(function(object4) {
    for (var i2 = 0; i2 < meshTypes.length; i2++) {
      if (object4 instanceof meshTypes[i2]) {
        meshes2[meshes2.length] = object4;
        break;
      }
    }
  });
  return meshes2;
}
function createDerivativeMesh(mesh, values, layer) {
  var material2 = mesh.material.createInstance();
  material2.setValues(values);
  var newMesh = new mesh.constructor(mesh.geometry, material2);
  newMesh.material.needsUpdate = true;
  newMesh.applyMatrix4(mesh.matrix);
  newMesh.layers.set(layer);
  return newMesh;
}
function traverseMeshes(root, meshTypes, func3) {
  var meshes2 = _gatherObjects(root, meshTypes);
  for (var i2 = 0, n2 = meshes2.length; i2 < n2; ++i2) {
    var mesh = meshes2[i2];
    if (!mesh.parent) {
      continue;
    }
    func3(mesh);
  }
}
function applyTransformsToMeshes(root, mtc) {
  var mtcCount = mtc.length;
  if (mtcCount < 1) {
    return;
  }
  var meshTypes = [Mesh, LineSegments, Line];
  traverseMeshes(root, meshTypes, function(mesh) {
    mesh.applyMatrix4(mtc[0]);
    for (var j2 = 1; j2 < mtcCount; ++j2) {
      var newMesh = new mesh.constructor(mesh.geometry, mesh.material);
      mesh.parent.add(newMesh);
      newMesh.applyMatrix4(mtc[j2]);
    }
  });
}
var processTransparentMaterial = /* @__PURE__ */ function() {
  var matValues = {
    prepassTransparancy: true,
    fakeOpacity: false,
    transparent: false,
    colorFromDepth: false,
    lights: false,
    shadowmap: false,
    fog: false
  };
  return function(root, material2) {
    if (!(material2 instanceof UberMaterial)) {
      return;
    }
    traverseMeshes(root, [Mesh, LineSegments], function(mesh) {
      mesh.material.setValues({
        prepassTransparancy: false,
        fakeOpacity: false
      });
      mesh.material.needsUpdate = true;
      mesh.layers.set(gfxutils.LAYERS.TRANSPARENT);
      var prepassTranspMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.PREPASS_TRANSPARENT);
      mesh.parent.add(prepassTranspMesh);
    });
  };
}();
var processColFromPosMaterial = /* @__PURE__ */ function() {
  var matValues = {
    colorFromPos: true,
    transparent: false,
    colorFromDepth: false,
    lights: false,
    shadowmap: false,
    fog: false,
    overrideColor: false,
    fogTransparent: false,
    attrColor: false,
    attrColor2: false,
    attrAlphaColor: false,
    fakeOpacity: false
  };
  return function(root, material2) {
    if (!(material2 instanceof UberMaterial)) {
      return;
    }
    traverseMeshes(root, [Mesh, LineSegments], function(mesh) {
      var colFromPosMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.COLOR_FROM_POSITION);
      mesh.parent.add(colFromPosMesh);
    });
  };
}();
var createShadowmapMaterial = /* @__PURE__ */ function() {
  var matValues = {
    colorFromDepth: true,
    orthoCam: true,
    lights: false,
    shadowmap: false,
    fog: false
  };
  return function(root, material2) {
    if (!(material2 instanceof UberMaterial)) {
      return;
    }
    traverseMeshes(root, [Mesh, LineSegments], function(mesh) {
      if (!mesh.receiveShadow && mesh.material.shadowmap) {
        mesh.material.setValues({
          shadowmap: false
        });
      }
      if (!mesh.material.lights) {
        return;
      }
      if (!mesh.castShadow) {
        return;
      }
      if (!gfxutils.belongToSelectLayers(mesh)) {
        return;
      }
      var shadowmapMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.SHADOWMAP);
      shadowmapMesh.isShadowmapMesh = true;
      mesh.parent.add(shadowmapMesh);
    });
  };
}();
function removeShadowmapMaterial(root, material2) {
  if (!(material2 instanceof UberMaterial)) {
    return;
  }
  traverseMeshes(root, [Mesh, LineSegments], function(mesh) {
    if (mesh.isShadowmapMesh) {
      mesh.parent.remove(mesh);
    }
  });
}
function forEachMeshInGroup(group, process2) {
  function processObj(object4) {
    if (object4 instanceof Mesh) {
      process2(object4);
    }
    for (var i2 = 0, l2 = object4.children.length; i2 < l2; i2++) {
      processObj(object4.children[i2]);
    }
  }
  processObj(group);
}
function _countMeshTriangles(mesh) {
  var geom = mesh.geometry;
  if (geom instanceof InstancedBufferGeometry) {
    var attribs = geom.attributes;
    for (var property in attribs) {
      if (attribs.hasOwnProperty(property) && attribs[property] instanceof InstancedBufferAttribute) {
        var currAttr = attribs[property];
        var indexSize = geom.index ? geom.index.array.length / 3 : 0;
        return indexSize * currAttr.array.length / currAttr.itemSize;
      }
    }
    return 0;
  }
  if (geom instanceof BufferGeometry) {
    return geom.index ? geom.index.array.length / 3 : 0;
  }
  return geom.faces ? geom.faces.length : 0;
}
function countTriangles(group) {
  var totalCount = 0;
  forEachMeshInGroup(group, function(mesh) {
    totalCount += _countMeshTriangles(mesh);
  });
  return totalCount;
}
var meshutils = {
  applyTransformsToMeshes,
  processTransparentMaterial,
  processColFromPosMaterial,
  createShadowmapMaterial,
  removeShadowmapMaterial,
  forEachMeshInGroup,
  countTriangles
};
var selectors$3 = chem.selectors;
var Representation = function() {
  function Representation2(index, mode2, colorer, selector) {
    _classCallCheck(this, Representation2);
    var startMaterialValues = {
      clipPlane: settings$1.now.draft.clipPlane,
      fogTransparent: settings$1.now.bg.transparent,
      shadowmap: settings$1.now.shadow.on,
      shadowmapType: settings$1.now.shadow.type
    };
    this.index = index;
    this.mode = mode2;
    this.colorer = colorer;
    this.selector = selector;
    this.selectorString = "";
    this.count = 0;
    this.material = new UberMaterial();
    this.material.setValues(startMaterialValues);
    this.material.setUberOptions({
      fogAlpha: settings$1.now.fogAlpha
    });
    this.materialPreset = materials$1.first;
    this.needsRebuild = true;
    this.visible = true;
    this.setMode(mode2);
  }
  _createClass(Representation2, [{
    key: "markAtoms",
    value: function markAtoms(complex) {
      this.count = complex.markAtoms(this.selector, 1 << this.index);
      this.needsRebuild = true;
      return this.count;
    }
  }, {
    key: "unmarkAtoms",
    value: function unmarkAtoms(complex) {
      complex.clearAtomBits(1 << this.index);
      this.count = 0;
    }
  }, {
    key: "setMode",
    value: function setMode(mode2) {
      this.mode = mode2;
    }
  }, {
    key: "setMaterialPreset",
    value: function setMaterialPreset(preset2) {
      this.materialPreset = preset2;
      this.material.setUberOptions(preset2.uberOptions);
      this.material.setValues(preset2.values);
    }
  }, {
    key: "reset",
    value: function reset2() {
      this.geo = null;
      this.selectionGeo = null;
    }
  }, {
    key: "buildGeometry",
    value: function buildGeometry(complex) {
      this.reset();
      this.needsRebuild = false;
      if (settings$1.now.ao) {
        this.material.setValues({
          normalsToGBuffer: settings$1.now.ao
        });
      }
      this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);
      if (this.material.uberOptions.opacity < 0.99 && settings$1.now.transparency === "prepass") {
        meshutils.processTransparentMaterial(this.geo, this.material);
      }
      this.geo.visible = this.visible;
      gfxutils.processObjRenderOrder(this.geo, this.materialPreset.id);
      meshutils.processColFromPosMaterial(this.geo, this.material);
      if (settings$1.now.shadow.on) {
        meshutils.createShadowmapMaterial(this.geo, this.material);
      }
      return this.geo;
    }
  }, {
    key: "buildSelectionGeometry",
    value: function buildSelectionGeometry(mask) {
      var sg = null;
      if (this.geo && "getSubset" in this.geo) {
        var meshes2 = this.geo.getSubset(mask);
        if (meshes2 && meshes2.length > 0) {
          sg = new Group();
          sg.matrixAutoUpdate = false;
          sg.matrix = this.geo.matrix;
          for (var j2 = 0; j2 < meshes2.length; j2++) {
            var m2 = meshes2[j2];
            sg.add(m2);
          }
        }
      }
      if (sg) {
        sg.visible = this.visible;
      }
      this.selectionGeo = sg;
      return this.selectionGeo;
    }
  }, {
    key: "compare",
    value: function compare(repSettings) {
      var diff = {};
      var selStr = String(this.selector);
      if (!repSettings || selStr.valueOf() !== String(repSettings.selector).valueOf()) {
        diff.selector = selStr;
      }
      var modeDiff = this.mode.identify();
      if (!repSettings || Array.isArray(modeDiff) || modeDiff !== repSettings.mode) {
        diff.mode = modeDiff;
      }
      var colorerDiff = this.colorer.identify();
      if (!repSettings || Array.isArray(colorerDiff) || colorerDiff !== repSettings.colorer) {
        diff.colorer = colorerDiff;
      }
      if (!repSettings || this.materialPreset.id !== repSettings.material) {
        diff.material = this.materialPreset.id;
      }
      return diff;
    }
  }, {
    key: "change",
    value: function change(repSettings, complex, mode2, color2) {
      var diff = {};
      if (repSettings.selector) {
        var newSelectorObject = selectors$3.parse(repSettings.selector).selector;
        var newSelector = String(newSelectorObject);
        if (this.selectorString !== newSelector) {
          diff.selector = newSelector;
          this.selectorString = newSelector;
          this.selector = newSelectorObject;
          this.markAtoms(complex);
        }
      }
      if (repSettings.mode) {
        var newMode = repSettings.mode;
        if (!(0, import_lodash.isEqual)(this.mode.identify(), newMode)) {
          diff.mode = newMode;
          this.setMode(mode2);
        }
      }
      if (repSettings.colorer) {
        var newColorer = repSettings.colorer;
        if (!(0, import_lodash.isEqual)(this.colorer.identify(), newColorer)) {
          diff.colorer = newColorer;
          this.colorer = color2;
        }
      }
      if (repSettings.material) {
        var newMaterial = repSettings.material;
        if (!(0, import_lodash.isEqual)(this.materialPreset.id, newMaterial)) {
          diff.material = newMaterial;
          this.setMaterialPreset(materials$1.get(repSettings.material));
        }
      }
      return diff;
    }
  }, {
    key: "show",
    value: function show(visible) {
      this.visible = visible;
      if (this.geo) {
        this.geo.visible = visible;
      }
      if (this.selectionGeo) {
        this.selectionGeo.visible = visible;
      }
    }
  }]);
  return Representation2;
}();
function _createSuper$A(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$A();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$A() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _traverseComponentGroups(root, component, callback) {
  var children = root.children;
  if (!children) {
    return;
  }
  for (var i2 = 0, n2 = children.length; i2 < n2; ++i2) {
    var child = children[i2];
    if (child._component === component) {
      callback(child);
    }
    if (child instanceof gfxutils.RCGroup) {
      _traverseComponentGroups(child, component, callback);
    }
  }
}
function ComplexEditor() {
}
var ComplexComponentEditor = function(_ComplexEditor) {
  _inherits(ComplexComponentEditor2, _ComplexEditor);
  var _super = _createSuper$A(ComplexComponentEditor2);
  function ComplexComponentEditor2(complexVisual) {
    var _this;
    _classCallCheck(this, ComplexComponentEditor2);
    _this = _super.call(this);
    _this._complexVisual = complexVisual;
    _this._inProgress = false;
    return _this;
  }
  _createClass(ComplexComponentEditor2, [{
    key: "begin",
    value: function begin() {
      var complex = this._complexVisual.getComplex();
      this._componentTransforms = [];
      for (var i2 = 0; i2 < complex._components.length; ++i2) {
        var component = complex._components[i2];
        this._componentTransforms[component._index] = new Object3D();
      }
      this._inProgress = true;
      return true;
    }
  }, {
    key: "apply",
    value: function apply2() {
      if (!this._inProgress) {
        return;
      }
      var complex = this._complexVisual.getComplex();
      for (var i2 = 0; i2 < complex._components.length; ++i2) {
        this._bakeComponentTransform(complex._components[i2]);
      }
      complex.onAtomPositionChanged();
      this._resetComponentTransform();
      this._complexVisual.finalizeEdit();
    }
  }, {
    key: "discard",
    value: function discard() {
      if (!this._inProgress) {
        return;
      }
      this._resetComponentTransform();
      this._complexVisual.finalizeEdit();
    }
  }, {
    key: "getAltObj",
    value: function getAltObj() {
      var res = {
        objects: [],
        pivot: new Vector3(0, 0, 0)
      };
      var visual = this._complexVisual;
      var component = visual.getSelectedComponent();
      if (component === null) {
        return res;
      }
      var selection = this._complexVisual.getSelectionGeo();
      var selectionMask = 1 << visual.getSelectionBit();
      var i2;
      var j2;
      var reprNode;
      var geo;
      _traverseComponentGroups(visual, component, function(child) {
        res.objects.push(child);
      });
      for (i2 = 0; i2 < selection.children.length; ++i2) {
        reprNode = selection.children[i2];
        for (j2 = 0; j2 < reprNode.children.length; ++j2) {
          geo = reprNode.children[j2];
          if (geo.hasOwnProperty("_component") && geo._component === component) {
            res.objects.push(geo);
          }
        }
      }
      res.objects.push(this._componentTransforms[component._index]);
      var bbmin = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      var bbmax = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      component.forEachResidue(function(residue2) {
        var atoms = residue2._atoms;
        for (j2 = 0; j2 < atoms.length; ++j2) {
          if (atoms[j2].mask & selectionMask) {
            bbmin.min(atoms[j2].position);
            bbmax.max(atoms[j2].position);
          }
        }
      });
      res.pivot.lerpVectors(bbmin, bbmax, 0.5);
      return res;
    }
  }, {
    key: "_bakeComponentTransform",
    value: function _bakeComponentTransform(component) {
      var t2 = this._componentTransforms[component._index];
      if (t2 && (!(t2.position.x === 0 && t2.position.y === 0 && t2.position.z === 0) || !(t2.quaternion.x === 0 && t2.quaternion.y === 0 && t2.quaternion.z === 0 && t2.quaternion.w === 1))) {
        t2.updateMatrix();
        component.forEachResidue(function(residue2) {
          var atoms = residue2._atoms;
          for (var j2 = 0; j2 < atoms.length; ++j2) {
            atoms[j2].position.applyMatrix4(t2.matrix);
          }
        });
      }
    }
  }, {
    key: "_resetComponentTransform",
    value: function _resetComponentTransform() {
      var visual = this._complexVisual;
      var selection = this._complexVisual.getSelectionGeo();
      var i2;
      var j2;
      var reprNode;
      var geo;
      for (i2 = 0; i2 < this._componentTransforms.length; ++i2) {
        geo = this._componentTransforms[i2];
        geo.position.set(0, 0, 0);
        geo.quaternion.set(0, 0, 0, 1);
      }
      for (i2 = 0; i2 < visual.children.length; ++i2) {
        reprNode = visual.children[i2];
        for (j2 = 0; j2 < reprNode.children.length; ++j2) {
          geo = reprNode.children[j2];
          if (geo.hasOwnProperty("_component")) {
            geo.position.set(0, 0, 0);
            geo.quaternion.set(0, 0, 0, 1);
          }
        }
      }
      for (i2 = 0; i2 < selection.children.length; ++i2) {
        reprNode = selection.children[i2];
        for (j2 = 0; j2 < reprNode.children.length; ++j2) {
          geo = reprNode.children[j2];
          if (geo.hasOwnProperty("_component")) {
            geo.position.set(0, 0, 0);
            geo.quaternion.set(0, 0, 0, 1);
          }
        }
      }
    }
  }]);
  return ComplexComponentEditor2;
}(ComplexEditor);
var ComplexFragmentEditor = function(_ComplexEditor2) {
  _inherits(ComplexFragmentEditor2, _ComplexEditor2);
  var _super2 = _createSuper$A(ComplexFragmentEditor2);
  function ComplexFragmentEditor2(complexVisual) {
    var _this2;
    _classCallCheck(this, ComplexFragmentEditor2);
    _this2 = _super2.call(this);
    _this2._complexVisual = complexVisual;
    _this2._inProgress = false;
    return _this2;
  }
  _createClass(ComplexFragmentEditor2, [{
    key: "begin",
    value: function begin() {
      var visual = this._complexVisual;
      var selection = this._complexVisual.getSelectionGeo();
      var atoms = this._getSelectionBorderAtoms();
      if (atoms.length < 1 || atoms.length > 2) {
        logger.error("Can only edit fragments with one or two bound atoms.");
        return false;
      }
      this._fragmentBoundAtoms = atoms;
      var selectionMask = 1 << visual.getSelectionBit();
      visual.disableSubset(selectionMask, true);
      for (var k2 = 0; k2 < selection.children.length; ++k2) {
        selection.children[k2].visible = false;
      }
      var pivotPos = atoms[0].position.clone();
      if (atoms.length === 2) {
        pivotPos.lerp(atoms[1].position, 0.5);
      }
      this._fragmentGeo = new Group();
      visual.add(this._fragmentGeo);
      this._fragmentGeo.position.copy(pivotPos);
      this._fragmentSelectionGeo = new Group();
      selection.add(this._fragmentSelectionGeo);
      this._fragmentSelectionGeo.position.copy(pivotPos);
      var offset = pivotPos.clone();
      offset.negate();
      for (var i2 = 0; i2 < visual.children.length; ++i2) {
        var g2 = visual.children[i2];
        if (!("getSubset" in g2)) {
          continue;
        }
        var vg = new Group();
        this._fragmentGeo.add(vg);
        var sg = new Group();
        this._fragmentSelectionGeo.add(sg);
        var meshes2 = g2.getSubset(selectionMask, true);
        for (var j2 = 0; j2 < meshes2.length; j2++) {
          var m2 = meshes2[j2];
          vg.add(m2);
          m2.position.copy(offset);
        }
        var smeshes = g2.getSubset(selectionMask, true);
        for (var h2 = 0; h2 < smeshes.length; h2++) {
          var sm = smeshes[h2];
          sg.add(sm);
          sm.position.copy(offset);
        }
      }
      gfxutils.applySelectionMaterial(this._fragmentSelectionGeo);
      this._inProgress = true;
      return true;
    }
  }, {
    key: "apply",
    value: function apply2() {
      if (!this._inProgress) {
        return;
      }
      var visual = this._complexVisual;
      var selectionBit = visual.getSelectionBit();
      var p2 = this._fragmentGeo.position;
      var m2 = this._fragmentGeo.matrix.clone();
      m2.multiply(new Matrix4().makeTranslation(-p2.x, -p2.y, -p2.z));
      this._bakeAtomTransform(m2, 1 << selectionBit);
      visual.enableSubset(1 << selectionBit, true);
      visual.getComplex().onAtomPositionChanged();
      visual.finalizeEdit();
    }
  }, {
    key: "discard",
    value: function discard() {
      if (!this._inProgress) {
        return;
      }
      var visual = this._complexVisual;
      var selection = this._complexVisual.getSelectionGeo();
      this._fragmentGeo.parent.remove(this._fragmentGeo);
      visual.enableSubset(1 << visual.getSelectionBit(), true);
      for (var i2 = 0; i2 < selection.children.length; ++i2) {
        var node = selection.children[i2];
        if (node.visible) {
          selection.remove(node);
        } else {
          node.visible = true;
        }
      }
      visual.finalizeEdit();
    }
  }, {
    key: "isFreeRotationAllowed",
    value: function isFreeRotationAllowed() {
      return this._fragmentBoundAtoms.length < 2;
    }
  }, {
    key: "getAltObj",
    value: function getAltObj() {
      var res = {
        objects: [],
        pivot: new Vector3(0, 0, 0)
      };
      res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);
      var boundAtoms = this._fragmentBoundAtoms;
      if (boundAtoms.length === 1) {
        if (boundAtoms[0].bonds.length === 1) {
          var bond = boundAtoms[0].bonds[0];
          res.axis = new Vector3().subVectors(bond._right.position, bond._left.position);
          res.axis.normalize();
          res.axis.transformDirection(this._complexVisual.matrixWorld);
        }
      } else if (boundAtoms.length === 2) {
        res.axis = new Vector3().subVectors(boundAtoms[1].position, boundAtoms[0].position);
        res.axis.normalize();
        res.axis.transformDirection(this._complexVisual.matrixWorld);
      }
      return res;
    }
  }, {
    key: "_getSelectionBorderAtoms",
    value: function _getSelectionBorderAtoms() {
      var complex = this._complexVisual.getComplex();
      var selectionMask = 1 << this._complexVisual.getSelectionBit();
      var atomHash = {};
      complex.forEachBond(function(bond) {
        if (bond._left.mask & selectionMask) {
          if ((bond._right.mask & selectionMask) === 0) {
            atomHash[bond._left.index] = 1;
          }
        } else if (bond._right.mask & selectionMask) {
          atomHash[bond._right.index] = 1;
        }
      });
      var atoms = [];
      var keys2 = Object.keys(atomHash);
      for (var i2 = 0, n2 = keys2.length; i2 < n2; ++i2) {
        var idx = keys2[i2];
        atoms.push(complex._atoms[idx]);
      }
      return atoms;
    }
  }, {
    key: "_bakeAtomTransform",
    value: function _bakeAtomTransform(matrix, mask) {
      this._complexVisual.getComplex().forEachAtom(function(atom) {
        if (atom.mask & mask) {
          atom.position.applyMatrix4(matrix);
        }
      });
    }
  }]);
  return ComplexFragmentEditor2;
}(ComplexEditor);
var ComplexVisualEdit = {
  ComponentEditor: ComplexComponentEditor,
  FragmentEditor: ComplexFragmentEditor
};
function _createSuper$z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$z() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var selectors$2 = chem.selectors;
function lookupAndCreate(entityList, specs) {
  if (!Array.isArray(specs)) {
    specs = [specs];
  }
  var _specs = specs, _specs2 = _slicedToArray(_specs, 2), id = _specs2[0], opts = _specs2[1];
  var Entity = entityList.get(id) || entityList.first;
  return new Entity(opts);
}
var ComplexVisual = function(_Visual) {
  _inherits(ComplexVisual2, _Visual);
  var _super = _createSuper$z(ComplexVisual2);
  function ComplexVisual2(name2, dataSource) {
    var _this;
    _classCallCheck(this, ComplexVisual2);
    _this = _super.call(this, name2, dataSource);
    _this._complex = dataSource;
    _this._reprList = [];
    _this._repr = null;
    _this._reprListChanged = true;
    _this._selectionBit = 0;
    _this._reprUsedBits = 0;
    _this._selectionCount = 0;
    _this._selectionGeometry = new Group();
    return _this;
  }
  _createClass(ComplexVisual2, [{
    key: "getBoundaries",
    value: function getBoundaries() {
      return this._complex.getBoundaries();
    }
  }, {
    key: "release",
    value: function release2() {
      if (this._selectionGeometry.parent) {
        this._selectionGeometry.remove(this._selectionGeometry);
      }
      Visual.prototype.release.call(this);
    }
  }, {
    key: "getComplex",
    value: function getComplex() {
      return this._complex;
    }
  }, {
    key: "getSelectionCount",
    value: function getSelectionCount() {
      return this._selectionCount;
    }
  }, {
    key: "getSelectionGeo",
    value: function getSelectionGeo() {
      return this._selectionGeometry;
    }
  }, {
    key: "getSelectionBit",
    value: function getSelectionBit() {
      return this._selectionBit;
    }
  }, {
    key: "getEditor",
    value: function getEditor() {
      return this._editor;
    }
  }, {
    key: "resetReps",
    value: function resetReps(reps) {
      if (this._complex) {
        this._complex.clearAtomBits(~0);
      }
      this._reprListChanged = true;
      this._reprUsedBits = 0;
      this._reprList.length = reps.length;
      for (var i2 = 0, n2 = reps.length; i2 < n2; ++i2) {
        var rep2 = reps[i2];
        var selector = void 0;
        var selectorString = void 0;
        if (typeof rep2.selector === "string") {
          selectorString = rep2.selector;
          var _selectors$parse = selectors$2.parse(selectorString);
          selector = _selectors$parse.selector;
        } else if (typeof rep2.selector === "undefined") {
          selectorString = settings$1.now.presets.default[0].selector;
          var _selectors$parse2 = selectors$2.parse(selectorString);
          selector = _selectors$parse2.selector;
        } else {
          selector = rep2.selector;
          selectorString = selector.toString();
        }
        var mode2 = lookupAndCreate(modes$1, rep2.mode);
        var colorer = lookupAndCreate(colorers$1, rep2.colorer);
        var material2 = materials$1.get(rep2.material) || materials$1.first;
        this._reprList[i2] = new Representation(i2, mode2, colorer, selector);
        this._reprList[i2].setMaterialPreset(material2);
        this._reprList[i2].selectorString = selectorString;
        if (this._complex) {
          this._complex.markAtoms(selector, 1 << i2);
        }
        this._reprUsedBits |= 1 << i2;
      }
      this._repr = reps.length > 0 ? this._reprList[0] : null;
      this._selectionBit = reps.length;
      this._reprUsedBits |= 1 << this._selectionBit;
      this._selectionCount = 0;
      if (this._complex) {
        this._complex.update();
      }
    }
  }, {
    key: "repCount",
    value: function repCount() {
      return this._reprList.length;
    }
  }, {
    key: "repCurrent",
    value: function repCurrent(index) {
      if (index >= 0 && index < this._reprList.length) {
        this._repr = this._reprList[index];
      } else {
        index = this._reprList.indexOf(this._repr);
      }
      return index;
    }
  }, {
    key: "rep",
    value: function rep2(index, _rep) {
      if (!_rep && (index === void 0 || index instanceof Object)) {
        _rep = index;
        index = this.repCurrent();
      }
      if (index < 0 || index > this._reprList.length) {
        logger.error("Rep ".concat(index, " does not exist!"));
        return null;
      }
      if (index === this._reprList.length) {
        var res = this.repAdd(_rep);
        logger.warn("Rep ".concat(index, " does not exist! New representation was created."));
        return {
          desc: res.desc,
          index,
          status: "created"
        };
      }
      var target = this._reprList[index];
      var desc = {
        selector: target.selectorString,
        mode: target.mode.identify(),
        colorer: target.colorer.identify(),
        material: target.materialPreset.id
      };
      if (_rep) {
        var diff = target.change(_rep, this._complex, lookupAndCreate(modes$1, _rep.mode), lookupAndCreate(colorers$1, _rep.colorer));
        if (!(0, import_lodash.isEmpty)(diff)) {
          target.needsRebuild = true;
          for (var key in diff) {
            if (diff.hasOwnProperty(key)) {
              desc[key] = diff[key];
              logger.debug("rep[".concat(index, "].").concat(key, " changed to ").concat(diff[key]));
            }
          }
          if (diff.mode && target.mode.isSurface && (settings$1.now.resolution === "ultra" || settings$1.now.resolution === "high")) {
            logger.report('Surface resolution was changed to "medium" to avoid hang-ups.');
            settings$1.set("resolution", "medium");
          }
          return {
            desc,
            index,
            status: "changed"
          };
        }
      }
      return {
        desc,
        index,
        status: ""
      };
    }
  }, {
    key: "repGet",
    value: function repGet(index) {
      if (index === void 0 || index instanceof Object) {
        index = this.repCurrent();
      }
      if (index < 0 || index >= this._reprList.length) {
        return null;
      }
      return this._reprList[index];
    }
  }, {
    key: "_getFreeReprIdx",
    value: function _getFreeReprIdx() {
      var bits = this._reprUsedBits;
      for (var i2 = 0; i2 <= ComplexVisual2.NUM_REPRESENTATION_BITS; ++i2, bits >>= 1) {
        if ((bits & 1) === 0) {
          return i2;
        }
      }
      return -1;
    }
  }, {
    key: "repAdd",
    value: function repAdd(rep2) {
      if (this._reprList.length >= ComplexVisual2.NUM_REPRESENTATION_BITS) {
        return null;
      }
      var newSelectionBit = this._getFreeReprIdx();
      if (newSelectionBit < 0) {
        return null;
      }
      var originalSelection = this.buildSelectorFromMask(1 << this._selectionBit);
      var def = settings$1.now.presets.default[0];
      var desc = (0, import_lodash.merge)({
        selector: def.selector,
        mode: def.mode,
        colorer: def.colorer,
        material: def.material
      }, rep2);
      var selector = typeof desc.selector === "string" ? selectors$2.parse(desc.selector).selector : desc.selector;
      var target = new Representation(this._selectionBit, lookupAndCreate(modes$1, desc.mode), lookupAndCreate(colorers$1, desc.colorer), selector);
      target.selectorString = selector.toString();
      target.setMaterialPreset(materials$1.get(desc.material));
      target.markAtoms(this._complex);
      this._reprList.push(target);
      this._selectionBit = newSelectionBit;
      this._reprUsedBits |= 1 << this._selectionBit;
      this._complex.markAtoms(originalSelection, 1 << this._selectionBit);
      return {
        desc,
        index: this._reprList.length - 1
      };
    }
  }, {
    key: "repRemove",
    value: function repRemove(index) {
      if (index === void 0) {
        index = this.repCurrent();
      }
      var count = this._reprList.length;
      if (index < 0 || index >= count || count <= 1) {
        return;
      }
      var target = this._reprList[index];
      target.unmarkAtoms(this._complex);
      this._reprUsedBits &= ~(1 << target.index);
      this._reprList.splice(index, 1);
      if (target === this._repr) {
        --count;
        index = index < count ? index : count - 1;
        this._repr = this._reprList[index];
      }
      this._reprListChanged = true;
    }
  }, {
    key: "repHide",
    value: function repHide(index, hide) {
      if (hide === void 0) {
        hide = true;
      }
      if (index < 0 || index >= this._reprList.length) {
        return;
      }
      var target = this._reprList[index];
      target.show(!hide);
    }
  }, {
    key: "select",
    value: function select3(selector, append) {
      if (append) {
        this._selectionCount += this._complex.markAtomsAdditionally(selector, 1 << this._selectionBit);
      } else {
        this._selectionCount = this._complex.markAtoms(selector, 1 << this._selectionBit);
      }
      this._complex.updateStructuresMask();
      this.rebuildSelectionGeometry();
    }
  }, {
    key: "resetSelectionMask",
    value: function resetSelectionMask() {
      if (this._selectionCount !== 0) {
        this._selectionCount = 0;
        if (this._complex) {
          this._complex.clearAtomBits(1 << this._selectionBit);
        }
      }
    }
  }, {
    key: "updateSelectionMask",
    value: function updateSelectionMask(pickedObj) {
      var self2 = this;
      var atom = pickedObj.atom;
      var residue2 = pickedObj.residue, chain2 = pickedObj.chain, molecule = pickedObj.molecule;
      var setMask = 1 << this._selectionBit;
      var clearMask = ~setMask;
      if (atom) {
        residue2 = atom.residue;
        chain2 = residue2._chain;
        molecule = residue2._molecule;
        if (atom.mask & setMask) {
          atom.mask &= clearMask;
          residue2._mask &= clearMask;
          chain2._mask &= clearMask;
          if (molecule) {
            molecule.mask &= clearMask;
          }
          this._selectionCount--;
        } else {
          atom.mask |= setMask;
          this._selectionCount++;
          residue2.collectMask();
          chain2.collectMask();
          if (molecule) {
            molecule.collectMask();
          }
        }
      } else if (residue2) {
        chain2 = residue2._chain;
        molecule = residue2._molecule;
        if (residue2._mask & setMask) {
          residue2._mask &= clearMask;
          chain2._mask &= clearMask;
          residue2.forEachAtom(function(a2) {
            if (a2.mask & setMask) {
              a2.mask &= clearMask;
              self2._selectionCount--;
            }
          });
        } else {
          residue2._mask |= setMask;
          residue2.forEachAtom(function(a2) {
            if (!(a2.mask & setMask)) {
              a2.mask |= setMask;
              self2._selectionCount++;
            }
          });
          chain2.collectMask();
          if (molecule) {
            molecule.collectMask();
          }
        }
      } else if (chain2 || molecule) {
        var obj = chain2 || molecule;
        if (obj._mask & setMask) {
          obj._mask &= clearMask;
          obj.forEachResidue(function(r2) {
            if (r2._mask & setMask) {
              r2._mask &= clearMask;
              r2.forEachAtom(function(a2) {
                if (a2.mask & setMask) {
                  a2.mask &= clearMask;
                  self2._selectionCount--;
                }
              });
              r2._mask &= clearMask;
            }
          });
        } else {
          obj._mask |= setMask;
          obj.forEachResidue(function(r2) {
            if (!(r2._mask & setMask)) {
              r2._mask |= setMask;
              r2.forEachAtom(function(a2) {
                if (!(a2.mask & setMask)) {
                  a2.mask |= setMask;
                  self2._selectionCount++;
                }
              });
              var otherObj = chain2 ? r2.getMolecule() : r2.getChain();
              if (otherObj) {
                otherObj.collectMask();
              }
            }
          });
        }
      } else {
        this.resetSelectionMask();
      }
    }
  }, {
    key: "expandSelection",
    value: function expandSelection() {
      var self2 = this;
      var selectionMask = 1 << this._selectionBit;
      var tmpMask = 1 << 31;
      this._complex.forEachBond(function(bond) {
        if (bond._left.mask & selectionMask) {
          if ((bond._right.mask & selectionMask) === 0) {
            bond._right.mask |= tmpMask;
          }
        } else if (bond._right.mask & selectionMask) {
          bond._left.mask |= tmpMask;
        }
      });
      var deselectionMask = ~tmpMask;
      this._complex.forEachAtom(function(atom) {
        if (atom.mask & tmpMask) {
          atom.mask = atom.mask & deselectionMask | selectionMask;
          ++self2._selectionCount;
        }
      });
      this._complex.updateStructuresMask();
    }
  }, {
    key: "shrinkSelection",
    value: function shrinkSelection() {
      var self2 = this;
      var selectionMask = 1 << this._selectionBit;
      var tmpMask = 1 << 31;
      this._complex.forEachBond(function(bond) {
        if (bond._left.mask & selectionMask) {
          if ((bond._right.mask & selectionMask) === 0) {
            bond._left.mask |= tmpMask;
          }
        } else if (bond._right.mask & selectionMask) {
          bond._right.mask |= tmpMask;
        }
      });
      this._complex.forEachAtom(function(atom) {
        if (atom.mask & selectionMask && atom.bonds.length === 1) {
          atom.mask |= tmpMask;
        }
      });
      var deselectionMask = ~(selectionMask | tmpMask);
      this._complex.forEachAtom(function(atom) {
        if (atom.mask & tmpMask) {
          atom.mask &= deselectionMask;
          --self2._selectionCount;
        }
      });
      this._complex.updateStructuresMask();
    }
  }, {
    key: "getSelectedComponent",
    value: function getSelectedComponent() {
      var selectionMask = 1 << this._selectionBit;
      var component = null;
      var multiple = false;
      this._complex.forEachAtom(function(atom) {
        if (atom.mask & selectionMask) {
          if (component === null) {
            component = atom.residue._component;
          } else if (component !== atom.residue._component) {
            multiple = true;
          }
        }
      });
      return multiple ? null : component;
    }
  }, {
    key: "getSelectionCenter",
    value: function getSelectionCenter(center, includesAtom, selRule) {
      center.set(0, 0, 0);
      var count = 0;
      this._complex.forEachAtom(function(atom) {
        if (includesAtom(atom, selRule)) {
          center.add(atom.position);
          count++;
        }
      });
      if (count === 0) {
        return false;
      }
      center.divideScalar(count);
      center.applyMatrix4(this.matrix);
      return true;
    }
  }, {
    key: "needsRebuild",
    value: function needsRebuild() {
      if (this._reprListChanged) {
        return true;
      }
      var reprList = this._reprList;
      for (var i2 = 0, n2 = reprList.length; i2 < n2; ++i2) {
        var repr = reprList[i2];
        if (repr.needsRebuild) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "rebuild",
    value: function rebuild() {
      var self2 = this;
      gfxutils.clearTree(this);
      return new Promise(function(resolve) {
        var complex = self2._complex;
        if (!complex) {
          resolve();
          return;
        }
        var errorOccured = false;
        setTimeout(function() {
          console.time("build");
          var reprList = self2._reprList;
          var palette2 = palettes$1.get(settings$1.now.palette) || palettes$1.first;
          var hasGeometry = false;
          for (var i2 = 0, n2 = reprList.length; i2 < n2; ++i2) {
            var repr = reprList[i2];
            repr.colorer.palette = palette2;
            if (repr.needsRebuild) {
              repr.reset();
              try {
                repr.buildGeometry(complex);
              } catch (e2) {
                if (e2 instanceof utils.OutOfMemoryError) {
                  repr.needsRebuild = false;
                  repr.reset();
                  logger.error("Not enough memory to build geometry for representation ".concat(repr.index + 1));
                  errorOccured = true;
                } else {
                  throw e2;
                }
              }
            }
            hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);
            if (repr.geo) {
              self2.add(repr.geo);
            }
          }
          self2._reprListChanged = false;
          console.timeEnd("build");
          resolve();
        }, 10);
      });
    }
  }, {
    key: "setNeedsRebuild",
    value: function setNeedsRebuild() {
      var reprList = this._reprList;
      for (var i2 = 0, n2 = reprList.length; i2 < n2; ++i2) {
        reprList[i2].needsRebuild = true;
      }
    }
  }, {
    key: "rebuildSelectionGeometry",
    value: function rebuildSelectionGeometry() {
      var mask = 1 << this._selectionBit;
      gfxutils.clearTree(this._selectionGeometry);
      for (var i2 = 0, n2 = this._reprList.length; i2 < n2; ++i2) {
        var repr = this._reprList[i2];
        var sg = repr.buildSelectionGeometry(mask);
        if (!sg) {
          continue;
        }
        this._selectionGeometry.add(sg);
        for (var j2 = 0; j2 < sg.children.length; j2++) {
          var m2 = sg.children[j2];
          if (this._editor && this._editor._componentTransforms) {
            var t2 = this._editor._componentTransforms[m2._component._index];
            if (t2) {
              m2.position.copy(t2.position);
              m2.quaternion.copy(t2.quaternion);
            }
          }
        }
        gfxutils.applySelectionMaterial(sg);
      }
    }
  }, {
    key: "_buildSelectorFromSortedLists",
    value: function _buildSelectorFromSortedLists(atoms, residues, chains) {
      var complex = this._complex;
      function optimizeList(list) {
        var result = [];
        var k2 = 0;
        var first = NaN;
        var last = NaN;
        for (var i2 = 0, n2 = list.length; i2 < n2; ++i2) {
          var value = list[i2];
          if (value === last + 1) {
            last = value;
          } else {
            if (!Number.isNaN(first)) {
              result[k2++] = new selectors$2.Range(first, last);
            }
            first = last = value;
          }
        }
        if (!Number.isNaN(first)) {
          result[k2] = new selectors$2.Range(first, last);
        }
        return result;
      }
      var expression = null;
      if (chains.length === complex._chains.length) {
        expression = selectors$2.all();
      } else {
        var selector;
        if (chains.length > 0) {
          selector = selectors$2.chain(chains);
          expression = expression ? selectors$2.or(expression, selector) : selector;
        }
        if (Object.keys(residues).length > 0) {
          for (var ch in residues) {
            if (residues.hasOwnProperty(ch)) {
              selector = selectors$2.and(selectors$2.chain(ch), selectors$2.residx(optimizeList(residues[ch])));
              expression = expression ? selectors$2.or(expression, selector) : selector;
            }
          }
        }
        if (atoms.length > 0) {
          selector = selectors$2.serial(optimizeList(atoms));
          expression = expression ? selectors$2.or(expression, selector) : selector;
        }
        if (!expression) {
          expression = selectors$2.none();
        }
      }
      return expression;
    }
  }, {
    key: "buildSelectorFromMask",
    value: function buildSelectorFromMask(mask) {
      var complex = this._complex;
      var chains = [];
      var residues = {};
      var atoms = [];
      complex.forEachChain(function(chain2) {
        if (chain2._mask & mask) {
          chains.push(chain2._name);
        }
      });
      complex.forEachResidue(function(residue2) {
        if (residue2._mask & mask && !(residue2._chain._mask & mask)) {
          var c2 = residue2._chain._name;
          if (!(c2 in residues)) {
            residues[c2] = [residue2._index];
          } else {
            residues[c2].push(residue2._index);
          }
        }
      });
      complex.forEachAtom(function(atom) {
        if (atom.mask & mask && !(atom.residue._mask & mask)) {
          atoms.push(atom.serial);
        }
      });
      return this._buildSelectorFromSortedLists(atoms, residues, chains);
    }
  }, {
    key: "forSelectedResidues",
    value: function forSelectedResidues(process2) {
      var selectionMask = 1 << this._selectionBit;
      this._complex.forEachResidue(function(residue2) {
        if (residue2._mask & selectionMask) {
          process2(residue2);
        }
      });
    }
  }, {
    key: "beginComponentEdit",
    value: function beginComponentEdit() {
      if (this._editor) {
        return null;
      }
      var editor = new ComplexVisualEdit.ComponentEditor(this);
      if (!editor.begin()) {
        return null;
      }
      this._editor = editor;
      return editor;
    }
  }, {
    key: "beginFragmentEdit",
    value: function beginFragmentEdit() {
      if (this._editor) {
        return null;
      }
      var editor = new ComplexVisualEdit.FragmentEditor(this);
      if (!editor.begin()) {
        return null;
      }
      this._editor = editor;
      return editor;
    }
  }, {
    key: "finalizeEdit",
    value: function finalizeEdit() {
      this._editor = null;
    }
  }, {
    key: "setMaterialValues",
    value: function setMaterialValues(values) {
      var needTraverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var process2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      for (var i2 = 0, n2 = this._reprList.length; i2 < n2; ++i2) {
        var rep2 = this._reprList[i2];
        rep2.material.setValues(values);
        if (needTraverse) {
          rep2.geo.traverse(function(object4) {
            if (object4 instanceof Mesh) {
              object4.material.setValues(values);
              if (process2 !== void 0) {
                process2(object4);
              }
              object4.material.needsUpdate = true;
            }
          });
        }
      }
    }
  }, {
    key: "setUberOptions",
    value: function setUberOptions(values) {
      for (var i2 = 0, n2 = this._reprList.length; i2 < n2; ++i2) {
        var rep2 = this._reprList[i2];
        rep2.material.setUberOptions(values);
      }
    }
  }, {
    key: "within",
    value: function within(selector, radius) {
      var vw = this._complex.getVoxelWorld();
      if (vw === null) {
        return false;
      }
      var selectionMask = 1 << this._selectionBit;
      this._complex.markAtoms(selector, selectionMask);
      if (vw) {
        vw.forEachAtomWithinDistFromMasked(this._complex, selectionMask, Number(radius), function(atom) {
          atom.mask |= selectionMask;
        });
      }
      this._selectionCount = this._complex.countAtomsByMask(selectionMask);
      this._complex.updateStructuresMask();
      return this.buildSelectorFromMask(selectionMask);
    }
  }]);
  return ComplexVisual2;
}(Visual);
ComplexVisual.NUM_REPRESENTATION_BITS = 30;
var vertexVolumeFaces = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  pos = position.xyz + 0.5;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";
var fragmentVolumeFaces = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(pos, 0.5);\r\n}";
var vertexVolume = "varying vec4 screenSpacePos;\r\n\r\nvoid main() {\r\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  gl_Position = screenSpacePos;\r\n}";
var fragmentVolume = "uniform mat4 projectionMatrix;\r\n\r\n// 3D volume texture\r\nuniform vec3 volumeDim;    // volume dimensions, pixels\r\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\r\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r\n\r\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\r\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\r\n\r\nuniform vec3 _isoLevel0;\r\nuniform float _flipV;\r\nuniform sampler2D _BFLeft;\r\nuniform sampler2D _BFRight;\r\nuniform sampler2D _FFLeft;\r\nuniform sampler2D _FFRight;\r\nuniform sampler2D _WFFLeft;\r\nuniform sampler2D _WFFRight;\r\n\r\nvarying vec4 screenSpacePos;\r\n\r\n#define NO_COLOR vec4(0., 0., 0., 0.)\r\n\r\nvec4 sample3DTexture(vec3 texCoord) {\r\n  // a pair of Z slices is determined by nearest slice border\r\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r\n\r\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\r\n\r\n  // calculate coords in tile texture for both slices\r\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n\r\n  // bilinear filtering\r\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r\n  return mix(colorSlice1, colorSlice2, weightSlice2);\r\n}\r\n\r\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\r\n  vec3 textCoord = boxCoord;\r\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\r\n\r\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\r\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\r\n    return NO_COLOR;\r\n\r\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\r\n\r\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\r\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\r\n    return NO_COLOR;\r\n\r\n  return sample3DTexture(textCoord);\r\n}\r\n\r\nfloat CalcColor(vec3 iter, vec3 dir) {\r\n  float d = 1. / 128.;\r\n  vec3 dx = vec3(d, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, d, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, d);\r\n\r\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\r\n  vec3 coordInc = mix(\r\n    vec3(\r\n      sample3DTextureInclined(iter + dx).x,\r\n      sample3DTextureInclined(iter + dy).x,\r\n      sample3DTextureInclined(iter + dz).x\r\n    ),\r\n    vec3(0. ,0. , 0.),\r\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\r\n  );\r\n\r\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\r\n  vec3 coordDec = mix(\r\n    vec3(0. ,0. , 0.),\r\n    vec3(\r\n      sample3DTextureInclined(iter - dx).x,\r\n      sample3DTextureInclined(iter - dy).x,\r\n      sample3DTextureInclined(iter - dz).x\r\n    ),\r\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\r\n  );\r\n\r\n  vec3 N = normalize(coordInc - coordDec);\r\n  float dif = max(0.0, dot(N, dir));\r\n  return dif;\r\n}\r\n\r\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\r\n  for (int i = 0; i < 5; i++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\r\n  for (int j = 0; j < 5; j++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if (vol < tr)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\r\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\r\n  vec3 step = stepSize * dir, iterator = start, left, right;\r\n  vec4 acc = NO_COLOR;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    iterator = iterator + step;\r\n    vol = sample3DTextureInclined(iterator).r;\r\n    if (length(iterator - back) <= stepSize || (vol > tr))\r\n      break;\r\n  }\r\n\r\n  if (vol > tr)\r\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\r\n\r\n  return acc;\r\n}\r\n\r\nfloat easeOut(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return 1.0 - (1.0 - t) * (1.0 - t);\r\n}\r\n\r\nfloat easeIn(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return t * t;\r\n}\r\n\r\nvec3 GetColSimple(float vol) {\r\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\r\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\r\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\r\n}\r\n\r\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 acc = NO_COLOR, iso;\r\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\r\n  vec3 step, col, colOld, right;\r\n  float tr0 = _isoLevel0.x;\r\n  float dif, r, kd, finish;\r\n  int count = 0, stopMol = 0;\r\n\r\n  for (int k = 0; k < 3; k++) {\r\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\r\n    kd = 140. * tr0 * stepSize;\r\n    r = 1. - kd;\r\n    step = stepSize * dir;\r\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\r\n      break;\r\n    iterator = iso.xyz;\r\n    dif = 1.;// CalcColor(iterator, dir);\r\n    colOld = GetColSimple(tr0);\r\n    curStepSize = stepSize;\r\n    for (int i = 0; i < STEPS_COUNT; i++) {\r\n      iterator = iterator + step;\r\n      molD = length(iterator - start);\r\n      vol = sample3DTextureInclined(iterator).r;\r\n      finish = distance(iterator, back) - stepSize;\r\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r\n        break;\r\n      alpha = (1. - r);\r\n      col = GetColSimple(vol);\r\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\r\n      vec3 colMid = GetColSimple(vol);\r\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\r\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n      colOld = col;\r\n    } // for i\r\n\r\n    if (finish < 0.0 || sumAlpha > 0.97)\r\n      break;\r\n\r\n    if (molD > molDist) {\r\n      curStepSize = stepSize - (molD - molDist);\r\n      right = iterator - (molD - molDist) * dir;\r\n      vol = sample3DTextureInclined(right).r;\r\n    } else {\r\n      vec3 left = iterator - step;\r\n      right = CorrectIso(left, iterator, tr0);\r\n      curStepSize = distance(left, right);\r\n      vol = tr0;\r\n    }\r\n\r\n    alpha = (1. - r) * curStepSize / stepSize;\r\n    dif = 1.;// CalcColor(right, dir);\r\n    col = GetColSimple(vol);\r\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\r\n    vec3 colMid = GetColSimple(vol);\r\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\r\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n\r\n    if (molD > molDist)\r\n      break;\r\n  } // for k\r\n  acc.rgb = 1. * sumColor / sumAlpha;\r\n  acc.a = sumAlpha;\r\n  return acc;\r\n}\r\n\r\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  float stepSize = 1.0 / float(STEPS_COUNT);\r\n  float len = length(back - start);\r\n  vec3 step = stepSize * dir;\r\n  vec3 iterator = start;\r\n  float acc = 0.0;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    if (float(i) * stepSize > len)\r\n      break;\r\n    iterator = iterator + step;\r\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\r\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\r\n  }\r\n\r\n  return vec4(1.,1.,1., acc);\r\n}\r\n\r\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\r\n  vec4 col = NO_COLOR;\r\n\r\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\r\n    float dif =  CalcColor(tst.xyz, dir);\r\n    dif = 0.9 * dif * dif;\r\n    col = vec4(dif, dif, dif, 1);\r\n  }\r\n  return col;\r\n}\r\n\r\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  return sample3DTexture(start);\r\n}\r\n\r\nvoid main() {\r\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r\n\r\n  if (_flipV > 0.0) {\r\n    tc.y = 1.0 - tc.y;\r\n  }\r\n\r\n  vec3 start;\r\n  vec3 back;\r\n  vec3 molBack;\r\n  if (projectionMatrix[0][2] < 0.0) {\r\n    start = texture2D(_FFLeft, tc.xy).xyz;\r\n    back = texture2D(_BFLeft, tc.xy).xyz;\r\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r\n  } else {\r\n    start = texture2D(_FFRight, tc.xy).xyz;\r\n    back = texture2D(_BFRight, tc.xy).xyz;\r\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\r\n  }\r\n\r\n  vec3 dir = normalize(back - start);\r\n\r\n  float molDist = 2.0;\r\n  if (length(molBack) > 0.001) {\r\n    molDist = distance(start, molBack);\r\n  }\r\n\r\n  #ifdef ISO_MODE\r\n    gl_FragColor = IsoRender(start, back, molDist, dir);\r\n  #else\r\n    gl_FragColor = VolRender(start, back, molDist, dir);\r\n  #endif\r\n}\r\n";
var vertexFarPlane = "varying vec4 volPos;\r\nuniform float aspectRatio;\r\nuniform float farZ;\r\nuniform float tanHalfFOV;\r\nuniform mat4  matWorld2Volume;\r\n\r\nvoid main() {\r\n  // rescale plane to fill in the whole far plane area seen from camera\r\n  vec3 pos = position.xyz;\r\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\r\n  pos.y = pos.y * tanHalfFOV * farZ;\r\n  // common transformation\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  // calc pos in volume CS\r\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  volPos = volPos + 0.5;\r\n  volPos.w = 0.5;\r\n}\r\n";
var fragmentFarPlane = "varying vec4 volPos;\r\n\r\nvoid main() {\r\n  gl_FragColor = volPos;\r\n}";
function _createSuper$y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$y() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var volumeUniforms = UniformsUtils.merge([{
  volumeDim: {
    type: "v3",
    value: new Vector3(512, 512, 512)
  },
  tileTex: {
    type: "t",
    value: null
  },
  tileTexSize: {
    type: "v2",
    value: new Vector2(512, 512)
  },
  tileStride: {
    type: "v2",
    value: new Vector2(512, 512)
  },
  boxAngles: {
    type: "v3",
    value: new Vector3(1, 1, 1)
  },
  delta: {
    type: "v3",
    value: new Vector3(0, 0, 0)
  },
  _isoLevel0: {
    type: "v2",
    value: new Vector3(0.5, 0.75, 1)
  },
  _flipV: {
    type: "f",
    value: 0
  },
  _BFLeft: {
    type: "t",
    value: null
  },
  _BFRight: {
    type: "t",
    value: null
  },
  _FFLeft: {
    type: "t",
    value: null
  },
  _FFRight: {
    type: "t",
    value: null
  },
  _WFFLeft: {
    type: "t",
    value: null
  },
  _WFFRight: {
    type: "t",
    value: null
  }
}]);
function overrideUniforms(params, defUniforms) {
  var uniforms = UniformsUtils.clone(defUniforms);
  for (var p2 in params) {
    if (uniforms.hasOwnProperty(p2)) {
      uniforms[p2].value = params[p2];
    }
  }
  return uniforms;
}
function facesPosMaterialParams(params, sideType) {
  return {
    uniforms: overrideUniforms(params, {}),
    vertexShader: vertexVolumeFaces,
    fragmentShader: fragmentVolumeFaces,
    transparent: false,
    depthTest: false,
    depthWrite: false,
    side: sideType
  };
}
var BackFacePosMaterial = function(_ShaderMaterial) {
  _inherits(BackFacePosMaterial2, _ShaderMaterial);
  var _super = _createSuper$y(BackFacePosMaterial2);
  function BackFacePosMaterial2(params) {
    _classCallCheck(this, BackFacePosMaterial2);
    var backFaceParams = facesPosMaterialParams(params, BackSide);
    return _super.call(this, backFaceParams);
  }
  return _createClass(BackFacePosMaterial2);
}(ShaderMaterial);
var ShaderParams = _createClass(function ShaderParams2(params, uniforms, vertexShader2, fragmentShader2) {
  _classCallCheck(this, ShaderParams2);
  this.uniforms = overrideUniforms(params, uniforms);
  this.vertexShader = vertexShader2;
  this.fragmentShader = fragmentShader2;
  this.transparent = false;
  this.depthTest = false;
  this.depthWrite = false;
  this.side = FrontSide;
});
var BackFacePosMaterialFarPlane = function(_ShaderMaterial2) {
  _inherits(BackFacePosMaterialFarPlane2, _ShaderMaterial2);
  var _super2 = _createSuper$y(BackFacePosMaterialFarPlane2);
  function BackFacePosMaterialFarPlane2(params) {
    _classCallCheck(this, BackFacePosMaterialFarPlane2);
    var matUniforms = UniformsUtils.merge([{
      aspectRatio: {
        type: "f",
        value: 0
      },
      farZ: {
        type: "f",
        value: 0
      },
      tanHalfFOV: {
        type: "f",
        value: 0
      },
      matWorld2Volume: {
        type: "4fv",
        value: new Matrix4()
      }
    }]);
    var shaderParams = new ShaderParams(params, matUniforms, vertexFarPlane, fragmentFarPlane);
    return _super2.call(this, shaderParams);
  }
  return _createClass(BackFacePosMaterialFarPlane2);
}(ShaderMaterial);
var FrontFacePosMaterial = function(_ShaderMaterial3) {
  _inherits(FrontFacePosMaterial2, _ShaderMaterial3);
  var _super3 = _createSuper$y(FrontFacePosMaterial2);
  function FrontFacePosMaterial2(params) {
    _classCallCheck(this, FrontFacePosMaterial2);
    var frontFaceParams = facesPosMaterialParams(params, FrontSide);
    return _super3.call(this, frontFaceParams);
  }
  return _createClass(FrontFacePosMaterial2);
}(ShaderMaterial);
var VolumeMaterial = function(_ShaderMaterial4) {
  _inherits(VolumeMaterial2, _ShaderMaterial4);
  var _super4 = _createSuper$y(VolumeMaterial2);
  function VolumeMaterial2(params) {
    var _this;
    _classCallCheck(this, VolumeMaterial2);
    var shaderParams = new ShaderParams(params, volumeUniforms, vertexVolume, fragmentVolume);
    shaderParams.transparent = true;
    shaderParams.depthTest = true;
    _this = _super4.call(this, shaderParams);
    _this.updateDefines();
    return _this;
  }
  _createClass(VolumeMaterial2, [{
    key: "updateDefines",
    value: function updateDefines() {
      this.defines = {
        ISO_MODE: settings$1.now.modes.VD.isoMode,
        STEPS_COUNT: settings$1.now.modes.VD.polyComplexity[settings$1.now.resolution] * 100
      };
      this.needsUpdate = true;
    }
  }]);
  return VolumeMaterial2;
}(ShaderMaterial);
var VolumeMaterial$1 = {
  BackFacePosMaterial,
  BackFacePosMaterialFarPlane,
  FrontFacePosMaterial,
  VolumeMaterial
};
function _createSuper$x(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$x();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$x() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VolumeMesh = function(_Mesh) {
  _inherits(VolumeMesh2, _Mesh);
  var _super = _createSuper$x(VolumeMesh2);
  function VolumeMesh2() {
    var _this;
    _classCallCheck(this, VolumeMesh2);
    var geo = new BufferGeometry();
    _this = _super.call(this, geo);
    _defineProperty2(_assertThisInitialized(_this), "volumeInfo", {});
    _this.clipPlane = new Plane();
    var size = new Vector3(0.5, 0.5, 0.5);
    _this.size = size;
    _this.cullFlag = [true, true, true, true, true, true, true, true, false, false, false, false, false, false];
    _this.faces = [{
      indices: [],
      norm: new Vector3(0, 0, -1)
    }, {
      indices: [],
      norm: new Vector3(0, 0, 1)
    }, {
      indices: [],
      norm: new Vector3(0, -1, 0)
    }, {
      indices: [],
      norm: new Vector3(0, 1, 0)
    }, {
      indices: [],
      norm: new Vector3(-1, 0, 0)
    }, {
      indices: [],
      norm: new Vector3(1, 0, 0)
    }, {
      indices: [],
      norm: new Vector3(0, 0, 0)
    }];
    _this.vertices = [
      new Vector3(-size.x, -size.y, -size.z),
      new Vector3(-size.x, size.y, -size.z),
      new Vector3(size.x, -size.y, -size.z),
      new Vector3(size.x, size.y, -size.z),
      new Vector3(-size.x, -size.y, size.z),
      new Vector3(-size.x, size.y, size.z),
      new Vector3(size.x, -size.y, size.z),
      new Vector3(size.x, size.y, size.z),
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0)
    ];
    geo.setAttribute("position", new BufferAttribute(new Float32Array(_this.vertices.length * 3), 3));
    _this.name = "VolumeMesh";
    return _this;
  }
  _createClass(VolumeMesh2, [{
    key: "_updateVertices",
    value: function _updateVertices() {
      var corners = VolumeMesh2._corners;
      var edges = VolumeMesh2._edges;
      var edgeIntersections = VolumeMesh2._edgeIntersections;
      var i2;
      var norm = this.clipPlane.normal;
      var D2 = this.clipPlane.constant;
      var vert = this.vertices;
      var size = this.size;
      var cornerMark = [0, 0, 0, 0, 0, 0, 0, 0];
      var edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
      var curEdge = new Vector3();
      var curEdgeInter = null;
      function CheckX() {
        if (norm.x === 0) return 0;
        var x2 = -(norm.dot(curEdge) + D2) / norm.x;
        if (-size.x <= x2 && x2 <= size.x) {
          curEdgeInter.set(x2, curEdge.y, curEdge.z);
          if (x2 === size.x) return 2;
          if (x2 === -size.x) return -2;
          return 1;
        }
        return 0;
      }
      function CheckY() {
        if (norm.y === 0) return 0;
        var y2 = -(norm.dot(curEdge) + D2) / norm.y;
        if (-size.y <= y2 && y2 <= size.y) {
          curEdgeInter.set(curEdge.x, y2, curEdge.z);
          if (y2 === size.y) return 2;
          if (y2 === -size.y) return -2;
          return 1;
        }
        return 0;
      }
      function CheckZ() {
        if (norm.z === 0) return 0;
        var z2 = -(norm.dot(curEdge) + D2) / norm.z;
        if (-size.z <= z2 && z2 <= size.z) {
          curEdgeInter.set(curEdge.x, curEdge.y, z2);
          if (z2 === size.z) return 2;
          if (z2 === -size.z) return -2;
          return 1;
        }
        return 0;
      }
      for (var curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
        var curEdgeSource = edges[curEdgeIdx];
        curEdgeInter = edgeIntersections[curEdgeIdx];
        curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4]);
        curEdge.multiply(size);
        var flag = 0;
        if (curEdgeSource[2] === 0) flag = CheckX();
        if (curEdgeSource[3] === 0) flag = CheckY();
        if (curEdgeSource[4] === 0) flag = CheckZ();
        if (flag === -2) {
          cornerMark[curEdgeSource[0]] = 1;
        } else if (flag === 2) {
          cornerMark[curEdgeSource[1]] = 1;
        } else if (flag === 0) {
          edgeMark[curEdgeIdx] = 0;
        }
      }
      var face = {
        indices: [],
        norm: norm.clone().negate()
      };
      var nextVertex = 8;
      for (i2 = 0; i2 < 8; ++i2) {
        if (cornerMark[i2] === 1) {
          vert[nextVertex].set(corners[i2][0], corners[i2][1], corners[i2][2]).multiply(size);
          face.indices.push(nextVertex++);
          edgeMark[corners[i2][3]] = 0;
          edgeMark[corners[i2][4]] = 0;
          edgeMark[corners[i2][5]] = 0;
        }
      }
      for (i2 = 0; i2 < 12; ++i2) {
        if (edgeMark[i2] === 1) {
          vert[nextVertex].copy(edgeIntersections[i2]);
          face.indices.push(nextVertex++);
        }
      }
      this.faces[6] = face;
      var diff = new Vector3();
      var coplanarPoint = new Vector3();
      this.clipPlane.coplanarPoint(coplanarPoint);
      for (i2 = 0; i2 < vert.length; ++i2) {
        this.cullFlag[i2] = false;
        if (i2 < 8) {
          diff.subVectors(vert[i2], coplanarPoint);
          this.cullFlag[i2] = norm.dot(diff) >= 0;
        } else if (i2 < 8 + face.indices.length) {
          this.cullFlag[i2] = true;
        }
      }
      var positions = this.geometry.getAttribute("position");
      var idx = 0;
      for (i2 = 0; i2 < vert.length; ++i2) {
        positions.array[idx++] = vert[i2].x;
        positions.array[idx++] = vert[i2].y;
        positions.array[idx++] = vert[i2].z;
      }
      positions.needsUpdate = true;
    }
  }, {
    key: "_collectVertices",
    value: function _collectVertices(face, filter2) {
      var i2;
      var vert = this.vertices;
      face.indices = [];
      for (i2 = 0; i2 < vert.length; ++i2) {
        if (this.cullFlag[i2] && filter2(vert[i2])) {
          face.indices.push(i2);
        }
      }
    }
  }, {
    key: "_sortIndices",
    value: function _sortIndices(face, right) {
      var i2;
      var j2;
      var vert = this.vertices;
      var angle = [];
      var dir = new Vector3();
      for (i2 = 1; i2 < face.indices.length; ++i2) {
        dir.subVectors(vert[face.indices[i2]], vert[face.indices[0]]);
        dir.normalize();
        dir.cross(right);
        dir.negate();
        angle[i2] = face.norm.dot(dir);
      }
      for (i2 = 1; i2 < face.indices.length - 1; ++i2) {
        for (j2 = i2 + 1; j2 < face.indices.length; ++j2) {
          if (angle[j2] < angle[i2]) {
            var t2 = angle[i2];
            angle[i2] = angle[j2];
            angle[j2] = t2;
            t2 = face.indices[i2];
            face.indices[i2] = face.indices[j2];
            face.indices[j2] = t2;
          }
        }
      }
    }
  }, {
    key: "_updateIndices",
    value: function _updateIndices() {
      var i2;
      var faceIdx;
      var face;
      var vert = this.vertices;
      var size = this.size;
      this._collectVertices(this.faces[0], function(vertex) {
        return vertex.z === -size.z;
      });
      this._collectVertices(this.faces[1], function(vertex) {
        return vertex.z === size.z;
      });
      this._collectVertices(this.faces[2], function(vertex) {
        return vertex.y === -size.y;
      });
      this._collectVertices(this.faces[3], function(vertex) {
        return vertex.y === size.y;
      });
      this._collectVertices(this.faces[4], function(vertex) {
        return vertex.x === -size.x;
      });
      this._collectVertices(this.faces[5], function(vertex) {
        return vertex.x === size.x;
      });
      var vCenter = new Vector3();
      var vRight = new Vector3();
      var vDir = new Vector3();
      for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
        face = this.faces[faceIdx];
        if (face.indices.length === 0) continue;
        vCenter.set(0, 0, 0);
        for (i2 = 0; i2 < face.indices.length; ++i2) {
          vCenter.add(vert[face.indices[i2]]);
        }
        vCenter.multiplyScalar(1 / face.indices.length);
        vRight.subVectors(vert[face.indices[0]], vCenter);
        vRight.normalize();
        var rightProj = [];
        for (i2 = 0; i2 < face.indices.length; ++i2) {
          vDir.subVectors(vert[face.indices[i2]], vCenter);
          rightProj[i2] = vDir.dot(vRight);
        }
        for (i2 = 1; i2 < face.indices.length; ++i2) {
          if (rightProj[i2] < rightProj[0]) {
            var t2 = rightProj[0];
            rightProj[0] = rightProj[i2];
            rightProj[i2] = t2;
            var _face$indices = _slicedToArray(face.indices, 1);
            t2 = _face$indices[0];
            face.indices[0] = face.indices[i2];
            face.indices[i2] = t2;
          }
        }
        this._sortIndices(face, vRight);
      }
      var numIndices = 0;
      for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
        face = this.faces[faceIdx];
        if (face.indices.length >= 3) {
          numIndices += 3 * (face.indices.length - 2);
        }
      }
      var offset = 0;
      var indices = new Uint16Array(numIndices);
      for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
        face = this.faces[faceIdx];
        for (i2 = 0; i2 < face.indices.length - 2; ++i2) {
          indices[offset] = face.indices[0];
          indices[offset + 1] = face.indices[i2 + 1];
          indices[offset + 2] = face.indices[i2 + 2];
          offset += 3;
        }
      }
      this.geometry.setIndex(new BufferAttribute(indices, 1));
    }
  }, {
    key: "setDataSource",
    value: function setDataSource(dataSource) {
      var vm = new VolumeMaterial$1.VolumeMaterial();
      var dim = dataSource.getDimensions();
      var stride = dataSource.getTiledTextureStride();
      var texture = dataSource.buildTiledTexture();
      var bbox = dataSource.getBox();
      vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2]);
      vm.uniforms.tileTex.value = texture;
      vm.uniforms.tileTexSize.value.set(texture.image.width, texture.image.height);
      vm.uniforms.tileStride.value.set(stride[0], stride[1]);
      Object.assign(this.volumeInfo, dataSource.getVolumeInfo());
      var volInfo = this.volumeInfo;
      vm.uniforms.delta.value.copy(volInfo.delta);
      vm.uniforms.boxAngles.value.set(volInfo.obtuseAngle[0], volInfo.obtuseAngle[1], volInfo.obtuseAngle[2]);
      this.material = vm;
      bbox.getSize(this.scale);
      bbox.getCenter(this.position);
    }
  }, {
    key: "_updateIsoLevel",
    value: function _updateIsoLevel() {
      var _settings$now$modes$V = settings$1.now.modes.VD, kSigma = _settings$now$modes$V.kSigma, kSigmaMed = _settings$now$modes$V.kSigmaMed, kSigmaMax = _settings$now$modes$V.kSigmaMax;
      var volInfo = this.volumeInfo;
      var mean = volInfo.dmean - volInfo.dmin;
      var span = volInfo.dmax - volInfo.dmin;
      var level = function level2(k2) {
        return (mean + k2 * volInfo.sd) / span;
      };
      this.material.uniforms._isoLevel0.value.set(level(kSigma), level(kSigmaMed), level(kSigmaMax));
    }
  }, {
    key: "rebuild",
    value: function rebuild(camera) {
      var nearClipPlaneOffset = VolumeMesh2._nearClipPlaneOffset;
      var pos = VolumeMesh2._pos;
      var norm = VolumeMesh2._norm;
      var norm4D = VolumeMesh2._norm4D;
      var matrixWorldToLocal = VolumeMesh2._matrixWorldToLocal;
      var clipPlane = VolumeMesh2._clipPlane;
      this._updateIsoLevel();
      camera.getWorldDirection(norm);
      camera.getWorldPosition(pos);
      pos.addScaledVector(norm, camera.near + nearClipPlaneOffset);
      matrixWorldToLocal.copy(this.matrixWorld).invert();
      pos.applyMatrix4(matrixWorldToLocal);
      norm4D.set(norm.x, norm.y, norm.z, 0);
      norm4D.applyMatrix4(matrixWorldToLocal);
      norm.copy(norm4D);
      norm.normalize();
      clipPlane.setFromNormalAndCoplanarPoint(norm, pos);
      if (!this.clipPlane.equals(clipPlane)) {
        this.clipPlane = clipPlane.clone();
        this._updateVertices();
        this._updateIndices();
      }
    }
  }]);
  return VolumeMesh2;
}(Mesh);
_defineProperty2(VolumeMesh, "_corners", [
  [-1, -1, -1, 0, 4, 8],
  [1, -1, -1, 0, 5, 9],
  [1, 1, -1, 1, 5, 10],
  [-1, 1, -1, 1, 4, 11],
  [-1, -1, 1, 2, 6, 8],
  [1, -1, 1, 2, 7, 9],
  [1, 1, 1, 3, 7, 10],
  [-1, 1, 1, 3, 6, 11]
]);
_defineProperty2(VolumeMesh, "_edges", [
  [0, 1, 0, -1, -1],
  [2, 3, 0, 1, -1],
  [4, 5, 0, -1, 1],
  [6, 7, 0, 1, 1],
  [0, 3, -1, 0, -1],
  [1, 2, 1, 0, -1],
  [4, 7, -1, 0, 1],
  [5, 6, 1, 0, 1],
  [0, 4, -1, -1, 0],
  [1, 5, 1, -1, 0],
  [2, 6, -1, 1, 0],
  [3, 7, 1, 1, 0]
]);
_defineProperty2(VolumeMesh, "_edgeIntersections", function() {
  var edgeIntersections = [];
  for (var j2 = 0; j2 < 12; ++j2) {
    edgeIntersections.push(new Vector3());
  }
  return edgeIntersections;
}());
_defineProperty2(VolumeMesh, "_nearClipPlaneOffset", 0.2);
_defineProperty2(VolumeMesh, "_pos", new Vector3());
_defineProperty2(VolumeMesh, "_norm", new Vector3());
_defineProperty2(VolumeMesh, "_norm4D", new Vector4());
_defineProperty2(VolumeMesh, "_matrixWorldToLocal", new Matrix4());
_defineProperty2(VolumeMesh, "_clipPlane", new Plane());
function _flattenArray(input) {
  var n2 = input.length;
  var output = new Float32Array(n2 * 3);
  for (var i2 = 0; i2 < n2; ++i2) {
    var j2 = 3 * i2;
    var v2 = input[i2];
    output[j2] = v2.x;
    output[j2 + 1] = v2.y;
    output[j2 + 2] = v2.z;
  }
  return output;
}
var VolumeBounds = function() {
  function VolumeBounds2(bBox, volInfo) {
    _classCallCheck(this, VolumeBounds2);
    var delta = volInfo.delta;
    var obtuseAngle = volInfo.obtuseAngle;
    var bSize = new Vector3();
    bBox.getSize(bSize);
    bSize.multiplyScalar(0.5);
    var offsetVert = this._getBaseVertices(delta, obtuseAngle);
    var geometry = new BufferGeometry();
    var vertices = [];
    for (var i2 = 0; i2 < 4; i2++) {
      vertices.push(offsetVert[i2].clone().multiply(bSize));
      vertices.push(offsetVert[(i2 + 1) % 4].clone().multiply(bSize));
    }
    var translation = new Vector3(2 * bSize.x * (1 - delta.x - delta.y), 0, 0);
    for (var _i = 0; _i < 8; _i++) {
      vertices.push(vertices[_i].clone().add(translation));
    }
    for (var _i2 = 0; _i2 < 4; _i2++) {
      vertices.push(vertices[_i2 * 2].clone());
      vertices.push(vertices[_i2 * 2 + 8].clone());
    }
    var center = new Vector3();
    bBox.getCenter(center);
    vertices.forEach(function(vertex) {
      return vertex.add(center);
    });
    var flatVertices = _flattenArray(vertices);
    geometry.setAttribute("position", new BufferAttribute(flatVertices, 3));
    this._lines = new LineSegments(geometry, new LineBasicMaterial({
      color: 16777215
    }));
    this._lines.layers.set(gfxutils.LAYERS.VOLUME);
  }
  _createClass(VolumeBounds2, [{
    key: "_getBaseVertices",
    value: function _getBaseVertices(delta, obtuseAngle) {
      var projTable = VolumeBounds2._projectionTable;
      var proj = function proj2(index, inv) {
        var currDelta = delta[projTable[index][0]];
        var angleValue = -0.5 * (inv - 1) + inv * obtuseAngle[projTable[index][1]];
        return angleValue * currDelta;
      };
      var offsetVert = [new Vector3(-1 + 2 * (proj("XZ", 1) + proj("XY", 1)), -1 + 2 * proj("YZ", 1), -1), new Vector3(-1 + 2 * (proj("XZ", -1) + proj("XY", 1)), -1 + 2 * proj("YZ", -1), 1), new Vector3(-1 + 2 * (proj("XZ", -1) + proj("XY", -1)), 1 - 2 * proj("YZ", 1), 1), new Vector3(-1 + 2 * (proj("XZ", 1) + proj("XY", -1)), 1 - 2 * proj("YZ", -1), -1)];
      return offsetVert;
    }
  }, {
    key: "getMesh",
    value: function getMesh() {
      return this._lines;
    }
  }]);
  return VolumeBounds2;
}();
_defineProperty2(VolumeBounds, "_projectionTable", {
  XY: ["x", 2],
  XZ: ["y", 1],
  YZ: ["z", 0]
});
var VolumeFarPlane = function() {
  function VolumeFarPlane2(volume, width, height) {
    _classCallCheck(this, VolumeFarPlane2);
    var planeGeo = this._initPlaneGeo(width, height);
    var mat = new VolumeMaterial$1.BackFacePosMaterialFarPlane();
    this._plane = new meshes.Mesh(planeGeo, mat);
    this._plane.frustumCulled = false;
    this._plane.doubleSided = true;
    var matWorldToVolume = new Matrix4();
    this._plane._onBeforeRender = function(_renderer, _scene, camera, _geometry2, _material, _group) {
      var material2 = this.material;
      if (!volume || !material2) {
        return;
      }
      var planeCamPos = new Vector4(0, 0, -(camera.far - 0.1), 1);
      planeCamPos.applyMatrix4(camera.matrixWorld);
      this.matrix.identity();
      this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z);
      this.matrixWorld.copy(this.matrix);
      this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);
      var volumeMatrix = volume.matrixWorld;
      matWorldToVolume.copy(volumeMatrix).invert();
      material2.uniforms.aspectRatio.value = camera.aspect;
      material2.uniforms.farZ.value = camera.far;
      material2.uniforms.tanHalfFOV.value = Math.tan(MathUtils.DEG2RAD * 0.5 * camera.fov);
      material2.uniforms.matWorld2Volume.value = matWorldToVolume;
    };
    this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
  }
  _createClass(VolumeFarPlane2, [{
    key: "_initPlaneGeo",
    value: function _initPlaneGeo(width, height) {
      var planeGeo = new BufferGeometry();
      width = width || 1;
      height = height || 1;
      var vertices = new Float32Array([-0.5 * width, 0.5 * height, 0, 0.5 * width, 0.5 * height, 0, -0.5 * width, -0.5 * height, 0, 0.5 * width, -0.5 * height, 0]);
      planeGeo.setAttribute("position", new BufferAttribute(vertices, 3));
      planeGeo.setIndex([0, 2, 1, 2, 3, 1]);
      return planeGeo;
    }
  }, {
    key: "getMesh",
    value: function getMesh() {
      return this._plane;
    }
  }]);
  return VolumeFarPlane2;
}();
function _createSuper$w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$w();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var VolumeVisual = function(_Visual) {
  _inherits(VolumeVisual2, _Visual);
  var _super = _createSuper$w(VolumeVisual2);
  function VolumeVisual2(name2, dataSource) {
    var _this;
    _classCallCheck(this, VolumeVisual2);
    _this = _super.call(this, name2, dataSource);
    _this._mesh = new VolumeMesh();
    _this._mesh.setDataSource(dataSource);
    _this.add(_this._mesh);
    _this._frame = new VolumeBounds(_this.getBoundaries().boundingBox, _this._mesh.volumeInfo);
    _this.add(_this._frame.getMesh());
    _this.showFrame(settings$1.now.modes.VD.frame);
    _this._farPlane = new VolumeFarPlane(_this._mesh, 2, 2);
    _this.add(_this._farPlane.getMesh());
    return _this;
  }
  _createClass(VolumeVisual2, [{
    key: "getBoundaries",
    value: function getBoundaries() {
      var box = this._dataSource.getBox();
      var sphere = new Sphere();
      box.getBoundingSphere(sphere);
      return {
        boundingBox: box,
        boundingSphere: sphere
      };
    }
  }, {
    key: "getMesh",
    value: function getMesh() {
      return this._mesh;
    }
  }, {
    key: "showFrame",
    value: function showFrame(needShow) {
      this._frame.getMesh().material.visible = needShow;
    }
  }]);
  return VolumeVisual2;
}(Visual);
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var LoaderList = function(_EntityList) {
  _inherits(LoaderList2, _EntityList);
  var _super = _createSuper$v(LoaderList2);
  function LoaderList2() {
    var someLoaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, LoaderList2);
    return _super.call(this, someLoaders, ["types"]);
  }
  _createClass(LoaderList2, [{
    key: "find",
    value: function find2(specs) {
      var list = [];
      if (specs.type) {
        list = this._dict.types[specs.type.toLowerCase()] || [];
      } else if (specs.source) {
        return this._list.filter(function(SomeLoader) {
          return SomeLoader.canProbablyLoad && SomeLoader.canProbablyLoad(specs.source);
        });
      }
      return _toConsumableArray(list);
    }
  }]);
  return LoaderList2;
}(EntityList);
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Loader2 = function(_EventDispatcher) {
  _inherits(Loader3, _EventDispatcher);
  var _super = _createSuper$u(Loader3);
  function Loader3(source, options2) {
    var _this;
    _classCallCheck(this, Loader3);
    _this = _super.call(this);
    _this._source = source;
    _this._options = options2 || {};
    _this._abort = false;
    _this._agent = null;
    return _this;
  }
  _createClass(Loader3, [{
    key: "load",
    value: function load() {
      return Promise.reject(new Error("Loading from this source is not implemented"));
    }
  }, {
    key: "abort",
    value: function abort() {
      this._abort = true;
      if (this._agent) {
        this._agent.abort();
      }
    }
  }], [{
    key: "extractName",
    value: function extractName(_source) {
      return void 0;
    }
  }]);
  return Loader3;
}(EventDispatcher2);
makeContextDependent(Loader2.prototype);
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var FileLoader2 = function(_Loader) {
  _inherits(FileLoader3, _Loader);
  var _super = _createSuper$t(FileLoader3);
  function FileLoader3(source, options2) {
    var _this;
    _classCallCheck(this, FileLoader3);
    _this = _super.call(this, source, options2);
    options2 = _this._options;
    _this._binary = options2.binary === true;
    return _this;
  }
  _createClass(FileLoader3, [{
    key: "load",
    value: function load() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        if (_this2._abort) {
          throw new Error("Loading aborted");
        }
        var blob = _this2._source;
        var reader = _this2._agent = new FileReader();
        reader.addEventListener("load", function() {
          resolve(reader.result);
        });
        reader.addEventListener("error", function() {
          reject(reader.error);
        });
        reader.addEventListener("abort", function() {
          reject(new Error("Loading aborted"));
        });
        reader.addEventListener("progress", function(event) {
          _this2.dispatchEvent(event);
        });
        if (_this2._binary) {
          reader.readAsArrayBuffer(blob);
        } else {
          reader.readAsText(blob);
        }
      });
    }
  }], [{
    key: "canProbablyLoad",
    value: function canProbablyLoad(source) {
      return File && source instanceof File || Blob && source instanceof Blob;
    }
  }, {
    key: "extractName",
    value: function extractName(source) {
      return source && source.name;
    }
  }]);
  return FileLoader3;
}(Loader2);
FileLoader2.types = ["file", "blob"];
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var urlStartRegexp = /^(https?|ftp):\/\//i;
var XHRLoader = function(_Loader) {
  _inherits(XHRLoader2, _Loader);
  var _super = _createSuper$s(XHRLoader2);
  function XHRLoader2(source, options2) {
    var _this;
    _classCallCheck(this, XHRLoader2);
    _this = _super.call(this, source, options2);
    options2 = _this._options;
    _this._binary = options2.binary === true;
    return _this;
  }
  _createClass(XHRLoader2, [{
    key: "load",
    value: function load() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        if (_this2._abort) {
          throw new Error("Loading aborted");
        }
        var url = _this2._source;
        var request = _this2._agent = new XMLHttpRequest();
        request.addEventListener("load", function() {
          if (request.status === 200) {
            resolve(request.response);
          } else {
            reject(new Error("HTTP ".concat(request.status, " while fetching ").concat(url)));
          }
        });
        request.addEventListener("error", function() {
          reject(new Error("HTTP request failed"));
        });
        request.addEventListener("abort", function() {
          reject(new Error("Loading aborted"));
        });
        request.addEventListener("progress", function(event) {
          _this2.dispatchEvent(event);
        });
        request.open("GET", url);
        if (_this2._binary) {
          request.responseType = "arraybuffer";
        } else {
          request.responseType = "text";
        }
        request.send();
      });
    }
  }], [{
    key: "canProbablyLoad",
    value: function canProbablyLoad(source) {
      return (0, import_lodash.isString)(source) && urlStartRegexp.test(source);
    }
  }, {
    key: "extractName",
    value: function extractName(source) {
      if (source) {
        var last = (source.indexOf("?") + 1 || source.lastIndexOf("#") + 1 || source.length + 1) - 1;
        return source.slice(source.lastIndexOf("/", last) + 1, last);
      }
      return void 0;
    }
  }]);
  return XHRLoader2;
}(Loader2);
XHRLoader.types = ["url"];
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ImmediateLoader = function(_Loader) {
  _inherits(ImmediateLoader2, _Loader);
  var _super = _createSuper$r(ImmediateLoader2);
  function ImmediateLoader2() {
    _classCallCheck(this, ImmediateLoader2);
    return _super.apply(this, arguments);
  }
  _createClass(ImmediateLoader2, [{
    key: "load",
    value: function load() {
      var _this = this;
      return new Promise(function(resolve) {
        if (_this._abort) {
          throw new Error("Loading aborted");
        }
        resolve(_this._source);
      });
    }
  }], [{
    key: "canProbablyLoad",
    value: function canProbablyLoad(_source) {
      return false;
    }
  }]);
  return ImmediateLoader2;
}(Loader2);
ImmediateLoader.types = ["immediate"];
var loaders = new LoaderList([
  FileLoader2,
  XHRLoader,
  ImmediateLoader
]);
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ParserList = function(_EntityList) {
  _inherits(ParserList2, _EntityList);
  var _super = _createSuper$q(ParserList2);
  function ParserList2() {
    var someParsers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, ParserList2);
    return _super.call(this, someParsers, ["formats", "extensions"]);
  }
  _createClass(ParserList2, [{
    key: "find",
    value: function find2(specs) {
      var list = [];
      if (specs.format) {
        list = this._dict.formats[specs.format.toLowerCase()] || [];
      } else if (specs.ext) {
        list = this._dict.extensions[specs.ext.toLowerCase()] || [];
      }
      if (list.length === 0 && !specs.format && specs.data) {
        return this._list.filter(function(SomeParser) {
          return SomeParser.canProbablyParse && SomeParser.canProbablyParse(specs.data);
        });
      }
      return _toConsumableArray(list);
    }
  }]);
  return ParserList2;
}(EntityList);
var Parser = function() {
  function Parser2(data, options2) {
    _classCallCheck(this, Parser2);
    this._data = data;
    this._options = options2 || {};
    this._abort = false;
  }
  _createClass(Parser2, [{
    key: "parseSync",
    value: function parseSync() {
      throw new Error("Parsing this type of data is not implemented");
    }
  }, {
    key: "parse",
    value: function parse() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        setTimeout(function() {
          try {
            if (_this._abort) {
              return reject(new Error("Parsing aborted"));
            }
            return resolve(_this.parseSync());
          } catch (error) {
            return reject(error);
          }
        });
      });
    }
  }, {
    key: "getModel",
    value: function getModel() {
      this.model._parseHeader(this._data);
      return this.model;
    }
  }, {
    key: "abort",
    value: function abort() {
      this._abort = true;
    }
  }]);
  return Parser2;
}();
makeContextDependent(Parser.prototype);
var Remark290 = function() {
  function Remark2902() {
    _classCallCheck(this, Remark2902);
    this.matrices = [];
    this._matrix = null;
    this._matrixIndex = -1;
  }
  _createClass(Remark2902, [{
    key: "parse",
    value: function parse(stream) {
      var matrix = this._matrix;
      if (stream.readString(12, 18) === "  SMTRY") {
        var matrixRow = stream.readCharCode(19) - 49;
        var matrixData = stream.readString(20, 80).trim().split(/\s+/);
        var matrixIndex = parseInt(matrixData[0], 10);
        if (this._matrix === null || matrixIndex !== this._matrixIndex) {
          this._matrixIndex = matrixIndex;
          this._matrix = matrix = new Matrix4();
          this.matrices[this.matrices.length] = matrix;
        }
        var _matrix2 = matrix, elements = _matrix2.elements;
        elements[matrixRow] = parseFloat(matrixData[1]);
        elements[matrixRow + 4] = parseFloat(matrixData[2]);
        elements[matrixRow + 8] = parseFloat(matrixData[3]);
        elements[matrixRow + 12] = parseFloat(matrixData[4]);
      }
    }
  }]);
  return Remark2902;
}();
Remark290.prototype.id = 290;
var Assembly$2 = chem.Assembly;
var Remark350 = function() {
  function Remark3502(complex) {
    _classCallCheck(this, Remark3502);
    this._complex = complex;
    this.assemblies = [];
    this._assembly = null;
    this._matrix = null;
    this._matrixIndex = -1;
  }
  _createClass(Remark3502, [{
    key: "parse",
    value: function parse(stream) {
      var assembly = this._assembly;
      var matrix = this._matrix;
      if (assembly && stream.readString(12, 18) === "  BIOMT") {
        var matrixRow = stream.readCharCode(19) - 49;
        var matrixData = stream.readString(20, 80).trim().split(/\s+/);
        var matrixIndex = parseInt(matrixData[0], 10);
        if (this._matrix === null || matrixIndex !== this._matrixIndex) {
          this._matrixIndex = matrixIndex;
          this._matrix = matrix = new Matrix4();
          assembly.addMatrix(matrix);
        }
        var _matrix2 = matrix, elements = _matrix2.elements;
        elements[matrixRow] = parseFloat(matrixData[1]);
        elements[matrixRow + 4] = parseFloat(matrixData[2]);
        elements[matrixRow + 8] = parseFloat(matrixData[3]);
        elements[matrixRow + 12] = parseFloat(matrixData[4]);
      } else if (assembly && stream.readString(35, 41) === "CHAINS:") {
        var entries = stream.readString(42, 80).split(",");
        for (var i2 = 0, n2 = entries.length; i2 < n2; ++i2) {
          var chain2 = entries[i2].trim();
          if (chain2.length > 0) {
            assembly.addChain(chain2);
          }
        }
      } else if (stream.readString(12, 23) === "BIOMOLECULE:") {
        this._matrix = null;
        this._matrixIndex = -1;
        this._assembly = assembly = new Assembly$2(this._complex);
        this.assemblies.push(assembly);
      }
    }
  }]);
  return Remark3502;
}();
Remark350.prototype.id = 350;
var PDBStream = function() {
  function PDBStream2(data) {
    _classCallCheck(this, PDBStream2);
    this._data = data;
    this._start = 0;
    this._nextCR = -1;
    this._nextLF = -1;
    this._next = -1;
    this._end = data.length;
    this.next();
  }
  _createClass(PDBStream2, [{
    key: "readLine",
    value: function readLine() {
      return this._data.slice(this._start, this._next);
    }
  }, {
    key: "readChar",
    value: function readChar(pos) {
      pos = this._start + pos - 1;
      return pos < this._next ? this._data[pos] : " ";
    }
  }, {
    key: "readCharCode",
    value: function readCharCode(pos) {
      pos = this._start + pos - 1;
      return pos < this._next ? this._data.charCodeAt(pos) : 32;
    }
  }, {
    key: "readString",
    value: function readString(begin, end) {
      var from = this._start + begin - 1;
      var to = this._start + end;
      return this._data.slice(from, to < this._next ? to : this._next);
    }
  }, {
    key: "readInt",
    value: function readInt(begin, end) {
      return parseInt(this.readString(begin, end), 10);
    }
  }, {
    key: "readFloat",
    value: function readFloat(begin, end) {
      return parseFloat(this.readString(begin, end));
    }
  }, {
    key: "end",
    value: function end() {
      return this._start >= this._end;
    }
  }, {
    key: "next",
    value: function next() {
      var start = this._next + 1;
      this._start = start < this._end ? start : this._end;
      if (this._start > this._nextCR) {
        this._nextCR = (this._data.indexOf("\r", this._start) + 1 || this._end + 1) - 1;
      }
      if (this._start > this._nextLF) {
        this._nextLF = (this._data.indexOf("\n", this._start) + 1 || this._end + 1) - 1;
      }
      this._next = this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF;
    }
  }]);
  return PDBStream2;
}();
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$8 = chem.Complex;
var Element$8 = chem.Element;
var Helix$2 = chem.Helix;
var Sheet$2 = chem.Sheet;
var Strand$2 = chem.Strand;
var Bond$4 = chem.Bond;
var Molecule$7 = chem.Molecule;
var TAG_LENGTH = 6;
function nameToElement$1(name2) {
  var veryLong = name2.trim().length === 4;
  return name2.slice(0, veryLong ? 1 : 2).trim();
}
var pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i;
var remarkParsers = {
  290: Remark290,
  350: Remark350
};
var PDBParser = function(_Parser) {
  _inherits(PDBParser2, _Parser);
  var _super = _createSuper$p(PDBParser2);
  function PDBParser2(data, options2) {
    var _this;
    _classCallCheck(this, PDBParser2);
    _this = _super.call(this, data, options2);
    _this._complex = null;
    _this._chain = null;
    _this._residue = null;
    _this._sheet = null;
    _this._serialAtomMap = null;
    _this._modelId = 1;
    _this._compaundFound = false;
    _this._biomoleculeFound = false;
    _this._allowedChainsIDs = null;
    _this._lastMolId = -1;
    _this._remarks = {};
    _this._remark = null;
    _this._molecules = [];
    _this._molecule = null;
    _this._compndCurrToken = "";
    _this._options.fileType = "pdb";
    return _this;
  }
  _createClass(PDBParser2, [{
    key: "_finalize",
    value: function _finalize() {
      this._fixBondsArray();
      this._fixChains();
      var remark290 = this._remarks[290];
      this._complex.symmetry = (0, import_lodash.isUndefined)(remark290) ? [] : remark290.matrices;
      var remark350 = this._remarks[350];
      this._complex.units = this._complex.units.concat((0, import_lodash.isUndefined)(remark350) ? [] : remark350.assemblies);
      this._finalizeMolecules();
      this._complex.finalize({
        needAutoBonding: true,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing,
        serialAtomMap: this._serialAtomMap
      });
    }
  }, {
    key: "_finalizeMolecules",
    value: function _finalizeMolecules() {
      var chainDict = {};
      var i2;
      var chains = this._complex._chains;
      for (i2 = 0; i2 < chains.length; ++i2) {
        var chainObj = chains[i2];
        var chainName = chainObj._name;
        chainDict[chainName] = chainObj;
      }
      for (i2 = 0; i2 < this._molecules.length; i2++) {
        var m2 = this._molecules[i2];
        var residues = [];
        for (var j2 = 0; j2 < m2._chains.length; j2++) {
          var name2 = m2._chains[j2];
          var chain2 = chainDict[name2];
          residues = residues.concat(chain2._residues.slice());
        }
        var molecule = new Molecule$7(this._complex, m2._name, i2 + 1);
        molecule.residues = residues;
        this._complex._molecules[i2] = molecule;
      }
    }
  }, {
    key: "_fixChains",
    value: function _fixChains() {
      var idChainMap = {};
      var complex = this._complex;
      for (var i2 = 0; i2 < complex._chains.length; i2++) {
        var chain2 = complex._chains[i2];
        idChainMap[chain2._name.charCodeAt(0)] = chain2;
      }
    }
  }, {
    key: "_fixBondsArray",
    value: function _fixBondsArray() {
      var serialAtomMap = this._serialAtomMap = {};
      var complex = this._complex;
      var atoms = complex._atoms;
      for (var i2 = 0, ni = atoms.length; i2 < ni; ++i2) {
        var atom = atoms[i2];
        serialAtomMap[atom.serial] = atom;
      }
      var bonds = complex._bonds;
      var logger2 = this.logger;
      for (var j2 = 0, nj = bonds.length; j2 < nj; ++j2) {
        var bond = bonds[j2];
        if (bond._right < bond._left) {
          logger2.debug("_fixBondsArray: Logic error.");
        }
        bond._left = serialAtomMap[bond._left] || null;
        bond._right = serialAtomMap[bond._right] || null;
      }
    }
  }, {
    key: "_parseATOM",
    value: function _parseATOM(stream) {
      if (this._modelId !== 1) {
        return;
      }
      var het = stream.readCharCode(1) === 72;
      var serial2 = het ? stream.readInt(7, 11) : stream.readInt(6, 11);
      var name2 = stream.readString(13, 16);
      var altLoc = stream.readChar(17);
      var resName = stream.readString(18, 20).trim();
      var chainID = stream.readChar(22);
      var resSeq = stream.readInt(23, 26);
      var iCode = stream.readChar(27);
      var x2 = stream.readFloat(31, 38);
      var y2 = stream.readFloat(39, 46);
      var z2 = stream.readFloat(47, 54);
      var occupancy = stream.readFloat(55, 60);
      var tempFactor = stream.readFloat(61, 66);
      var element = stream.readString(77, 78).trim() || nameToElement$1(name2);
      var charge = stream.readInt(79, 80) || 0;
      if (this.settings.now.nowater) {
        if (resName === "HOH" || resName === "WAT") {
          return;
        }
      }
      name2 = name2.trim();
      var type = Element$8.getByName(element);
      var role = Element$8.Role[name2];
      var chain2 = this._chain;
      if (!chain2 || chain2.getName() !== chainID) {
        this._chain = chain2 = this._complex.getChain(chainID) || this._complex.addChain(chainID);
        this._residue = null;
      }
      var residue2 = this._residue;
      if (!residue2 || residue2.getSequence() !== resSeq || residue2.getICode() !== iCode) {
        this._residue = residue2 = chain2.addResidue(resName, resSeq, iCode);
      }
      var xyz = new Vector3(x2, y2, z2);
      residue2.addAtom(name2, type, xyz, role, het, serial2, altLoc, occupancy, tempFactor, charge);
    }
  }, {
    key: "_parseENDMDL",
    value: function _parseENDMDL() {
      this._modelId += 1;
    }
  }, {
    key: "_parseCONECT",
    value: function _parseCONECT(stream) {
      var serial0 = stream.readInt(7, 11);
      var serial1 = stream.readInt(12, 16);
      var serial2 = stream.readInt(17, 21);
      var serial3 = stream.readInt(22, 26);
      var serial4 = stream.readInt(27, 31);
      var complex = this._complex;
      if (serial1 && serial1 > serial0) {
        complex.addBond(serial0, serial1, 0, Bond$4.BondType.UNKNOWN, true);
      }
      if (serial2 && serial2 > serial0) {
        complex.addBond(serial0, serial2, 0, Bond$4.BondType.UNKNOWN, true);
      }
      if (serial3 && serial3 > serial0) {
        complex.addBond(serial0, serial3, 0, Bond$4.BondType.UNKNOWN, true);
      }
      if (serial4 && serial4 > serial0) {
        complex.addBond(serial0, serial4, 0, Bond$4.BondType.UNKNOWN, true);
      }
    }
  }, {
    key: "_parseCOMPND",
    value: function _parseCOMPND(stream) {
      var str = stream.readString(11, 80);
      var tokenIdx = str.indexOf(":");
      this._compndCurrToken = tokenIdx > 0 ? str.substring(0, tokenIdx).trim() : this._compndCurrToken;
      if (this._compndCurrToken === "MOL_ID") {
        this._molecule = {
          _index: "",
          _chains: []
        };
        this._molecule._index = parseInt(str.substring(tokenIdx + 1, str.indexOf(";")), 10);
        this._molecules.push(this._molecule);
      } else if (this._compndCurrToken === "MOLECULE" && this._molecule != null) {
        this._molecule._name = str.substring(tokenIdx + 1, str.indexOf(";")).trim();
      } else if (this._compndCurrToken === "CHAIN" && this._molecule != null) {
        var chainStr = str.substring(tokenIdx + 1, 80).trim();
        var lastChar = chainStr[chainStr.length - 1];
        if (lastChar === ";" || lastChar === ",") {
          chainStr = chainStr.slice(0, -1);
        }
        chainStr = chainStr.replace(/\s+/g, "");
        var chains = chainStr.split(",");
        this._molecule._chains = this._molecule._chains.concat(chains);
      }
    }
  }, {
    key: "_parseREMARK",
    value: function _parseREMARK(stream) {
      var remarkNum = stream.readInt(8, 10);
      var remark = this._remarks[remarkNum];
      if ((0, import_lodash.isUndefined)(remark)) {
        var RemarkParser = remarkParsers[remarkNum];
        if (typeof RemarkParser === "function") {
          this._remarks[remarkNum] = remark = new RemarkParser(this._complex);
        }
      }
      if (!(0, import_lodash.isUndefined)(remark)) {
        remark.parse(stream);
      }
    }
  }, {
    key: "_parseHELIX",
    value: function _parseHELIX(stream) {
      var _this2 = this;
      var fields = [20, 22, 32, 34];
      this._parseSTRUCTURE(stream, fields, function(obj) {
        _this2._complex.addHelix(obj);
        _this2._complex.structures.push(obj);
      });
    }
  }, {
    key: "_parseSHEET",
    value: function _parseSHEET(stream) {
      var _this3 = this;
      var fields = [22, 23, 33, 34];
      this._parseSTRUCTURE(stream, fields, function(obj) {
        _this3._complex.addSheet(obj);
      });
    }
  }, {
    key: "_parseSTRUCTURE",
    value: function _parseSTRUCTURE(stream, pars, adder) {
      var startId = 0;
      var startIndex = 1;
      var endId = 2;
      var endIndex = 3;
      var codeOfS = 83;
      var serialNumber = stream.readInt(8, 10);
      var structureName = stream.readString(12, 14).trim();
      var comment = stream.readString(41, 70).trim();
      var helLength = stream.readInt(72, 76);
      var helixClass = stream.readInt(39, 40);
      var shWidth = stream.readInt(15, 16);
      var shCur = stream.readInt(42, 45);
      var shPrev = stream.readInt(57, 60);
      var startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0);
      var endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
      var startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
      var iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
      var startICode = 0;
      if (iCodeStr.length > 0) {
        startICode = iCodeStr.charCodeAt(0);
      }
      var endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
      iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
      var endICode = 0;
      if (iCodeStr.length > 0) {
        endICode = iCodeStr.charCodeAt(0);
      }
      var obj;
      var cs = this._sheet;
      if (stream.readCharCode(1) === codeOfS) {
        if (cs !== null && cs.getName() !== structureName) {
          cs = null;
          this._sheet = null;
        }
        if (cs === null) {
          this._sheet = obj = new Sheet$2(structureName, shWidth);
          adder(obj);
        } else {
          obj = cs;
        }
        var strand = new Strand$2(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helixClass, shCur, shPrev);
        obj.addStrand(strand);
        this._complex.structures.push(strand);
      } else {
        obj = new Helix$2(helixClass, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), serialNumber, structureName, comment, helLength);
        adder(obj);
      }
    }
  }, {
    key: "_parseHEADER",
    value: function _parseHEADER(stream) {
      var metadata = this._complex.metadata;
      metadata.classification = stream.readString(11, 50).trim();
      metadata.date = stream.readString(51, 59).trim();
      var id = stream.readString(63, 66).trim();
      metadata.id = id;
      if (id) {
        this._complex.name = id;
      }
      metadata.format = "pdb";
    }
  }, {
    key: "_parseTITLE",
    value: function _parseTITLE(stream) {
      var metadata = this._complex.metadata;
      metadata.title = metadata.title || [];
      var line = stream.readInt(9, 10) || 1;
      metadata.title[line - 1] = stream.readString(11, 80).trim();
    }
  }, {
    key: "parseSync",
    value: function parseSync() {
      var stream = new PDBStream(this._data);
      var result = this._complex = new Complex$8();
      while (!stream.end()) {
        var tag = stream.readString(1, TAG_LENGTH);
        var func3 = PDBParser2.tagParsers[tag];
        if (typeof func3 === "function") {
          func3.call(this, stream);
        }
        stream.next();
      }
      this._finalize();
      this._serialAtomMap = null;
      this._sheet = null;
      this._residue = null;
      this._chain = null;
      this._complex = null;
      if (result.getAtomCount() === 0) {
        throw new Error("The data does not contain valid atoms");
      }
      return result;
    }
  }], [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isString)(data) && pdbStartRegexp.test(data);
    }
  }]);
  return PDBParser2;
}(Parser);
_defineProperty2(PDBParser, "tagParsers", {
  HEADER: PDBParser.prototype._parseHEADER,
  "TITLE ": PDBParser.prototype._parseTITLE,
  "ATOM  ": PDBParser.prototype._parseATOM,
  HETATM: PDBParser.prototype._parseATOM,
  ENDMDL: PDBParser.prototype._parseENDMDL,
  CONECT: PDBParser.prototype._parseCONECT,
  COMPND: PDBParser.prototype._parseCOMPND,
  REMARK: PDBParser.prototype._parseREMARK,
  "HELIX ": PDBParser.prototype._parseHELIX,
  "SHEET ": PDBParser.prototype._parseSHEET,
  "ATOM 1": PDBParser.prototype._parseATOM,
  "ATOM 2": PDBParser.prototype._parseATOM,
  "ATOM 3": PDBParser.prototype._parseATOM,
  "ATOM 4": PDBParser.prototype._parseATOM,
  "ATOM 5": PDBParser.prototype._parseATOM,
  "ATOM 6": PDBParser.prototype._parseATOM,
  "ATOM 7": PDBParser.prototype._parseATOM,
  "ATOM 8": PDBParser.prototype._parseATOM,
  "ATOM 9": PDBParser.prototype._parseATOM
});
PDBParser.formats = ["pdb"];
PDBParser.extensions = [".pdb", ".ent"];
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$7 = chem.Complex;
var Element$7 = chem.Element;
var SGroup = chem.SGroup;
var Bond$3 = chem.Bond;
var cOrderCharCodes = {
  A: 0,
  S: 1,
  D: 2,
  T: 3
};
var cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;
var CMLParser = function(_Parser) {
  _inherits(CMLParser2, _Parser);
  var _super = _createSuper$o(CMLParser2);
  function CMLParser2(data, options2) {
    var _this;
    _classCallCheck(this, CMLParser2);
    _this = _super.call(this, data, options2);
    _this._complex = null;
    _this._residue = null;
    _this._serialAtomMap = null;
    _this._modelId = 1;
    _this._lastMolId = -1;
    _this._readOnlyOneMolecule = false;
    _this._options.fileType = "cml";
    return _this;
  }
  _createClass(CMLParser2, [{
    key: "_rebuidBondIndexes",
    value: function _rebuidBondIndexes(atoms, bonds) {
      var count = atoms.length;
      for (var i2 = 0; i2 < count; i2++) {
        var atomId = atoms[i2].id;
        var countBonds = bonds.length;
        for (var j2 = 0; j2 < countBonds; j2++) {
          var idxs = bonds[j2].atomRefs2.split(" ");
          if (idxs[0] === atomId) {
            bonds[j2].start = i2;
          }
          if (idxs[1] === atomId) {
            bonds[j2].end = i2;
          }
        }
      }
    }
  }, {
    key: "_createSGroup",
    value: function _createSGroup(molecule, moleculeArr) {
      var newGroup = new SGroup(molecule.id, molecule.fieldData, new Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);
      if (molecule.placement === "Relative") {
        newGroup._center = new Vector3(0, 0, 0);
      }
      if (molecule.fieldName === "MDLBG_FRAGMENT_CHARGE") {
        newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
      }
      if (molecule.fieldName === "MDLBG_FRAGMENT_COEFFICIENT") {
        newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
      }
      moleculeArr.push(newGroup);
    }
  }, {
    key: "_extractSGroup",
    value: function _extractSGroup(molecule, moleculeArr) {
      if (!Array.isArray(moleculeArr)) {
        moleculeArr = [];
      }
      if (molecule) {
        if (Array.isArray(molecule)) {
          var count = molecule.length;
          for (var i2 = 0; i2 < count; i2++) {
            if (molecule[i2].molecule) {
              moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i2].molecule));
            }
            this._createSGroup(molecule[i2], moleculeArr);
          }
        } else {
          if (molecule.molecule) {
            if (molecule.molecule) {
              moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
            }
          }
          this._createSGroup(molecule, moleculeArr);
        }
      }
      return moleculeArr;
    }
  }, {
    key: "_extractSGroups",
    value: function _extractSGroups(molecule, atoms) {
      var moleculeArr = this._extractSGroup(molecule);
      var count = atoms.length;
      var i2;
      var j2;
      for (i2 = 0; i2 < count; i2++) {
        var atomId = atoms[i2].id;
        for (j2 = 0; j2 < moleculeArr.length; j2++) {
          var firstAtomRef = moleculeArr[j2]._atoms.split(" ")[0];
          if (firstAtomRef === atomId) {
            if (!atoms[i2].sgroupRef) {
              atoms[i2].sgroupRef = [];
            }
            atoms[i2].sgroupRef.push(moleculeArr[j2]);
          }
        }
      }
      var atomMap = {};
      var mapEntry = null;
      var nLimon = 1e8;
      var bLow = new Vector3(nLimon, nLimon, nLimon);
      var bHight = new Vector3(-nLimon, -nLimon, -nLimon);
      function cycleFuncInner(e2) {
        mapEntry = atomMap[e2];
        if (mapEntry) {
          moleculeArr[j2]._atoms.push(mapEntry.a);
        }
      }
      function cycleFunc(e2) {
        mapEntry = atomMap[e2];
        if (mapEntry) {
          bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
          bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
          cycleFuncInner(e2);
        }
      }
      for (i2 = 0; i2 < atoms.length; i2++) {
        atomMap[atoms[i2].id] = {};
        atomMap[atoms[i2].id].x = atoms[i2].x2;
        if (atoms[i2].x3) {
          atomMap[atoms[i2].id].x = atoms[i2].x3;
        }
        atomMap[atoms[i2].id].x = parseFloat(atomMap[atoms[i2].id].x);
        atomMap[atoms[i2].id].y = atoms[i2].y2;
        if (atoms[i2].y3) {
          atomMap[atoms[i2].id].y = atoms[i2].y3;
        }
        atomMap[atoms[i2].id].y = parseFloat(atomMap[atoms[i2].id].y);
        atomMap[atoms[i2].id].z = "0.0";
        if (atoms[i2].z3) {
          atomMap[atoms[i2].id].z = atoms[i2].z3;
        }
        atomMap[atoms[i2].id].z = parseFloat(atomMap[atoms[i2].id].z);
        atomMap[atoms[i2].id].a = atoms[i2];
      }
      var atomsRef;
      for (j2 = 0; j2 < moleculeArr.length; j2++) {
        if (moleculeArr[j2]._center !== null) {
          bLow.set(nLimon, nLimon, nLimon);
          bHight.set(-nLimon, -nLimon, -nLimon);
          atomsRef = moleculeArr[j2]._atoms.split(" ");
          moleculeArr[j2]._atoms = [];
          atomsRef.forEach(cycleFunc);
          moleculeArr[j2]._center.addVectors(bLow, bHight);
          moleculeArr[j2]._center.multiplyScalar(0.5);
        } else {
          atomsRef = moleculeArr[j2]._atoms.split(" ");
          moleculeArr[j2]._atoms = [];
          atomsRef.forEach(cycleFuncInner);
        }
      }
      atomMap = null;
    }
  }, {
    key: "_traverseData",
    value: function _traverseData(dom) {
      function isArray2(o2) {
        return Object.prototype.toString.apply(o2) === "[object Array]";
      }
      function parseNode(xmlNode, result2) {
        if (xmlNode.nodeName === "#text" && xmlNode.nodeValue.trim() === "") {
          return;
        }
        var jsonNode = {};
        jsonNode.xmlNode = xmlNode;
        var existing = result2[xmlNode.nodeName];
        if (existing) {
          if (!isArray2(existing)) {
            result2[xmlNode.nodeName] = [existing, jsonNode];
          } else {
            result2[xmlNode.nodeName].push(jsonNode);
          }
        } else {
          result2[xmlNode.nodeName] = jsonNode;
        }
        var length;
        var i2;
        if (xmlNode.attributes) {
          length = xmlNode.attributes.length;
          for (i2 = 0; i2 < length; i2++) {
            var attribute = xmlNode.attributes[i2];
            jsonNode[attribute.nodeName] = attribute.nodeValue;
          }
        }
        length = xmlNode.childNodes.length;
        for (i2 = 0; i2 < length; i2++) {
          parseNode(xmlNode.childNodes[i2], jsonNode);
        }
      }
      var result = {};
      if (dom.childNodes.length) {
        parseNode(dom.childNodes[0], result);
      }
      return result;
    }
  }, {
    key: "_findSuitableMolecule",
    value: function _findSuitableMolecule(data, molSet) {
      for (var key in data) {
        if (key === "xmlNode") {
          continue;
        } else if (key === "molecule") {
          if (data.molecule) {
            if (data.molecule.atomArray && data.molecule.atomArray.atom) {
              molSet.push(data);
            }
            if (Array.isArray(data.molecule)) {
              for (var i2 = 0; i2 < data.molecule.length; i2++) {
                if (data.molecule[i2].atomArray && data.molecule[i2].atomArray.atom) {
                  molSet.push({
                    molecule: data.molecule[i2]
                  });
                }
              }
            }
          }
        } else if (data[key] && data[key] !== null && _typeof(data[key]) === "object") {
          this._findSuitableMolecule(data[key], molSet);
        }
      }
    }
  }, {
    key: "_selectComponents",
    value: function _selectComponents(text) {
      var parser2 = new DOMParser();
      var doc = parser2.parseFromString(text, "application/xml");
      var traversedData = this._traverseData(doc);
      var rawData;
      var self2 = this;
      function prepareComponentCompound(data) {
        var atoms = [];
        if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
          if (!Array.isArray(data.molecule.atomArray.atom)) {
            atoms.push(data.molecule.atomArray.atom);
          } else {
            atoms = data.molecule.atomArray.atom;
          }
        } else if (!data.molecule) {
          var ret = {};
          ret.atomLabels = null;
          ret.labelsCount = 1;
          return ret;
        }
        if (data.molecule.molecule) {
          self2._extractSGroups(data.molecule.molecule, atoms);
        }
        var atom;
        var count = atoms.length;
        for (var i2 = 0; i2 < count; i2++) {
          atom = atoms[i2];
          atom.edges = [];
        }
        var localBond = [];
        if (data.molecule.bondArray && data.molecule.bondArray.bond) {
          if (!Array.isArray(data.molecule.bondArray.bond)) {
            localBond.push(data.molecule.bondArray.bond);
          } else {
            localBond = data.molecule.bondArray.bond;
          }
        }
        var bond;
        count = localBond.length;
        self2._rebuidBondIndexes(atoms, localBond);
        function addCurrBond(index) {
          bond = localBond[index];
          atom = atoms[bond.start];
          if (!atom) {
            return false;
          }
          atom.edges.push(bond.end);
          atom = atoms[bond.end];
          if (!atom) {
            return false;
          }
          atom.edges.push(bond.start);
          return true;
        }
        for (var _i = 0; _i < count; _i++) {
          if (!addCurrBond(_i)) {
            continue;
          }
          var orderAttr = bond.xmlNode.getAttribute("order");
          var tc = parseInt(orderAttr, 10);
          localBond[_i].order = 0;
          localBond[_i].type = Bond$3.BondType.UNKNOWN;
          if (tc > 1) {
            localBond[_i].order = tc;
          } else {
            var order = cOrderCharCodes[orderAttr];
            if (order !== void 0) {
              localBond[_i].order = order;
              if (orderAttr === "A") {
                localBond[_i].type = Bond$3.BondType.AROMATIC;
              }
            }
          }
        }
        count = atoms.length;
        for (var _i2 = 0; _i2 < count; _i2++) {
          atom = atoms[_i2];
          atom.edges.sort();
        }
        var labels = self2._breadWidthSearch(atoms, 0);
        var retStruct = {};
        retStruct.atoms = atoms;
        retStruct.bonds = localBond;
        retStruct.labels = labels.atomLabels;
        retStruct.count = Math.min(1, labels.labelsCount);
        retStruct.curr = -1;
        retStruct.originalCML = doc;
        return retStruct;
      }
      if (traversedData.cml) {
        rawData = traversedData.cml;
      } else {
        rawData = traversedData;
      }
      var retData = [];
      var filteredData = [];
      this._findSuitableMolecule(rawData, filteredData);
      if (this._readOnlyOneMolecule && filteredData.length > 1) {
        filteredData.splice(1, filteredData.length - 1);
      }
      filteredData.forEach(function(d2) {
        var rd = prepareComponentCompound(d2);
        if (rd.atoms.length > 0) {
          retData.push(rd);
        }
      });
      return retData;
    }
  }, {
    key: "_packLabel",
    value: function _packLabel(compId, molId) {
      var shift = 16;
      return (molId << shift) + compId;
    }
  }, {
    key: "_unpackLabel",
    value: function _unpackLabel(l2) {
      var shift = 16;
      var mask = (1 << shift) - 1;
      return {
        molId: l2 >>> shift,
        compId: l2 & mask
      };
    }
  }, {
    key: "_breadWidthSearch",
    value: function _breadWidthSearch(atoms, molID) {
      var atomLabels = new Array(atoms.length);
      var id;
      for (id = 0; id < atomLabels.length; id++) {
        atomLabels[id] = this._packLabel(0, molID);
      }
      var breadthQueue = [];
      var componentID = 0;
      var labeledAtoms = atoms.length;
      while (labeledAtoms > 0) {
        componentID++;
        var startID = -1;
        for (id = 0; id < atomLabels.length; id++) {
          if (this._unpackLabel(atomLabels[id]).compId === 0) {
            startID = id;
            break;
          }
        }
        if (startID < 0) {
          break;
        }
        breadthQueue.push(atoms[startID]);
        atomLabels[startID] = this._packLabel(componentID, molID);
        labeledAtoms--;
        while (breadthQueue.length > 0) {
          var curr = breadthQueue.shift();
          if (!curr) {
            continue;
          }
          for (var i2 = 0; i2 < curr.edges.length; i2++) {
            if (atomLabels[curr.edges[i2]] !== componentID) {
              breadthQueue.push(atoms[curr.edges[i2]]);
              atomLabels[curr.edges[i2]] = componentID;
              labeledAtoms--;
            }
          }
        }
      }
      var ret = {};
      ret.atomLabels = atomLabels;
      ret.labelsCount = componentID;
      return ret;
    }
  }, {
    key: "_parseBond",
    value: function _parseBond(eAtom, mainAtom, order, type) {
      if (eAtom >= 0) {
        var h2 = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)];
        this._complex.addBond(h2[0], h2[1], order, type, true);
      }
    }
  }, {
    key: "_fixBondsArray",
    value: function _fixBondsArray() {
      var serialAtomMap = this._serialAtomMap = {};
      var complex = this._complex;
      var atoms = complex._atoms;
      for (var i2 = 0, ni = atoms.length; i2 < ni; ++i2) {
        var atom = atoms[i2];
        serialAtomMap[atom.serial] = atom;
      }
      var bonds = complex._bonds;
      var logger2 = this.logger;
      for (var j2 = 0, nj = bonds.length; j2 < nj; ++j2) {
        var bond = bonds[j2];
        if (bond._right < bond._left) {
          logger2.debug("_fixBondsArray: Logic error.");
        }
        bond._left = serialAtomMap[bond._left] || null;
        bond._right = serialAtomMap[bond._right] || null;
      }
    }
  }, {
    key: "_parseSet",
    value: function _parseSet(varData) {
      var complex = this._complex = new Complex$7();
      var data = varData;
      var currentLabel = data.curr;
      var atoms = data.atoms, labels = data.labels;
      var atom = null;
      var i2;
      var j2;
      var count = atoms.length;
      function addFunc(a2) {
        a2.xmlNodeRef = atom;
        if (atom.x2) {
          atom.x3 = atom.x2;
          delete atom.x2;
        }
        if (atom.y2) {
          atom.y3 = atom.y2;
          delete atom.y2;
        }
        if (!atom.z3) {
          atom.z3 = "0.0";
        }
        atom.complexAtom = a2;
      }
      var chains = {};
      var reorder = [];
      for (i2 = 0; i2 < count; i2++) {
        reorder.push(i2);
      }
      reorder.sort(function(a2, b2) {
        return labels[a2] - labels[b2];
      });
      for (i2 = 0; i2 < count; i2++) {
        var atomCharge = 0;
        var lLabel = labels[reorder[i2]];
        if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {
          atom = atoms[reorder[i2]];
          var atomFullNameStruct = atom.elementType;
          if (atom.sgroupRef) {
            var countRef = atom.sgroupRef.length;
            for (var k2 = 0; k2 < countRef; ++k2) {
              complex._sgroups.push(atom.sgroupRef[k2]);
            }
          }
          if (atom.x3 || atom.x2) {
            var currAtomComp = this._unpackLabel(lLabel).compId;
            var chainID = " ";
            var resSeq = currAtomComp;
            var iCode = " ";
            var strLabel = currAtomComp.toString();
            if (strLabel.length === 1) {
              strLabel = "0".concat(strLabel);
            }
            var resName = "N".concat(strLabel);
            var chain2 = chains[chainID];
            if (!chain2 || chain2.getName() !== chainID) {
              chains[chainID] = chain2 = this._complex.getChain(chainID) || this._complex.addChain(chainID);
              this._residue = null;
            }
            var residue2 = this._residue;
            if (!residue2 || residue2.getSequence() !== resSeq || residue2.getICode() !== iCode) {
              this._residue = residue2 = chain2.addResidue(resName, resSeq, iCode);
            }
            var xyz = null;
            if (atom.x3) {
              xyz = new Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
            } else if (atom.x2) {
              xyz = new Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
            }
            var element = Element$7.ByName[atom.elementType.toUpperCase()];
            if (!element) {
              element = JSON.parse(JSON.stringify(Element$7.ByName[Object.keys(Element$7.ByName)[Object.keys(Element$7.ByName).length - 1]]));
              element.number += 1;
              element.name = atom.elementType.toUpperCase();
              element.fullName = "Unknown";
              Element$7.ByName[atom.elementType.toUpperCase()] = element;
            }
            var atomSerial = parseInt(atom.id.replace(/[^0-9]/, ""), 10);
            var added = residue2.addAtom(atomFullNameStruct, element, xyz, Element$7.Role.SG, true, atomSerial, " ", 1, 0, atomCharge);
            if (atom.hydrogenCount) {
              added.hydrogenCount = parseInt(atom.hydrogenCount, 10);
            }
            if (atom.mrvValence) {
              added.valence = parseInt(atom.mrvValence, 10);
            }
            addFunc(added);
          }
        }
      }
      chains = null;
      for (i2 = 0; i2 < data.bonds.length; i2++) {
        var cb = data.bonds[i2];
        if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
          atom = atoms[cb.start];
          if (!atom || !atoms[cb.end]) {
            continue;
          }
          this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ""), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ""), 10), cb.order, cb.type);
        }
      }
      for (i2 = 0; i2 < this._complex.getSGroupCount(); i2++) {
        var sGrp = this._complex.getSGroups()[i2];
        for (j2 = 0; j2 < sGrp._atoms.length; j2++) {
          sGrp._atoms[j2] = sGrp._atoms[j2].complexAtom;
        }
      }
      for (i2 = 0; i2 < count; i2++) {
        if (this._unpackLabel(labels[i2]).molId === this._unpackLabel(currentLabel).molId) {
          atom = atoms[i2];
          atom.complexAtom = null;
          delete atom.complexAtom;
        }
      }
      this._complex.originalCML = data.originalCML;
      this._fixBondsArray();
      complex.finalize({
        needAutoBonding: false,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing,
        serialAtomMap: this._serialAtomMap
      });
      this._serialAtomMap = null;
      this._complex = null;
      return complex;
    }
  }, {
    key: "parseSync",
    value: function parseSync() {
      var complexes = [];
      var self2 = this;
      var moleculaSet = this._selectComponents(this._data);
      moleculaSet.forEach(function(molSet) {
        molSet.curr = 2;
        if (molSet.count === 0) {
          molSet.count = 1;
        }
        for (var i2 = 0; i2 < molSet.count; i2++) {
          molSet.curr = i2 + 1;
          complexes.push(self2._parseSet(molSet, false));
        }
      });
      var totalAtomsParsed = 0;
      complexes.forEach(function(c2) {
        totalAtomsParsed += c2.getAtomCount();
      });
      if (totalAtomsParsed <= 0) {
        throw new Error("The data does not contain valid atoms");
      }
      if (complexes.length > 1) {
        var joinedComplex = new Complex$7();
        joinedComplex.joinComplexes(complexes);
        joinedComplex.originalCML = complexes[0].originalCML;
        return joinedComplex;
      }
      if (complexes.length === 1) {
        return complexes[0];
      }
      return new Complex$7();
    }
  }], [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isString)(data) && cmlStartRegexp.test(data);
    }
  }]);
  return CMLParser2;
}(Parser);
CMLParser.formats = ["cml"];
CMLParser.extensions = [".cml"];
var mmtf = { exports: {} };
(function(module, exports) {
  !function(r2, t2) {
    t2(exports);
  }(commonjsGlobal, function(r2) {
    function t2(r3, t3, n3) {
      for (var e3 = (r3.byteLength, 0), i3 = n3.length; i3 > e3; e3++) {
        var o3 = n3.charCodeAt(e3);
        if (128 > o3) r3.setUint8(t3++, o3 >>> 0 & 127 | 0);
        else if (2048 > o3) r3.setUint8(t3++, o3 >>> 6 & 31 | 192), r3.setUint8(t3++, o3 >>> 0 & 63 | 128);
        else if (65536 > o3) r3.setUint8(t3++, o3 >>> 12 & 15 | 224), r3.setUint8(t3++, o3 >>> 6 & 63 | 128), r3.setUint8(t3++, o3 >>> 0 & 63 | 128);
        else {
          if (!(1114112 > o3)) throw new Error("bad codepoint " + o3);
          r3.setUint8(t3++, o3 >>> 18 & 7 | 240), r3.setUint8(t3++, o3 >>> 12 & 63 | 128), r3.setUint8(t3++, o3 >>> 6 & 63 | 128), r3.setUint8(t3++, o3 >>> 0 & 63 | 128);
        }
      }
    }
    function n2(r3) {
      for (var t3 = 0, n3 = 0, e3 = r3.length; e3 > n3; n3++) {
        var i3 = r3.charCodeAt(n3);
        if (128 > i3) t3 += 1;
        else if (2048 > i3) t3 += 2;
        else if (65536 > i3) t3 += 3;
        else {
          if (!(1114112 > i3)) throw new Error("bad codepoint " + i3);
          t3 += 4;
        }
      }
      return t3;
    }
    function e2(r3, i3, o3) {
      var a3 = _typeof(r3);
      if ("string" === a3) {
        var u3 = n2(r3);
        if (32 > u3) return i3.setUint8(o3, 160 | u3), t2(i3, o3 + 1, r3), 1 + u3;
        if (256 > u3) return i3.setUint8(o3, 217), i3.setUint8(o3 + 1, u3), t2(i3, o3 + 2, r3), 2 + u3;
        if (65536 > u3) return i3.setUint8(o3, 218), i3.setUint16(o3 + 1, u3), t2(i3, o3 + 3, r3), 3 + u3;
        if (4294967296 > u3) return i3.setUint8(o3, 219), i3.setUint32(o3 + 1, u3), t2(i3, o3 + 5, r3), 5 + u3;
      }
      if (r3 instanceof Uint8Array) {
        var u3 = r3.byteLength, s3 = new Uint8Array(i3.buffer);
        if (256 > u3) return i3.setUint8(o3, 196), i3.setUint8(o3 + 1, u3), s3.set(r3, o3 + 2), 2 + u3;
        if (65536 > u3) return i3.setUint8(o3, 197), i3.setUint16(o3 + 1, u3), s3.set(r3, o3 + 3), 3 + u3;
        if (4294967296 > u3) return i3.setUint8(o3, 198), i3.setUint32(o3 + 1, u3), s3.set(r3, o3 + 5), 5 + u3;
      }
      if ("number" === a3) {
        if (!isFinite(r3)) throw new Error("Number not finite: " + r3);
        if (Math.floor(r3) !== r3) return i3.setUint8(o3, 203), i3.setFloat64(o3 + 1, r3), 9;
        if (r3 >= 0) {
          if (128 > r3) return i3.setUint8(o3, r3), 1;
          if (256 > r3) return i3.setUint8(o3, 204), i3.setUint8(o3 + 1, r3), 2;
          if (65536 > r3) return i3.setUint8(o3, 205), i3.setUint16(o3 + 1, r3), 3;
          if (4294967296 > r3) return i3.setUint8(o3, 206), i3.setUint32(o3 + 1, r3), 5;
          throw new Error("Number too big 0x" + r3.toString(16));
        }
        if (r3 >= -32) return i3.setInt8(o3, r3), 1;
        if (r3 >= -128) return i3.setUint8(o3, 208), i3.setInt8(o3 + 1, r3), 2;
        if (r3 >= -32768) return i3.setUint8(o3, 209), i3.setInt16(o3 + 1, r3), 3;
        if (r3 >= -2147483648) return i3.setUint8(o3, 210), i3.setInt32(o3 + 1, r3), 5;
        throw new Error("Number too small -0x" + (-r3).toString(16).substr(1));
      }
      if (null === r3) return i3.setUint8(o3, 192), 1;
      if ("boolean" === a3) return i3.setUint8(o3, r3 ? 195 : 194), 1;
      if ("object" === a3) {
        var u3, f3 = 0, c3 = Array.isArray(r3);
        if (c3) u3 = r3.length;
        else {
          var d3 = Object.keys(r3);
          u3 = d3.length;
        }
        var f3;
        if (16 > u3 ? (i3.setUint8(o3, u3 | (c3 ? 144 : 128)), f3 = 1) : 65536 > u3 ? (i3.setUint8(o3, c3 ? 220 : 222), i3.setUint16(o3 + 1, u3), f3 = 3) : 4294967296 > u3 && (i3.setUint8(o3, c3 ? 221 : 223), i3.setUint32(o3 + 1, u3), f3 = 5), c3) for (var l3 = 0; u3 > l3; l3++) {
          f3 += e2(r3[l3], i3, o3 + f3);
        }
        else for (var l3 = 0; u3 > l3; l3++) {
          var v3 = d3[l3];
          f3 += e2(v3, i3, o3 + f3), f3 += e2(r3[v3], i3, o3 + f3);
        }
        return f3;
      }
      throw new Error("Unknown type " + a3);
    }
    function i2(r3) {
      var t3 = _typeof(r3);
      if ("string" === t3) {
        var e3 = n2(r3);
        if (32 > e3) return 1 + e3;
        if (256 > e3) return 2 + e3;
        if (65536 > e3) return 3 + e3;
        if (4294967296 > e3) return 5 + e3;
      }
      if (r3 instanceof Uint8Array) {
        var e3 = r3.byteLength;
        if (256 > e3) return 2 + e3;
        if (65536 > e3) return 3 + e3;
        if (4294967296 > e3) return 5 + e3;
      }
      if ("number" === t3) {
        if (Math.floor(r3) !== r3) return 9;
        if (r3 >= 0) {
          if (128 > r3) return 1;
          if (256 > r3) return 2;
          if (65536 > r3) return 3;
          if (4294967296 > r3) return 5;
          throw new Error("Number too big 0x" + r3.toString(16));
        }
        if (r3 >= -32) return 1;
        if (r3 >= -128) return 2;
        if (r3 >= -32768) return 3;
        if (r3 >= -2147483648) return 5;
        throw new Error("Number too small -0x" + r3.toString(16).substr(1));
      }
      if ("boolean" === t3 || null === r3) return 1;
      if ("object" === t3) {
        var e3, o3 = 0;
        if (Array.isArray(r3)) {
          e3 = r3.length;
          for (var a3 = 0; e3 > a3; a3++) {
            o3 += i2(r3[a3]);
          }
        } else {
          var u3 = Object.keys(r3);
          e3 = u3.length;
          for (var a3 = 0; e3 > a3; a3++) {
            var s3 = u3[a3];
            o3 += i2(s3) + i2(r3[s3]);
          }
        }
        if (16 > e3) return 1 + o3;
        if (65536 > e3) return 3 + o3;
        if (4294967296 > e3) return 5 + o3;
        throw new Error("Array or object too long 0x" + e3.toString(16));
      }
      throw new Error("Unknown type " + t3);
    }
    function o2(r3) {
      var t3 = new ArrayBuffer(i2(r3)), n3 = new DataView(t3);
      return e2(r3, n3, 0), new Uint8Array(t3);
    }
    function a2(r3, t3, n3) {
      return t3 ? new r3(t3.buffer, t3.byteOffset, t3.byteLength / (n3 || 1)) : void 0;
    }
    function u2(r3) {
      return a2(DataView, r3);
    }
    function s2(r3) {
      return a2(Uint8Array, r3);
    }
    function f2(r3) {
      return a2(Int8Array, r3);
    }
    function c2(r3) {
      return a2(Int32Array, r3, 4);
    }
    function d2(r3) {
      return a2(Float32Array, r3, 4);
    }
    function l2(r3, t3) {
      var n3 = r3.length / 2;
      t3 || (t3 = new Int16Array(n3));
      for (var e3 = 0, i3 = 0; n3 > e3; ++e3, i3 += 2) {
        t3[e3] = r3[i3] << 8 ^ r3[i3 + 1] << 0;
      }
      return t3;
    }
    function v2(r3, t3) {
      var n3 = r3.length;
      t3 || (t3 = new Uint8Array(2 * n3));
      for (var e3 = u2(t3), i3 = 0; n3 > i3; ++i3) {
        e3.setInt16(2 * i3, r3[i3]);
      }
      return s2(t3);
    }
    function g2(r3, t3) {
      var n3 = r3.length / 4;
      t3 || (t3 = new Int32Array(n3));
      for (var e3 = 0, i3 = 0; n3 > e3; ++e3, i3 += 4) {
        t3[e3] = r3[i3] << 24 ^ r3[i3 + 1] << 16 ^ r3[i3 + 2] << 8 ^ r3[i3 + 3] << 0;
      }
      return t3;
    }
    function L2(r3, t3) {
      var n3 = r3.length;
      t3 || (t3 = new Uint8Array(4 * n3));
      for (var e3 = u2(t3), i3 = 0; n3 > i3; ++i3) {
        e3.setInt32(4 * i3, r3[i3]);
      }
      return s2(t3);
    }
    function h2(r3, t3) {
      var n3 = r3.length;
      t3 || (t3 = new Float32Array(n3 / 4));
      for (var e3 = u2(t3), i3 = u2(r3), o3 = 0, a3 = 0, s3 = n3 / 4; s3 > o3; ++o3, a3 += 4) {
        e3.setFloat32(a3, i3.getFloat32(a3), true);
      }
      return t3;
    }
    function y2(r3, t3, n3) {
      var e3 = r3.length, i3 = 1 / t3;
      n3 || (n3 = new Float32Array(e3));
      for (var o3 = 0; e3 > o3; ++o3) {
        n3[o3] = r3[o3] * i3;
      }
      return n3;
    }
    function m2(r3, t3, n3) {
      var e3 = r3.length;
      n3 || (n3 = new Int32Array(e3));
      for (var i3 = 0; e3 > i3; ++i3) {
        n3[i3] = Math.round(r3[i3] * t3);
      }
      return n3;
    }
    function p2(r3, t3) {
      var n3, e3;
      if (!t3) {
        var i3 = 0;
        for (n3 = 0, e3 = r3.length; e3 > n3; n3 += 2) {
          i3 += r3[n3 + 1];
        }
        t3 = new r3.constructor(i3);
      }
      var o3 = 0;
      for (n3 = 0, e3 = r3.length; e3 > n3; n3 += 2) {
        for (var a3 = r3[n3], u3 = r3[n3 + 1], s3 = 0; u3 > s3; ++s3) {
          t3[o3] = a3, ++o3;
        }
      }
      return t3;
    }
    function U2(r3) {
      if (0 === r3.length) return new Int32Array();
      var t3, n3, e3 = 2;
      for (t3 = 1, n3 = r3.length; n3 > t3; ++t3) {
        r3[t3 - 1] !== r3[t3] && (e3 += 2);
      }
      var i3 = new Int32Array(e3), o3 = 0, a3 = 1;
      for (t3 = 1, n3 = r3.length; n3 > t3; ++t3) {
        r3[t3 - 1] !== r3[t3] ? (i3[o3] = r3[t3 - 1], i3[o3 + 1] = a3, a3 = 1, o3 += 2) : ++a3;
      }
      return i3[o3] = r3[r3.length - 1], i3[o3 + 1] = a3, i3;
    }
    function b2(r3, t3) {
      var n3 = r3.length;
      t3 || (t3 = new r3.constructor(n3)), n3 && (t3[0] = r3[0]);
      for (var e3 = 1; n3 > e3; ++e3) {
        t3[e3] = r3[e3] + t3[e3 - 1];
      }
      return t3;
    }
    function I2(r3, t3) {
      var n3 = r3.length;
      t3 || (t3 = new r3.constructor(n3)), t3[0] = r3[0];
      for (var e3 = 1; n3 > e3; ++e3) {
        t3[e3] = r3[e3] - r3[e3 - 1];
      }
      return t3;
    }
    function w2(r3, t3) {
      var n3, e3, i3 = r3 instanceof Int8Array ? 127 : 32767, o3 = -i3 - 1, a3 = r3.length;
      if (!t3) {
        var u3 = 0;
        for (n3 = 0; a3 > n3; ++n3) {
          r3[n3] < i3 && r3[n3] > o3 && ++u3;
        }
        t3 = new Int32Array(u3);
      }
      for (n3 = 0, e3 = 0; a3 > n3; ) {
        for (var s3 = 0; r3[n3] === i3 || r3[n3] === o3; ) {
          s3 += r3[n3], ++n3;
        }
        s3 += r3[n3], ++n3, t3[e3] = s3, ++e3;
      }
      return t3;
    }
    function C(r3, t3) {
      var n3, e3 = t3 ? 127 : 32767, i3 = -e3 - 1, o3 = r3.length, a3 = 0;
      for (n3 = 0; o3 > n3; ++n3) {
        var u3 = r3[n3];
        0 === u3 ? ++a3 : a3 += u3 === e3 || u3 === i3 ? 2 : u3 > 0 ? Math.ceil(u3 / e3) : Math.ceil(u3 / i3);
      }
      var s3 = t3 ? new Int8Array(a3) : new Int16Array(a3), f3 = 0;
      for (n3 = 0; o3 > n3; ++n3) {
        var u3 = r3[n3];
        if (u3 >= 0) for (; u3 >= e3; ) {
          s3[f3] = e3, ++f3, u3 -= e3;
        }
        else for (; i3 >= u3; ) {
          s3[f3] = i3, ++f3, u3 -= i3;
        }
        s3[f3] = u3, ++f3;
      }
      return s3;
    }
    function A2(r3, t3) {
      return b2(p2(r3), t3);
    }
    function x2(r3) {
      return U2(I2(r3));
    }
    function M2(r3, t3, n3) {
      return y2(p2(r3, c2(n3)), t3, n3);
    }
    function F2(r3, t3) {
      return U2(m2(r3, t3));
    }
    function S2(r3, t3, n3) {
      return y2(b2(r3, c2(n3)), t3, n3);
    }
    function E2(r3, t3, n3) {
      return I2(m2(r3, t3), n3);
    }
    function N2(r3, t3, n3) {
      return y2(w2(r3, c2(n3)), t3, n3);
    }
    function O2(r3, t3, n3) {
      var e3 = w2(r3, c2(n3));
      return S2(e3, t3, d2(e3));
    }
    function T(r3, t3, n3) {
      return C(E2(r3, t3), n3);
    }
    function k2(r3) {
      var t3 = u2(r3), n3 = t3.getInt32(0), e3 = t3.getInt32(4), i3 = r3.subarray(8, 12), r3 = r3.subarray(12);
      return [n3, r3, e3, i3];
    }
    function j2(r3, t3, n3, e3) {
      var i3 = new ArrayBuffer(12 + e3.byteLength), o3 = new Uint8Array(i3), a3 = new DataView(i3);
      return a3.setInt32(0, r3), a3.setInt32(4, t3), n3 && o3.set(n3, 8), o3.set(e3, 12), o3;
    }
    function q2(r3) {
      var t3 = r3.length, n3 = s2(r3);
      return j2(2, t3, void 0, n3);
    }
    function D2(r3) {
      var t3 = r3.length, n3 = L2(r3);
      return j2(4, t3, void 0, n3);
    }
    function P2(r3, t3) {
      var n3 = r3.length / t3, e3 = L2([t3]), i3 = s2(r3);
      return j2(5, n3, e3, i3);
    }
    function z2(r3) {
      var t3 = r3.length, n3 = L2(U2(r3));
      return j2(6, t3, void 0, n3);
    }
    function B2(r3) {
      var t3 = r3.length, n3 = L2(x2(r3));
      return j2(8, t3, void 0, n3);
    }
    function V(r3, t3) {
      var n3 = r3.length, e3 = L2([t3]), i3 = L2(F2(r3, t3));
      return j2(9, n3, e3, i3);
    }
    function G2(r3, t3) {
      var n3 = r3.length, e3 = L2([t3]), i3 = v2(T(r3, t3));
      return j2(10, n3, e3, i3);
    }
    function R2(r3) {
      var t3 = {};
      return rr.forEach(function(n3) {
        void 0 !== r3[n3] && (t3[n3] = r3[n3]);
      }), r3.bondAtomList && (t3.bondAtomList = D2(r3.bondAtomList)), r3.bondOrderList && (t3.bondOrderList = q2(r3.bondOrderList)), t3.xCoordList = G2(r3.xCoordList, 1e3), t3.yCoordList = G2(r3.yCoordList, 1e3), t3.zCoordList = G2(r3.zCoordList, 1e3), r3.bFactorList && (t3.bFactorList = G2(r3.bFactorList, 100)), r3.atomIdList && (t3.atomIdList = B2(r3.atomIdList)), r3.altLocList && (t3.altLocList = z2(r3.altLocList)), r3.occupancyList && (t3.occupancyList = V(r3.occupancyList, 100)), t3.groupIdList = B2(r3.groupIdList), t3.groupTypeList = D2(r3.groupTypeList), r3.secStructList && (t3.secStructList = q2(r3.secStructList)), r3.insCodeList && (t3.insCodeList = z2(r3.insCodeList)), r3.sequenceIndexList && (t3.sequenceIndexList = B2(r3.sequenceIndexList)), t3.chainIdList = P2(r3.chainIdList, 4), r3.chainNameList && (t3.chainNameList = P2(r3.chainNameList, 4)), t3;
    }
    function H2(r3) {
      function t3(r4) {
        for (var t4 = {}, n4 = 0; r4 > n4; n4++) {
          var e4 = o3();
          t4[e4] = o3();
        }
        return t4;
      }
      function n3(t4) {
        var n4 = r3.subarray(a3, a3 + t4);
        return a3 += t4, n4;
      }
      function e3(t4) {
        var n4 = r3.subarray(a3, a3 + t4);
        a3 += t4;
        var e4 = 65535;
        if (t4 > e4) {
          for (var i4 = [], o4 = 0; o4 < n4.length; o4 += e4) {
            i4.push(String.fromCharCode.apply(null, n4.subarray(o4, o4 + e4)));
          }
          return i4.join("");
        }
        return String.fromCharCode.apply(null, n4);
      }
      function i3(r4) {
        for (var t4 = new Array(r4), n4 = 0; r4 > n4; n4++) {
          t4[n4] = o3();
        }
        return t4;
      }
      function o3() {
        var o4, s3, f3 = r3[a3];
        if (0 === (128 & f3)) return a3++, f3;
        if (128 === (240 & f3)) return s3 = 15 & f3, a3++, t3(s3);
        if (144 === (240 & f3)) return s3 = 15 & f3, a3++, i3(s3);
        if (160 === (224 & f3)) return s3 = 31 & f3, a3++, e3(s3);
        if (224 === (224 & f3)) return o4 = u3.getInt8(a3), a3++, o4;
        switch (f3) {
          case 192:
            return a3++, null;
          case 194:
            return a3++, false;
          case 195:
            return a3++, true;
          case 196:
            return s3 = u3.getUint8(a3 + 1), a3 += 2, n3(s3);
          case 197:
            return s3 = u3.getUint16(a3 + 1), a3 += 3, n3(s3);
          case 198:
            return s3 = u3.getUint32(a3 + 1), a3 += 5, n3(s3);
          case 202:
            return o4 = u3.getFloat32(a3 + 1), a3 += 5, o4;
          case 203:
            return o4 = u3.getFloat64(a3 + 1), a3 += 9, o4;
          case 204:
            return o4 = r3[a3 + 1], a3 += 2, o4;
          case 205:
            return o4 = u3.getUint16(a3 + 1), a3 += 3, o4;
          case 206:
            return o4 = u3.getUint32(a3 + 1), a3 += 5, o4;
          case 208:
            return o4 = u3.getInt8(a3 + 1), a3 += 2, o4;
          case 209:
            return o4 = u3.getInt16(a3 + 1), a3 += 3, o4;
          case 210:
            return o4 = u3.getInt32(a3 + 1), a3 += 5, o4;
          case 217:
            return s3 = u3.getUint8(a3 + 1), a3 += 2, e3(s3);
          case 218:
            return s3 = u3.getUint16(a3 + 1), a3 += 3, e3(s3);
          case 219:
            return s3 = u3.getUint32(a3 + 1), a3 += 5, e3(s3);
          case 220:
            return s3 = u3.getUint16(a3 + 1), a3 += 3, i3(s3);
          case 221:
            return s3 = u3.getUint32(a3 + 1), a3 += 5, i3(s3);
          case 222:
            return s3 = u3.getUint16(a3 + 1), a3 += 3, t3(s3);
          case 223:
            return s3 = u3.getUint32(a3 + 1), a3 += 5, t3(s3);
        }
        throw new Error("Unknown type 0x" + f3.toString(16));
      }
      var a3 = 0, u3 = new DataView(r3.buffer);
      return o3();
    }
    function W2(r3, t3, n3, e3) {
      switch (r3) {
        case 1:
          return h2(t3);
        case 2:
          return f2(t3);
        case 3:
          return l2(t3);
        case 4:
          return g2(t3);
        case 5:
          return s2(t3);
        case 6:
          return p2(g2(t3), new Uint8Array(n3));
        case 7:
          return p2(g2(t3));
        case 8:
          return A2(g2(t3));
        case 9:
          return M2(g2(t3), g2(e3)[0]);
        case 10:
          return O2(l2(t3), g2(e3)[0]);
        case 11:
          return y2(l2(t3), g2(e3)[0]);
        case 12:
          return N2(l2(t3), g2(e3)[0]);
        case 13:
          return N2(f2(t3), g2(e3)[0]);
        case 14:
          return w2(l2(t3));
        case 15:
          return w2(f2(t3));
      }
    }
    function X2(r3, t3) {
      t3 = t3 || {};
      var n3 = t3.ignoreFields, e3 = {};
      return nr.forEach(function(t4) {
        var i3 = n3 ? -1 !== n3.indexOf(t4) : false, o3 = r3[t4];
        i3 || void 0 === o3 || (o3 instanceof Uint8Array ? e3[t4] = W2.apply(null, k2(o3)) : e3[t4] = o3);
      }), e3;
    }
    function J(r3) {
      return String.fromCharCode.apply(null, r3).replace(/\0/g, "");
    }
    function K(r3, t3, n3) {
      n3 = n3 || {};
      var e3, i3, o3, a3, u3, s3, f3 = n3.firstModelOnly, c3 = t3.onModel, d3 = t3.onChain, l3 = t3.onGroup, v3 = t3.onAtom, g3 = t3.onBond, L3 = 0, h3 = 0, y3 = 0, m3 = 0, p3 = 0, U3 = -1, b3 = r3.chainNameList, I3 = r3.secStructList, w3 = r3.insCodeList, C2 = r3.sequenceIndexList, A3 = r3.atomIdList, x3 = r3.bFactorList, M3 = r3.altLocList, F3 = r3.occupancyList, S3 = r3.bondAtomList, E3 = r3.bondOrderList;
      for (e3 = 0, i3 = r3.chainsPerModel.length; i3 > e3 && !(f3 && L3 > 0); ++e3) {
        var N3 = r3.chainsPerModel[L3];
        for (c3 && c3({
          chainCount: N3,
          modelIndex: L3
        }), o3 = 0; N3 > o3; ++o3) {
          var O3 = r3.groupsPerChain[h3];
          if (d3) {
            var T2 = J(r3.chainIdList.subarray(4 * h3, 4 * h3 + 4)), k3 = null;
            b3 && (k3 = J(b3.subarray(4 * h3, 4 * h3 + 4))), d3({
              groupCount: O3,
              chainIndex: h3,
              modelIndex: L3,
              chainId: T2,
              chainName: k3
            });
          }
          for (a3 = 0; O3 > a3; ++a3) {
            var j3 = r3.groupList[r3.groupTypeList[y3]], q3 = j3.atomNameList.length;
            if (l3) {
              var D3 = null;
              I3 && (D3 = I3[y3]);
              var P3 = null;
              r3.insCodeList && (P3 = String.fromCharCode(w3[y3]));
              var z3 = null;
              C2 && (z3 = C2[y3]), l3({
                atomCount: q3,
                groupIndex: y3,
                chainIndex: h3,
                modelIndex: L3,
                groupId: r3.groupIdList[y3],
                groupType: r3.groupTypeList[y3],
                groupName: j3.groupName,
                singleLetterCode: j3.singleLetterCode,
                chemCompType: j3.chemCompType,
                secStruct: D3,
                insCode: P3,
                sequenceIndex: z3
              });
            }
            for (u3 = 0; q3 > u3; ++u3) {
              if (v3) {
                var B3 = null;
                A3 && (B3 = A3[m3]);
                var V2 = null;
                x3 && (V2 = x3[m3]);
                var G3 = null;
                M3 && (G3 = String.fromCharCode(M3[m3]));
                var R3 = null;
                F3 && (R3 = F3[m3]), v3({
                  atomIndex: m3,
                  groupIndex: y3,
                  chainIndex: h3,
                  modelIndex: L3,
                  atomId: B3,
                  element: j3.elementList[u3],
                  atomName: j3.atomNameList[u3],
                  formalCharge: j3.formalChargeList[u3],
                  xCoord: r3.xCoordList[m3],
                  yCoord: r3.yCoordList[m3],
                  zCoord: r3.zCoordList[m3],
                  bFactor: V2,
                  altLoc: G3,
                  occupancy: R3
                });
              }
              m3 += 1;
            }
            if (g3) {
              var H3 = j3.bondAtomList;
              for (u3 = 0, s3 = j3.bondOrderList.length; s3 > u3; ++u3) {
                g3({
                  atomIndex1: m3 - q3 + H3[2 * u3],
                  atomIndex2: m3 - q3 + H3[2 * u3 + 1],
                  bondOrder: j3.bondOrderList[u3]
                });
              }
            }
            y3 += 1;
          }
          h3 += 1;
        }
        if (p3 = U3 + 1, U3 = m3 - 1, g3 && S3) for (u3 = 0, s3 = S3.length; s3 > u3; u3 += 2) {
          var W3 = S3[u3], X3 = S3[u3 + 1];
          (W3 >= p3 && U3 >= W3 || X3 >= p3 && U3 >= X3) && g3({
            atomIndex1: W3,
            atomIndex2: X3,
            bondOrder: E3 ? E3[u3 / 2] : null
          });
        }
        L3 += 1;
      }
    }
    function Q2(r3) {
      return o2(R2(r3));
    }
    function Y2(r3, t3) {
      r3 instanceof ArrayBuffer && (r3 = new Uint8Array(r3));
      var n3;
      return n3 = r3 instanceof Uint8Array ? H2(r3) : r3, X2(n3, t3);
    }
    function Z2(r3, t3, n3, e3) {
      function i3() {
        try {
          var r4 = Y2(o3.response);
          n3(r4);
        } catch (t4) {
          e3(t4);
        }
      }
      var o3 = new XMLHttpRequest();
      o3.addEventListener("load", i3, true), o3.addEventListener("error", e3, true), o3.responseType = "arraybuffer", o3.open("GET", t3 + r3.toUpperCase()), o3.send();
    }
    function $(r3, t3, n3) {
      Z2(r3, or, t3, n3);
    }
    function _2(r3, t3, n3) {
      Z2(r3, ar, t3, n3);
    }
    var rr = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"], tr = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"], nr = rr.concat(tr), er = "v1.1.0dev", ir = "//mmtf.rcsb.org/v1.0/", or = ir + "full/", ar = ir + "reduced/";
    r2.encode = Q2, r2.decode = Y2, r2.traverse = K, r2.fetch = $, r2.fetchReduced = _2, r2.version = er, r2.fetchUrl = or, r2.fetchReducedUrl = ar, r2.encodeMsgpack = o2, r2.encodeMmtf = R2, r2.decodeMsgpack = H2, r2.decodeMmtf = X2;
  });
})(mmtf, mmtf.exports);
var MMTF = mmtf.exports;
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$6 = chem.Complex;
var Chain$1 = chem.Chain;
var Atom$1 = chem.Atom;
var Element$6 = chem.Element;
var Helix$1 = chem.Helix;
var Sheet$1 = chem.Sheet;
var Strand$1 = chem.Strand;
var Bond$2 = chem.Bond;
var Assembly$1 = chem.Assembly;
var Molecule$6 = chem.Molecule;
var ArrayComparator = function() {
  function ArrayComparator2(original) {
    _classCallCheck(this, ArrayComparator2);
    this._original = Array.from(original);
    this._original.sort();
    this._sum = 0;
    for (var i2 = 0; i2 < this._original.length; ++i2) {
      this._sum += this._original[i2];
    }
  }
  _createClass(ArrayComparator2, [{
    key: "compare",
    value: function compare(candidate) {
      var len = candidate.length;
      if (len !== this._original.length) {
        return false;
      }
      var sum = 0;
      var i2;
      for (i2 = 0; i2 < len; ++i2) {
        sum += candidate[i2];
      }
      if (sum !== this._sum) {
        return false;
      }
      var sorted = Array.from(candidate);
      sorted.sort();
      for (i2 = 0; i2 < len; ++i2) {
        if (sorted[i2] !== this._original[i2]) {
          return false;
        }
      }
      return true;
    }
  }]);
  return ArrayComparator2;
}();
ArrayComparator.prototype.constructor = ArrayComparator;
var StructuralElementType = StructuralElement.Type;
var secStructToType = [
  StructuralElementType.HELIX_PI,
  StructuralElementType.BEND,
  StructuralElementType.HELIX_ALPHA,
  StructuralElementType.STRAND,
  StructuralElementType.HELIX_310,
  StructuralElementType.BRIDGE,
  StructuralElementType.TURN,
  StructuralElementType.COIL
];
function getFirstByte(buf) {
  var bytes = new Uint8Array(buf, 0, 1);
  return bytes[0];
}
var MMTFParser = function(_Parser) {
  _inherits(MMTFParser2, _Parser);
  var _super = _createSuper$n(MMTFParser2);
  function MMTFParser2(data, options2) {
    var _this;
    _classCallCheck(this, MMTFParser2);
    _this = _super.call(this, data, options2);
    _this._options.fileType = "mmtf";
    return _this;
  }
  _createClass(MMTFParser2, [{
    key: "_onModel",
    value: function _onModel(_modelData) {
    }
  }, {
    key: "_onChain",
    value: function _onChain(chainData) {
      if (chainData.modelIndex !== 0) {
        return;
      }
      var chain2 = new Chain$1(this._complex, chainData.chainName);
      this._complex._chains[chainData.chainIndex] = chain2;
      chain2._index = chainData.chainIndex;
    }
  }, {
    key: "_onGroup",
    value: function _onGroup(groupData) {
      if (groupData.modelIndex !== 0) {
        return;
      }
      if (this.settings.now.nowater) {
        if (groupData.groupName === "HOH" || groupData.groupName === "WAT") {
          return;
        }
      }
      var chain2 = this._complex._chains[groupData.chainIndex];
      var icode = !groupData.insCode.charCodeAt(0) ? "" : groupData.insCode;
      var residue2 = chain2.addResidue(groupData.groupName, groupData.groupId, icode);
      residue2._index = groupData.groupIndex;
      this._updateSecStructure(this._complex, residue2, groupData);
    }
  }, {
    key: "_onAtom",
    value: function _onAtom(atomData) {
      if (atomData.modelIndex !== 0) {
        return;
      }
      var altLoc = !atomData.altLoc.charCodeAt(0) ? "" : atomData.altLoc;
      var atom = new Atom$1(
        atomData.groupIndex,
        atomData.atomName,
        Element$6.getByName(atomData.element.toUpperCase()),
        new Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord),
        Element$6.Role[atomData.atomName],
        false,
        atomData.atomId,
        altLoc,
        atomData.occupancy,
        atomData.bFactor,
        atomData.formalCharge
      );
      this._complex._atoms[atomData.atomIndex] = atom;
      atom.index = atomData.atomIndex;
      this._serialAtomMap[atomData.atomId] = atom;
    }
  }, {
    key: "_onBond",
    value: function _onBond(bondData) {
      var right = Math.max(bondData.atomIndex1, bondData.atomIndex2);
      if (right >= this._complex._atoms.length) {
        return;
      }
      var left = Math.min(bondData.atomIndex1, bondData.atomIndex2);
      this._complex.addBond(this._complex._atoms[left], this._complex._atoms[right], bondData.bondOrder, Bond$2.BondType.UNKNOWN, true);
    }
  }, {
    key: "_updateSecStructure",
    value: function _updateSecStructure(complex, residue2, groupData) {
      var helixClasses = [3, -1, 1, -1, 5];
      if (!(0, import_lodash.isUndefined)(groupData) && groupData.secStruct === this._ssType) {
        residue2._secondary = this._ssStruct;
        if (this._ssStruct) {
          this._ssStruct.term = residue2;
        }
        return;
      }
      if (!(0, import_lodash.isUndefined)(groupData)) {
        var type = secStructToType[groupData.secStruct];
        this._ssType = groupData.secStruct;
        this._ssStart = residue2;
        var struct = null;
        switch (this._ssType) {
          case -1:
          case 7:
            break;
          case 0:
          case 2:
          case 4:
            struct = new Helix$1(helixClasses[this._ssType], residue2, residue2, 0, "", "", 0);
            complex._helices.push(struct);
            break;
          case 3: {
            var sheet = new Sheet$1("", 0);
            complex._sheets.push(sheet);
            struct = new Strand$1(sheet, residue2, residue2, 0, null, null);
            break;
          }
          default:
            if (type !== void 0) {
              struct = new StructuralElement(type, residue2, residue2);
            }
            break;
        }
        this._ssStruct = struct;
        residue2._secondary = struct;
        if (struct) {
          complex.structures.push(struct);
        }
      }
    }
  }, {
    key: "_updateMolecules",
    value: function _updateMolecules(mmtfData) {
      var entities = mmtfData.entityList;
      if (!entities) {
        return;
      }
      var chainsInModel0 = mmtfData.chainsPerModel[0];
      for (var i2 = 0; i2 < entities.length; i2++) {
        var entity = entities[i2];
        var chains = entity.chainIndexList;
        var residues = [];
        for (var j2 = 0; j2 < chains.length; j2++) {
          var chainIndex = chains[j2];
          if (chainIndex >= chainsInModel0) {
            continue;
          }
          var chain2 = this._complex._chains[chainIndex];
          residues = residues.concat(chain2._residues.slice());
        }
        var molecule = new Molecule$6(this._complex, entity.description, i2 + 1);
        molecule.residues = residues;
        this._complex._molecules[i2] = molecule;
      }
    }
  }, {
    key: "_traverse",
    value: function _traverse(mmtfData) {
      var self2 = this;
      var metadata = this._complex.metadata;
      metadata.id = mmtfData.structureId;
      metadata.title = [];
      metadata.title[0] = mmtfData.title;
      metadata.date = mmtfData.releaseDate;
      metadata.format = "mmtf";
      var eventCallbacks = {
        onModel: function onModel(modelData) {
          self2._onModel(modelData);
        },
        onChain: function onChain(chainData) {
          self2._onChain(chainData);
        },
        onGroup: function onGroup(groupData) {
          self2._onGroup(groupData);
        },
        onAtom: function onAtom(atomData) {
          self2._onAtom(atomData);
        },
        onBond: function onBond(bondData) {
          self2._onBond(bondData);
        }
      };
      this._ssType = -1;
      this._ssStruct = null;
      this._ssStart = null;
      MMTF.traverse(mmtfData, eventCallbacks);
      this._updateSecStructure(this._complex);
      this._updateMolecules(mmtfData);
    }
  }, {
    key: "_linkAtomsToResidues",
    value: function _linkAtomsToResidues() {
      for (var i2 = 0; i2 < this._complex._atoms.length; ++i2) {
        var atom = this._complex._atoms[i2];
        var residue2 = this._complex._residues[atom.residue];
        atom.residue = residue2;
        residue2._atoms.push(atom);
      }
    }
  }, {
    key: "_findSynonymousChains",
    value: function _findSynonymousChains() {
      var named = {};
      for (var i2 = 0; i2 < this._complex._chains.length; ++i2) {
        var chain2 = this._complex._chains[i2];
        var name2 = chain2.getName();
        if (!named.hasOwnProperty(name2)) {
          named[name2] = [];
        }
        named[name2].push(chain2._index);
      }
      return named;
    }
  }, {
    key: "_parseAssemblyInfo",
    value: function _parseAssemblyInfo(mmtfData) {
      var i2;
      var j2;
      var k2;
      var assemblies = [];
      var logger2 = this.logger;
      for (i2 = 0; i2 < mmtfData.bioAssemblyList.length; ++i2) {
        var baInfo = mmtfData.bioAssemblyList[i2];
        if (baInfo.transformList.length === 0) {
          continue;
        }
        var chains = baInfo.transformList[0].chainIndexList;
        var chainListCheck = new ArrayComparator(chains);
        var chainNames = {};
        for (j2 = 0; j2 < chains.length; ++j2) {
          chainNames[this._complex._chains[chains[j2]].getName()] = 1;
        }
        var allChains = [];
        var name2 = void 0;
        for (name2 in chainNames) {
          if (chainNames.hasOwnProperty(name2)) {
            Array.prototype.push.apply(allChains, this._chainsByName[name2]);
          }
        }
        if (!chainListCheck.compare(allChains)) {
          logger2.debug("MMTF: Assembly is missing some of the synonymous chains. Skipping...");
        }
        var a2 = new Assembly$1(this._complex);
        for (name2 in chainNames) {
          if (chainNames.hasOwnProperty(name2)) {
            a2.addChain(name2);
          }
        }
        a2.addMatrix(new Matrix4().fromArray(baInfo.transformList[0].matrix).transpose());
        for (j2 = 1; j2 < baInfo.transformList.length; ++j2) {
          var transform = baInfo.transformList[j2];
          if (!chainListCheck.compare(transform.chainIndexList)) {
            logger2.debug("MMTF: Chain lists differ for different transforms in one assembly. Skipping...");
            continue;
          }
          var m2 = new Matrix4().fromArray(transform.matrix).transpose();
          for (k2 = 0; k2 < a2.matrices.length; ++k2) {
            if (a2.matrices[k2].equals(m2)) {
              break;
            }
          }
          if (k2 === a2.matrices.length) {
            a2.addMatrix(m2);
          }
        }
        a2.finalize();
        assemblies.push(a2);
      }
      return assemblies;
    }
  }, {
    key: "_markHeteroAtoms",
    value: function _markHeteroAtoms(mmtfData) {
      var chainsInModel0 = mmtfData.chainsPerModel[0];
      for (var i2 = 0; i2 < mmtfData.entityList.length; ++i2) {
        var entity = mmtfData.entityList[i2];
        if (entity.type !== "polymer") {
          for (var j2 = 0; j2 < entity.chainIndexList.length; ++j2) {
            var chainIndex = entity.chainIndexList[j2];
            if (chainIndex >= chainsInModel0) {
              continue;
            }
            var chain2 = this._complex._chains[chainIndex];
            for (var k2 = 0; k2 < chain2._residues.length; ++k2) {
              var res = chain2._residues[k2];
              for (var m2 = 0; m2 < res._atoms.length; ++m2) {
                res._atoms[m2].het = true;
              }
            }
          }
        }
      }
    }
  }, {
    key: "_joinSynonymousChains",
    value: function _joinSynonymousChains() {
      var i2;
      var j2;
      var primaryChainsArray = [];
      var primaryChainsHash = {};
      for (i2 = 0; i2 < this._complex._chains.length; ++i2) {
        var chain2 = this._complex._chains[i2];
        var name2 = chain2.getName();
        if (!primaryChainsHash.hasOwnProperty(name2)) {
          primaryChainsHash[name2] = chain2;
          chain2._index = primaryChainsArray.length;
          primaryChainsArray.push(chain2);
          continue;
        }
        var primary = primaryChainsHash[name2];
        for (j2 = 0; j2 < chain2._residues.length; ++j2) {
          var residue2 = chain2._residues[j2];
          primary._residues.push(residue2);
          residue2._chain = primary;
        }
      }
      this._complex._chains = primaryChainsArray;
    }
  }, {
    key: "parseSync",
    value: function parseSync() {
      var mmtfData = MMTF.decode(this._data);
      this._complex = new Complex$6();
      this._serialAtomMap = {};
      this._traverse(mmtfData);
      this._linkAtomsToResidues();
      this._markHeteroAtoms(mmtfData);
      this._chainsByName = this._findSynonymousChains();
      Array.prototype.push.apply(this._complex.units, this._parseAssemblyInfo(mmtfData));
      this._joinSynonymousChains();
      this._complex.finalize({
        needAutoBonding: false,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing,
        serialAtomMap: this._serialAtomMap
      });
      return this._complex;
    }
  }], [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isArrayBuffer)(data) && (getFirstByte(data) | 1) === 223;
    }
  }]);
  return MMTFParser2;
}(Parser);
MMTFParser.formats = ["mmtf"];
MMTFParser.extensions = [".mmtf"];
MMTFParser.binary = true;
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ParsingError = function(_Error) {
  _inherits(ParsingError2, _Error);
  var _super = _createSuper$m(ParsingError2);
  function ParsingError2(message, line, column) {
    var _this;
    _classCallCheck(this, ParsingError2);
    _this = _super.call(this, "data:".concat(line, ":").concat(column, ": ").concat(message));
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), ParsingError2);
    }
    _this.name = "ParsingError";
    _this.parseLine = line;
    _this.parseColumn = column;
    return _this;
  }
  return _createClass(ParsingError2);
}(_wrapNativeSuper(Error));
function _isWhitespace(ch) {
  return ch === 32 || ch === 10 || ch === 13 || ch === 9;
}
function _inlineIndexOf(ch0, str, idx) {
  var len = str.length;
  var ch = -1;
  while (idx < len) {
    ch = str.charCodeAt(idx);
    if (ch === ch0 || ch === 10) {
      break;
    }
    ++idx;
  }
  return ch === ch0 ? idx : -1;
}
function readCIF(source) {
  var i2 = 0;
  var j2 = 0;
  var n2 = source.length;
  var code = NaN;
  var newline = true;
  var line = 1;
  var column = 1;
  var begin;
  var state = 0;
  var result = {};
  var block = {};
  var keys2 = [];
  var keysCount = 0;
  var key = "";
  var values = [];
  var valuesCount = 0;
  var value;
  function _parseValue() {
    var val;
    if ((code === 46 || code === 63) && (i2 + 1 >= n2 || _isWhitespace(source.charCodeAt(i2 + 1)))) {
      ++column;
      ++i2;
      return void 0;
    }
    if (newline && code === 59) {
      j2 = i2;
      var lines = 0;
      do {
        j2 = _inlineIndexOf(10, source, j2 + 1);
        if (j2 === -1) {
          throw new ParsingError("Unterminated text block found", line, column);
        }
        ++lines;
      } while (j2 + 1 < n2 && source.charCodeAt(j2 + 1) !== code || j2 + 1 >= n2);
      val = source.substring(i2 + 1, j2).replace(/\r/g, "");
      i2 = j2 + 2;
      line += lines;
      column = 1;
      newline = false;
      return val;
    }
    if (code === 39 || code === 34) {
      j2 = i2;
      do {
        j2 = _inlineIndexOf(code, source, j2 + 1);
        if (j2 === -1) {
          throw new ParsingError("Unterminated quoted string found", line, column);
        }
      } while (j2 + 1 < n2 && !_isWhitespace(source.charCodeAt(j2 + 1)));
      val = source.substring(i2 + 1, j2);
      column += j2 - i2 + 1;
      i2 = j2 + 1;
      return val;
    }
    j2 = i2;
    while (j2 < n2 && !_isWhitespace(source.charCodeAt(j2))) {
      ++j2;
    }
    val = source.substring(i2, j2);
    column += j2 - i2;
    i2 = j2;
    var num = Number(val);
    if (!Number.isNaN(num)) {
      return num;
    }
    return val;
  }
  function _storeKey(tag) {
    keys2[keysCount++] = tag;
  }
  function _storeValue(val) {
    var keyIndex2 = valuesCount % keysCount;
    values[keyIndex2].push(val);
    ++valuesCount;
    return val;
  }
  while (i2 <= n2) {
    code = source.charCodeAt(i2);
    if (code === 13) ;
    else if (code === 10) {
      newline = true;
      ++line;
      column = 1;
    } else {
      if (code === 32 || code === 9) ;
      else if (code === 35) {
        i2 = _inlineIndexOf(10, source, i2 + 1);
        if (i2 === -1) {
          break;
        } else {
          continue;
        }
      } else if (state === 0) {
        if ((code === 68 || code === 100) && source.substr(i2 + 1, 4).toLowerCase() === "ata_") {
          j2 = i2 + 5;
          begin = j2;
          while (j2 < n2 && !_isWhitespace(source.charCodeAt(j2))) {
            ++j2;
          }
          column += j2 - i2;
          i2 = j2;
          if (begin < i2) {
            result[source.substring(begin, i2)] = block = {};
            state = 1;
            continue;
          } else {
            throw new ParsingError("Data block name missing", line, column);
          }
        } else if (Number.isNaN(code)) {
          break;
        } else {
          throw new ParsingError("Unexpected character in state ".concat(state), line, column);
        }
      } else if (state === 1) {
        if ((code === 68 || code === 100) && source.substr(i2 + 1, 4).toLowerCase() === "ata_") {
          state = 0;
          continue;
        } else if (code === 95) {
          j2 = i2 + 1;
          begin = j2;
          while (j2 < n2 && !_isWhitespace(source.charCodeAt(j2))) {
            ++j2;
          }
          column += j2 - i2;
          i2 = j2;
          if (begin < i2) {
            key = source.substring(begin, i2);
            state = 2;
            continue;
          } else {
            throw new ParsingError("Tag name missing", line, column);
          }
        } else if ((code === 76 || code === 108) && source.substr(i2 + 1, 4).toLowerCase() === "oop_") {
          i2 += 5;
          column += 5;
          if (i2 < n2 && !_isWhitespace(source.charCodeAt(i2))) {
            throw new ParsingError("Unexpected character in state ".concat(state), line, column);
          } else {
            keys2 = [];
            keysCount = 0;
            values = [];
            valuesCount = 0;
            state = 3;
            continue;
          }
        } else if (Number.isNaN(code)) {
          break;
        } else {
          throw new ParsingError("Unexpected character in state ".concat(state), line, column);
        }
      } else if (state === 2) {
        if (Number.isNaN(code)) {
          break;
        }
        value = _parseValue();
        (0, import_lodash.set)(block, key, value);
        state = 1;
        continue;
      } else if (state === 3) {
        if (code === 95) {
          j2 = i2 + 1;
          begin = j2;
          while (j2 < n2 && !_isWhitespace(source.charCodeAt(j2))) {
            ++j2;
          }
          column += j2 - i2;
          i2 = j2;
          if (begin < i2) {
            _storeKey(source.substring(begin, i2));
            continue;
          } else {
            throw new ParsingError("Tag name missing", line, column);
          }
        } else {
          if (keysCount > 0) {
            for (var keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
              value = [];
              values[keyIndex] = value;
              (0, import_lodash.set)(block, keys2[keyIndex], value);
            }
            state = 4;
            continue;
          }
          throw new ParsingError("Data tags are missing inside a loop", line, column);
        }
      } else if (state === 4) {
        if ((code === 68 || code === 100) && source.substr(i2 + 1, 4).toLowerCase() === "ata_") {
          state = 0;
        } else if (code === 95) {
          state = 1;
        } else if ((code === 76 || code === 108) && source.substr(i2 + 1, 4).toLowerCase() === "oop_") {
          state = 1;
        } else if (Number.isNaN(code)) {
          state = 0;
        } else {
          _storeValue(_parseValue());
        }
        continue;
      } else {
        throw new ParsingError("Unexpected internal state ".concat(state), line, column);
      }
      newline = false;
      ++column;
    }
    ++i2;
  }
  if (state === 2) {
    throw new ParsingError("Unexpected end of file in state ".concat(state), line, column);
  }
  return result;
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$5 = chem.Complex;
var Element$5 = chem.Element;
var Helix = chem.Helix;
var Sheet = chem.Sheet;
var Strand = chem.Strand;
var Assembly = chem.Assembly;
var Molecule$5 = chem.Molecule;
var cRequiredAtomFields = ["auth_seq_id", "Cartn_x", "Cartn_y", "Cartn_z", "label_atom_id"];
var cSecondaryCoding = {
  helx: "helix",
  turn: "turn",
  strn: "strand"
};
function getTypeFromId(string5) {
  var typeId = /[A-Za-z]+/.exec(string5);
  if (!typeId) {
    return null;
  }
  return cSecondaryCoding[typeId[0].toLowerCase()];
}
function arrize(arrayLikeObject) {
  if (arrayLikeObject === null || arrayLikeObject === void 0 || (0, import_lodash.isArray)(arrayLikeObject)) {
    return arrayLikeObject;
  }
  return [arrayLikeObject];
}
function nameToElement(name2) {
  var veryLong = name2.trim().length === 4;
  return name2.slice(0, veryLong ? 1 : 2).trim();
}
var AtomDataError = function(_Error) {
  _inherits(AtomDataError2, _Error);
  var _super = _createSuper$l(AtomDataError2);
  function AtomDataError2(message) {
    var _this;
    _classCallCheck(this, AtomDataError2);
    _this = _super.call(this);
    _this.name = "AtomDataError";
    _this.message = message;
    return _this;
  }
  return _createClass(AtomDataError2);
}(_wrapNativeSuper(Error));
function _getOperations(operList) {
  if (!operList) {
    return null;
  }
  var idc = arrize(operList.id);
  var matrix = operList.matrix, vector = operList.vector;
  if (!idc || !matrix || !vector) {
    return null;
  }
  var ops = [];
  for (var i2 = 0, n2 = idc.length; i2 < n2; ++i2) {
    var mtx = new Matrix4();
    var elements = mtx.elements;
    for (var row = 0; row < 3; ++row) {
      var matrixData = matrix[row + 1];
      elements[row] = arrize(matrixData[1])[i2];
      elements[row + 4] = arrize(matrixData[2])[i2];
      elements[row + 8] = arrize(matrixData[3])[i2];
      elements[row + 12] = arrize(vector[row + 1])[i2];
    }
    ops[idc[i2]] = mtx;
  }
  return ops;
}
function _extractOperations(assemblyGen, opsDict) {
  assemblyGen = (0, import_lodash.isString)(assemblyGen) ? assemblyGen : "".concat(assemblyGen);
  var l2 = assemblyGen.replace(/\)\s*\(/g, "!").replace(/[()']/g, "");
  var groupStr = l2.split("!");
  var gps = [];
  for (var grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
    var gr = groupStr[grIdx].split(",");
    var gp = [];
    var idx = 0;
    for (var i2 = 0, n2 = gr.length; i2 < n2; ++i2) {
      var s2 = gr[i2];
      if (s2.includes("-")) {
        var es = s2.split("-");
        var j2 = parseInt(es[0], 10);
        var m2 = parseInt(es[1], 10);
        for (; j2 <= m2; ++j2) {
          gp[idx++] = opsDict[j2];
        }
      } else {
        gp[idx++] = opsDict[s2];
      }
    }
    gps.push(gp);
  }
  var matrices = [];
  var cnt = 0;
  function traverse(level, mtx) {
    for (var ii = 0, nn2 = gps[level].length; ii < nn2; ++ii) {
      var newMtx = mtx ? mtx.clone() : new Matrix4();
      newMtx.multiplyMatrices(gps[level][ii], newMtx);
      if (level === 0) {
        matrices[cnt++] = newMtx;
      } else {
        traverse(level - 1, newMtx);
      }
    }
  }
  traverse(gps.length - 1);
  return matrices;
}
var CIFParser = function(_Parser) {
  _inherits(CIFParser2, _Parser);
  var _super2 = _createSuper$l(CIFParser2);
  function CIFParser2(data, options2) {
    var _this2;
    _classCallCheck(this, CIFParser2);
    _this2 = _super2.call(this, data, options2);
    _this2.asymDict = {};
    _this2.molecules = [];
    _this2._options.fileType = "cif";
    return _this2;
  }
  _createClass(CIFParser2, [{
    key: "parseSync",
    value: function parseSync() {
      this.logger.info("Parsing CIF file..");
      var data = readCIF(this._data);
      return this._toComplex(data);
    }
  }, {
    key: "_toComplex",
    value: function _toComplex(cifData) {
      var complex = new Complex$5();
      var complexData = cifData[Object.keys(cifData)[0]];
      this._extractAtoms(complex, complexData);
      this._extractSecondary(complex, complexData);
      this._extractAssemblies(complex, complexData);
      this._extractMolecules(complex, complexData);
      this._extractMetadata(complex, complexData);
      complex.finalize({
        needAutoBonding: true,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing
      });
      return complex;
    }
  }, {
    key: "_extractMetadata",
    value: function _extractMetadata(complex, complexData) {
      var metadata = complex.metadata;
      metadata.id = complexData.entry.id;
      metadata.classification = complexData.struct_keywords.pdbx_keywords;
      var databaserev = complexData.database_PDB_rev;
      metadata.date = databaserev && databaserev.date_original ? databaserev.date_original : "";
      metadata.format = "cif";
      metadata.title = [];
      metadata.title[0] = complexData.struct.title;
    }
  }, {
    key: "_extractMolecules",
    value: function _extractMolecules(complex, complexData) {
      var molData = complexData.entity;
      var names = arrize(molData.pdbx_description);
      var count = names.length;
      var i2;
      for (i2 = 0; i2 < count; i2++) {
        if (this.molecules[i2]) {
          this.molecules[i2].name = names[i2];
        } else {
          this.molecules[i2] = {
            name: names[i2],
            residues: []
          };
        }
      }
      var molecules = complex.getMolecules();
      for (i2 = 0; i2 < count; i2++) {
        var molecule = this.molecules[i2];
        molecules[i2] = new Molecule$5(complex, molecule.name, i2 + 1);
        molecules[i2].residues = molecule.residues;
      }
    }
  }, {
    key: "_extractAtoms",
    value: function _extractAtoms(complex, complexData) {
      var atomData = complexData.atom_site;
      if (!atomData) {
        throw new AtomDataError("CIF parsing error: atom_site is not specified!");
      }
      for (var f2 = 0, n2 = cRequiredAtomFields.length; f2 < n2; ++f2) {
        if (!atomData[cRequiredAtomFields[f2]]) {
          throw new AtomDataError("CIF parsing error: requires field ".concat(cRequiredAtomFields[f2], " not found!"));
        }
      }
      var asymDict = this.asymDict;
      var resIdc = arrize(atomData.auth_seq_id);
      var x2 = arrize(atomData.Cartn_x);
      var y2 = arrize(atomData.Cartn_y);
      var z2 = arrize(atomData.Cartn_z);
      var names = arrize(atomData.label_atom_id);
      var count = names.length;
      var group = arrize(atomData.group_PDB) || [];
      var chainIdc = arrize(atomData.auth_asym_id) || [];
      var chainLabelIdc = arrize(atomData.label_asym_id) || [];
      var serials = arrize(atomData.id) || [];
      var iCodes = arrize(atomData.pdbx_PDB_ins_code) || [];
      var resNames = arrize(atomData.label_comp_id) || [];
      var elements = arrize(atomData.type_symbol) || [];
      var tempFactors = arrize(atomData.B_iso_or_equiv) || [];
      var occupancies = arrize(atomData.occupancy) || [];
      var charges = arrize(atomData.pdbx_formal_charge) || [];
      var altLocs = arrize(atomData.label_alt_id) || [];
      var models = arrize(atomData.pdbx_PDB_model_num) || [];
      var molecules = arrize(atomData.label_entity_id) || [];
      var chain2 = null;
      var residue2 = null;
      for (var i2 = 0; i2 < count; ++i2) {
        var model = models[i2] || 1;
        if (model !== 1) {
          continue;
        }
        var chainID = String(chainIdc[i2] || " ");
        if (!chain2 || chain2.getName() !== chainID) {
          chain2 = complex.getChain(chainID) || complex.addChain(chainID);
        }
        asymDict[String(chainLabelIdc[i2] || " ")] = chainID;
        var resSeq = resIdc[i2];
        var iCode = String(iCodes[i2] || " ");
        var resName = String(resNames[i2] || "");
        if (!residue2 || residue2.getSequence() !== resSeq || residue2.getICode() !== iCode) {
          residue2 = chain2.addResidue(resName, resSeq, iCode);
          var moleculeIdx = molecules[i2] - 1;
          var entity = this.molecules[moleculeIdx];
          if (!entity) {
            this.molecules[moleculeIdx] = {
              name: "",
              residues: []
            };
            entity = this.molecules[moleculeIdx];
          }
          entity.residues.push(residue2);
        }
        var name2 = names[i2];
        var element = elements[i2] || nameToElement(name2);
        var type = Element$5.getByName(element);
        var role = Element$5.Role[name2.trim()];
        var xyz = new Vector3(x2[i2], y2[i2], z2[i2]);
        var het = group[i2] === "HETATM" || false;
        var serial2 = serials[i2] || i2;
        var tempFactor = tempFactors[i2] || 0;
        var occupancy = occupancies[i2] || 0;
        var altLoc = String(altLocs[i2] || "");
        var charge = charges[i2] || 0;
        residue2.addAtom(name2, type, xyz, role, het, serial2, altLoc, occupancy, tempFactor, charge);
      }
    }
  }, {
    key: "_extractSecondary",
    value: function _extractSecondary(complex, complexData) {
      if (complexData.struct_conf) {
        this._extractConfs(complex, complexData.struct_conf);
      }
      if (complexData.struct_sheet_range) {
        this._extractSheets(complex, complexData.struct_sheet_range);
      }
    }
  }, {
    key: "_extractSheets",
    value: function _extractSheets(complex, sheetData) {
      var asymDict = this.asymDict;
      if (!sheetData.sheet_id || !sheetData.id || !sheetData.beg_label_seq_id || !sheetData.end_label_seq_id || !sheetData.beg_label_asym_id) {
        return;
      }
      var sheets = complex._sheets;
      function getSheet(name2) {
        var n3 = sheets.length;
        for (var i3 = 0; i3 < n3; ++i3) {
          if (sheets[i3]._name === name2) {
            return sheets[i3];
          }
        }
        sheets[n3] = new Sheet(name2, 0);
        return sheets[n3];
      }
      var sheetNames = arrize(sheetData.sheet_id);
      var strandNames = arrize(sheetData.id);
      var starts = arrize(sheetData.beg_auth_seq_id);
      var ends = arrize(sheetData.end_auth_seq_id);
      var chains = arrize(sheetData.beg_label_asym_id);
      var stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || [];
      var endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || [];
      for (var i2 = 0, n2 = strandNames.length; i2 < n2; ++i2) {
        var chain2 = complex.getChain(asymDict[chains[i2]]);
        var sheet = getSheet(sheetNames[i2]);
        var startIdx = starts[i2];
        var endIdx = ends[i2];
        var startICode = stICodes[i2] || " ";
        var endICode = endICodes[i2] || " ";
        var start = chain2.findResidue(startIdx, startICode);
        var end = chain2.findResidue(endIdx, endICode);
        if (!start || !end) {
          continue;
        }
        var strand = new Strand(sheet, start[0], end[0], 0, null, null);
        var residues = chain2.getResidues();
        for (var r2 = start[1]; r2 <= end[1]; ++r2) {
          residues[r2]._secondary = strand;
        }
        sheet.addStrand(strand);
        complex.structures.push(strand);
      }
    }
  }, {
    key: "_extractConfs",
    value: function _extractConfs(complex, helicesData) {
      var asymDict = this.asymDict;
      if (!helicesData.conf_type_id || !helicesData.beg_label_seq_id || !helicesData.end_label_seq_id || !helicesData.beg_label_asym_id) {
        return;
      }
      var types = arrize(helicesData.conf_type_id);
      var starts = arrize(helicesData.beg_auth_seq_id);
      var stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || [];
      var ends = arrize(helicesData.end_auth_seq_id);
      var endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || [];
      var comments = arrize(helicesData.details) || [];
      var lengths = arrize(helicesData.pdbx_PDB_helix_length) || [];
      var helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || [];
      var names = arrize(helicesData.id) || [];
      var chains = arrize(helicesData.beg_label_asym_id);
      for (var i2 = 0, n2 = types.length; i2 < n2; ++i2) {
        var type = getTypeFromId(types[i2]);
        if (!type) {
          continue;
        }
        var name2 = names[i2] || types[i2];
        var chain2 = complex.getChain(asymDict[chains[i2]]);
        var startIdx = starts[i2];
        var endIdx = ends[i2];
        var startICode = stICodes[i2] || " ";
        var endICode = endICodes[i2] || " ";
        var start = chain2.findResidue(startIdx, startICode);
        var end = chain2.findResidue(endIdx, endICode);
        if (!start || !end) {
          continue;
        }
        var comment = comments[i2] || "";
        var length = lengths[i2] || 0;
        var helixClass = helixClasses[i2] || " ";
        var struct = void 0;
        if (type === "helix") {
          var idx = complex._helices.length;
          struct = new Helix(helixClass, start[0], end[0], idx, name2, comment, length);
          complex.addHelix(struct);
          complex.structures.push(struct);
        } else if (type === "turn") {
          struct = new StructuralElement(StructuralElement.Type.TURN, start[0], end[0]);
          complex.structures.push(struct);
        } else {
          struct = null;
        }
        if (!struct) {
          continue;
        }
        var residues = chain2.getResidues();
        for (var r2 = start[1]; r2 <= end[1]; ++r2) {
          residues[r2]._secondary = struct;
        }
      }
    }
  }, {
    key: "_extractAssemblies",
    value: function _extractAssemblies(complex, complexData) {
      var asymDict = this.asymDict;
      var asmGen = complexData.pdbx_struct_assembly_gen;
      if (!asmGen) {
        return;
      }
      var asmIdx = arrize(asmGen.assembly_id);
      var asmOper = arrize(asmGen.oper_expression);
      var asmList = arrize(asmGen.asym_id_list);
      if (!asmIdx || !asmOper || !asmList) {
        return;
      }
      var operList = _getOperations(complexData.pdbx_struct_oper_list);
      if (!operList) {
        return;
      }
      for (var i2 = 0, n2 = asmIdx.length; i2 < n2; ++i2) {
        var asm = new Assembly(complex);
        var assemblyOps = _extractOperations(asmOper[i2], operList);
        var entries = asmList[i2].split(",");
        for (var ii = 0, nn2 = entries.length; ii < nn2; ++ii) {
          var chain2 = entries[ii].trim();
          if (chain2.length > 0) {
            asm.addChain(asymDict[chain2]);
          }
        }
        asm.matrices = assemblyOps;
        complex.units.push(asm);
      }
    }
  }], [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isString)(data) && /^\s*data_/i.test(data);
    }
  }]);
  return CIFParser2;
}(Parser);
CIFParser.formats = ["cif", "mmcif"];
CIFParser.extensions = [".cif", ".mmcif"];
var valueType = {
  singular: 0,
  vector: 1,
  array: 2,
  buffer: 3
};
var VolumeModel = function() {
  function VolumeModel2() {
    _classCallCheck(this, VolumeModel2);
    _defineProperty2(this, "_xyz2crs", []);
    _defineProperty2(this, "_origin", new Vector3(0, 0, 0));
    this._header = {};
    this._boxSize = new Vector3();
    this._boxStart = new Vector3();
    this._header.delta = {};
    this._header.extent = [];
    this._header.nstart = [];
    this._header.grid = [];
    this._header.crs2xyz = [];
    this._header.cellDims = new Vector3();
    this._header.angles = [];
    this._header.origin = new Vector3(0, 0, 0);
    this._header.dmin = 0;
    this._header.dmean = 0;
    this._header.dmax = 0;
  }
  _createClass(VolumeModel2, [{
    key: "_typedCheck",
    value: function _typedCheck() {
      if ((0, import_lodash.isTypedArray)(this._buff)) {
        this._buff = this._buff.buffer;
      } else if (!(0, import_lodash.isArrayBuffer)(this._buff)) {
        throw new TypeError("Expected ArrayBuffer or TypedArray");
      }
    }
  }, {
    key: "_fillHeader",
    value: function _fillHeader(headerFormat, arrays) {
      for (var key in headerFormat) {
        if (headerFormat.hasOwnProperty(key)) {
          switch (headerFormat[key][0]) {
            case valueType.singular:
              this._header[key] = arrays[headerFormat[key][1]][headerFormat[key][2]];
              break;
            case valueType.array:
              this._parseArray(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);
              break;
            case valueType.vector:
              this._parseVector(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);
              break;
            case valueType.buffer:
              this._header[key] = new Uint8Array(arrays[headerFormat[key][1]], [headerFormat[key][2]] * 4, [headerFormat[key][3]] * 4);
              break;
          }
        }
      }
    }
  }, {
    key: "_parseVector",
    value: function _parseVector(vector, arr, pos) {
      var _ref = [arr[pos], arr[pos + 1], arr[pos + 2]];
      vector.x = _ref[0];
      vector.y = _ref[1];
      vector.z = _ref[2];
    }
  }, {
    key: "_parseArray",
    value: function _parseArray(vector, arr, pos) {
      vector[0] = arr[pos];
      vector[1] = arr[pos + 1];
      vector[2] = arr[pos + 2];
    }
  }, {
    key: "_parseHeader",
    value: function _parseHeader(_buffer) {
    }
  }, {
    key: "_setAxisIndices",
    value: function _setAxisIndices() {
    }
  }, {
    key: "_setOrigins",
    value: function _setOrigins() {
    }
  }, {
    key: "_getAxis",
    value: function _getAxis() {
      var header = this._header;
      var xScale = header.cellDims.x / header.grid[0];
      var yScale = header.cellDims.y / header.grid[1];
      var zScale = header.cellDims.z / header.grid[2];
      var _header$angles = _slicedToArray(header.angles, 3), alpha = _header$angles[0], beta = _header$angles[1], gamma = _header$angles[2];
      var z1 = Math.cos(beta);
      var z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
      var z3 = Math.sqrt(1 - z1 * z1 - z2 * z2);
      var xaxis = new Vector3(xScale, 0, 0);
      var yaxis = new Vector3(Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0);
      var zaxis = new Vector3(z1 * zScale, z2 * zScale, z3 * zScale);
      return [xaxis, yaxis, zaxis];
    }
  }, {
    key: "_getXYZdim",
    value: function _getXYZdim() {
      return [this._header.extent[this._xyz2crs[0]], this._header.extent[this._xyz2crs[1]], this._header.extent[this._xyz2crs[2]]];
    }
  }, {
    key: "_getVolumeInfo",
    value: function _getVolumeInfo() {
      var volInfo = (0, import_lodash.pick)(this._header, ["dmean", "dmin", "dmax", "sd", "delta"]);
      volInfo.obtuseAngle = this._header.angles.map(function(angle) {
        return Number(angle >= Math.PI / 2);
      });
      return volInfo;
    }
  }, {
    key: "_setBoxParams",
    value: function _setBoxParams(xaxis, yaxis, zaxis) {
      var _this = this;
      var shiftX = 0;
      var shiftY = 0;
      var _this$_header$angles = _slicedToArray(this._header.angles, 3), alpha = _this$_header$angles[0], beta = _this$_header$angles[1], gamma = _this$_header$angles[2];
      if (gamma >= Math.PI / 2) {
        shiftX += Math.abs(yaxis.x);
      }
      if (beta >= Math.PI / 2) {
        shiftX += Math.abs(zaxis.x);
      }
      if (alpha >= Math.PI / 2) {
        shiftY += Math.abs(zaxis.y);
      }
      this._boxStart = new Vector3(this._origin.x - shiftX, this._origin.y - shiftY, this._origin.z);
      this._boxSize = new Vector3(Math.abs(xaxis.x) + Math.abs(yaxis.x) + Math.abs(zaxis.x), Math.abs(yaxis.y) + Math.abs(zaxis.y), Math.abs(zaxis.z));
      var delta = function delta2(axe, proj) {
        return Math.abs(axe[proj]) / _this._boxSize[proj];
      };
      this._header.delta.x = delta(yaxis, "x");
      this._header.delta.y = delta(zaxis, "x");
      this._header.delta.z = delta(zaxis, "y");
    }
  }, {
    key: "_getXYZbox",
    value: function _getXYZbox() {
      return new Box3(this._boxStart.clone(), this._boxStart.clone().add(this._boxSize));
    }
  }, {
    key: "_toXYZData",
    value: function _toXYZData() {
    }
  }, {
    key: "parse",
    value: function parse(data) {
      this._parseHeader(data);
      this._setOrigins();
      return new Volume$2(Float32Array, this._getXYZdim(), this._getXYZbox(), 1, this._toXYZData(), this._getVolumeInfo());
    }
  }]);
  return VolumeModel2;
}();
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var CCP4Header = {
  extent: [valueType.array, "u32", 0],
  type: [valueType.singular, "u32", 3],
  nstart: [valueType.array, "i32", 4],
  grid: [valueType.array, "u32", 7],
  cellDims: [valueType.vector, "f32", 10],
  angles: [valueType.array, "f32", 13],
  crs2xyz: [valueType.array, "i32", 16],
  dmin: [valueType.singular, "f32", 19],
  dmax: [valueType.singular, "f32", 20],
  dmean: [valueType.singular, "f32", 21],
  ispg: [valueType.singular, "u32", 22],
  nsymbt: [valueType.singular, "u32", 23],
  lksflg: [valueType.singular, "u32", 24],
  customData: [valueType.buffer, "buffer", 25, 9],
  origin: [valueType.vector, "f32", 34],
  map: [valueType.buffer, "buffer", 52, 1],
  machine: [valueType.singular, "u32", 53],
  sd: [valueType.singular, "f32", 54],
  nlabel: [valueType.singular, "f32", 55],
  label: [valueType.buffer, "buffer", 56, 200]
};
var Ccp4Model = function(_VolumeModel) {
  _inherits(Ccp4Model2, _VolumeModel);
  var _super = _createSuper$k(Ccp4Model2);
  function Ccp4Model2() {
    _classCallCheck(this, Ccp4Model2);
    return _super.apply(this, arguments);
  }
  _createClass(Ccp4Model2, [{
    key: "_parseHeader",
    value: function _parseHeader(_buffer) {
      this._buff = _buffer;
      this._typedCheck();
      var arrays = {};
      arrays.u32 = new Uint32Array(this._buff, 0, 56);
      arrays.i32 = new Int32Array(this._buff, 0, 56);
      arrays.f32 = new Float32Array(this._buff, 0, 56);
      arrays.buffer = this._buff;
      var header = this._header;
      this._fillHeader(CCP4Header, arrays);
      header.angles.forEach(function(angle, i2, a2) {
        a2[i2] *= Math.PI / 180;
      });
    }
  }, {
    key: "_setAxisIndices",
    value: function _setAxisIndices() {
      var header = this._header;
      if (header.cellDims.x === 0 && header.cellDims.y === 0 && header.cellDims.z === 0) {
        header.cellDims.set(1, 1, 1);
      }
      var crs2xyz = this._header.crs2xyz;
      if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
        crs2xyz[0] = 1;
        crs2xyz[1] = 2;
        crs2xyz[2] = 3;
      }
      var xyz2crs = this._xyz2crs;
      xyz2crs[crs2xyz[0] - 1] = 0;
      xyz2crs[crs2xyz[1] - 1] = 1;
      xyz2crs[crs2xyz[2] - 1] = 2;
    }
  }, {
    key: "_setOrigins",
    value: function _setOrigins() {
      var _this$_getAxis = this._getAxis(), _this$_getAxis2 = _slicedToArray(_this$_getAxis, 3), xaxis = _this$_getAxis2[0], yaxis = _this$_getAxis2[1], zaxis = _this$_getAxis2[2];
      this._setAxisIndices();
      var header = this._header;
      var xyz2crs = this._xyz2crs;
      if (header.origin.x === 0 && header.origin.y === 0 && header.origin.z === 0) {
        this._origin.addScaledVector(xaxis, header.nstart[xyz2crs[0]]);
        this._origin.addScaledVector(yaxis, header.nstart[xyz2crs[1]]);
        this._origin.addScaledVector(zaxis, header.nstart[xyz2crs[2]]);
      } else {
        this._origin = header.origin;
      }
      xaxis.multiplyScalar(header.extent[xyz2crs[0]] - 1);
      yaxis.multiplyScalar(header.extent[xyz2crs[1]] - 1);
      zaxis.multiplyScalar(header.extent[xyz2crs[2]] - 1);
      if (header.type === 2) {
        this._data = new Float32Array(this._buff, 1024 + header.nsymbt, header.extent[0] * header.extent[1] * header.extent[2]);
      } else {
        throw new Error("CCP4: Unsupported format ".concat(header.type));
      }
      this._setBoxParams(xaxis, yaxis, zaxis);
    }
  }, {
    key: "_toXYZData",
    value: function _toXYZData() {
      var header = this._header;
      var data = this._data;
      var xyz2crs = this._xyz2crs;
      var xyzData = new Float32Array(data.length);
      var dim = this._getXYZdim();
      var xSize = dim[0];
      var ySize = dim[1];
      var crsIdx = 0;
      var coord = [];
      var x2;
      var y2;
      var z2;
      for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
        for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
          for (coord[0] = 0; coord[0] < header.extent[0]; coord[0]++, crsIdx++) {
            x2 = coord[xyz2crs[0]];
            y2 = coord[xyz2crs[1]];
            z2 = coord[xyz2crs[2]];
            xyzData[x2 + xSize * (y2 + ySize * z2)] = data[crsIdx];
          }
        }
      }
      return xyzData;
    }
  }]);
  return Ccp4Model2;
}(VolumeModel);
var CCP4Parser = function(_Parser) {
  _inherits(CCP4Parser2, _Parser);
  var _super2 = _createSuper$k(CCP4Parser2);
  function CCP4Parser2(data, options2) {
    var _this;
    _classCallCheck(this, CCP4Parser2);
    _this = _super2.call(this, data, options2);
    _this._options.fileType = "ccp4";
    _this.model = new Ccp4Model();
    return _this;
  }
  _createClass(CCP4Parser2, [{
    key: "parseSync",
    value: function parseSync() {
      return this.model.parse(this._data);
    }
  }], [{
    key: "canProbablyParse",
    value: function canProbablyParse(_data) {
      return false;
    }
  }]);
  return CCP4Parser2;
}(Parser);
CCP4Parser.formats = ["ccp4"];
CCP4Parser.extensions = [".ccp4", ".map", ".mrc"];
CCP4Parser.binary = true;
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$4 = chem.Complex;
var Element$4 = chem.Element;
var Molecule$4 = chem.Molecule;
var XYZParser = function(_Parser) {
  _inherits(XYZParser2, _Parser);
  var _super = _createSuper$j(XYZParser2);
  function XYZParser2(data, options2) {
    var _this;
    _classCallCheck(this, XYZParser2);
    _this = _super.call(this, data, options2);
    _this._complex = null;
    _this._atomsInf = null;
    _this._options.fileType = "xyz";
    _this._fileName = options2.name;
    return _this;
  }
  _createClass(XYZParser2, [{
    key: "_parseToAtomsInf",
    value: function _parseToAtomsInf(source) {
      var endnAtoms = source.indexOf("\n");
      var nAtoms = parseInt(source.substring(0, endnAtoms), 10);
      var endComment = source.indexOf("\n", endnAtoms + 1);
      var comment = source.slice(endnAtoms + 1, endComment).trim();
      if (comment.length === 0) {
        comment = this._fileName;
      }
      var startAtomsInf = endComment + source.substring(endComment).search(/\S/);
      this._atomsInf = source.substring(startAtomsInf).split(/[\s,]*\n[\s,]*/);
      if (!Number.isNaN(nAtoms) && this._atomsInf.length - 1 !== nAtoms) {
        this._complex.error = {
          message: "wrong number of atoms"
        };
        return;
      }
      this._complex.metadata.format = "xyz";
      this._complex.name = comment;
    }
  }, {
    key: "_parseAtomsInf",
    value: function _parseAtomsInf() {
      var het = true;
      var altLoc = " ";
      var occupancy = 1;
      var tempFactor = 1;
      var charge = 0;
      var chain2 = this._complex.addChain("A");
      var residue2 = chain2.addResidue("UNK", 1, " ");
      for (var i2 = 0; i2 < this._atomsInf.length - 1; i2++) {
        var words = this._atomsInf[i2].split(/[\s,]+/);
        if (words.length !== 4) {
          this._complex.error = {
            message: "missed parameters"
          };
          break;
        }
        var serial2 = i2 + 1;
        var name2 = words[0];
        var xyz = new Vector3(parseFloat(words[1]), parseFloat(words[2]), parseFloat(words[3]));
        var type = Element$4.getByName(name2);
        var role = void 0;
        residue2.addAtom(name2, type, xyz, role, het, serial2, altLoc, occupancy, tempFactor, charge);
      }
      var molecule = new Molecule$4(this._complex, this._complex.name, 1);
      molecule.residues = residue2;
      this._complex._molecules[0] = molecule;
    }
  }, {
    key: "parseSync",
    value: function parseSync() {
      var result = this._complex = new Complex$4();
      this._parseToAtomsInf(this._data);
      this._parseAtomsInf();
      this._complex.finalize({
        needAutoBonding: true,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing,
        serialAtomMap: this._serialAtomMap
      });
      this._complex = null;
      this._atomsInf = null;
      if (result.error) {
        throw new Error(result.error.message);
      }
      return result;
    }
  }], [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isString)(data) && /^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(data);
    }
  }]);
  return XYZParser2;
}(Parser);
_defineProperty2(XYZParser, "formats", ["xyz"]);
_defineProperty2(XYZParser, "extensions", [".xyz"]);
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$3 = chem.Complex;
var Element$3 = chem.Element;
var PubChemParser = function(_Parser) {
  _inherits(PubChemParser2, _Parser);
  var _super = _createSuper$i(PubChemParser2);
  function PubChemParser2(data, options2) {
    var _this;
    _classCallCheck(this, PubChemParser2);
    _this = _super.call(this, data, options2);
    _this._options.fileType = "pubchem+json";
    return _this;
  }
  _createClass(PubChemParser2, [{
    key: "parseSync",
    value: function parseSync() {
      this.logger.info("Parsing PubChem JSON file...");
      return this._toComplex(JSON.parse(this._data));
    }
  }, {
    key: "_toComplex",
    value: function _toComplex(jsonData) {
      var complex = new Complex$3();
      var complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0];
      if (complexData) {
        this._extractAtoms(complex, complexData);
        complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing
        });
      }
      return complex;
    }
  }, {
    key: "_extractAtoms",
    value: function _extractAtoms(complex, complexData) {
      var aids = complexData.atoms && complexData.atoms.aid;
      var elements = aids && complexData.atoms.element;
      if (!elements || aids.length !== elements.length) {
        throw new Error("Unable to parse atom elements");
      }
      elements = (0, import_lodash.fromPairs)((0, import_lodash.zip)(aids, elements));
      var atoms = {};
      var coords = complexData.coords && complexData.coords[0];
      var model = coords && coords.conformers && coords.conformers[0];
      var xs = model && model.x;
      var ys = model && model.y;
      var zs = model && model.z || [];
      aids = coords && coords.aid;
      if (!aids || !xs || !ys) {
        throw new Error("Coordinates are not found in the file");
      }
      var chain2 = complex.addChain(" ");
      var residue2 = chain2.addResidue("UNK", 1, " ");
      for (var i2 = 0, n2 = aids.length; i2 < n2; ++i2) {
        var aid = aids[i2];
        var element = Element$3.ByAtomicNumber[elements[aid]];
        var xyz = new Vector3(xs[i2], ys[i2], zs[i2] || 0);
        atoms[aid] = residue2.addAtom(element.name, element, xyz, void 0, true, aid, " ", 1, 0, 0);
      }
      var aids1 = complexData.bonds && complexData.bonds.aid1;
      var aids2 = complexData.bonds && complexData.bonds.aid2;
      var orders = complexData.bonds && complexData.bonds.order || [];
      if (!aids1 || !aids2 || aids1.length !== aids2.length) {
        return;
      }
      for (var j2 = 0, m2 = aids1.length; j2 < m2; ++j2) {
        complex.addBond(atoms[aids1[j2]], atoms[aids2[j2]], orders[j2] || 1, 0, true);
      }
    }
  }], [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isString)(data) && data[0] === "{";
    }
  }]);
  return PubChemParser2;
}(Parser);
PubChemParser.formats = ["pubchem", "pubchem+json", "pc"];
PubChemParser.extensions = [".json"];
var SDFStream = function() {
  function SDFStream2(data) {
    _classCallCheck(this, SDFStream2);
    this._strings = data.split(/\r?\n|\r/);
    this._currentStart = 0;
    this._currentStringIndx = 0;
  }
  _createClass(SDFStream2, [{
    key: "setStart",
    value: function setStart(start) {
      if (start >= this._strings.length) {
        this._currentStart = this._strings.length - 1;
        this._currentStringIndx = this._strings.length - 1;
      } else {
        this._currentStart = start;
        this._currentStringIndx = start;
      }
    }
  }, {
    key: "getNextString",
    value: function getNextString() {
      return this._strings[++this._currentStringIndx];
    }
  }, {
    key: "getCurrentString",
    value: function getCurrentString() {
      return this._strings[this._currentStringIndx];
    }
  }, {
    key: "getStringFromStart",
    value: function getStringFromStart(numb) {
      this._currentStringIndx = this._currentStart + numb;
      return this._strings[this._currentStart + numb];
    }
  }, {
    key: "findNextDataItem",
    value: function findNextDataItem() {
      var curStr = this.getNextString();
      var res = false;
      while (!(0, import_lodash.isUndefined)(curStr) && curStr.trim() !== "$$$$") {
        if (curStr.match(/>\s+<(.*)>/)) {
          res = true;
          break;
        }
        curStr = this.getNextString();
      }
      return res;
    }
  }, {
    key: "findNextCompoundStart",
    value: function findNextCompoundStart() {
      var curStr = this.getCurrentString();
      while (!(0, import_lodash.isUndefined)(curStr) && curStr.trim() !== "$$$$") {
        curStr = this.getNextString();
      }
      this.setStart(++this._currentStringIndx);
      return this.probablyHaveDataToParse();
    }
  }, {
    key: "probablyHaveDataToParse",
    value: function probablyHaveDataToParse() {
      return this._currentStringIndx < this._strings.length - 2;
    }
  }]);
  return SDFStream2;
}();
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$2 = chem.Complex;
var Element$2 = chem.Element;
var Bond$1 = chem.Bond;
var Molecule$3 = chem.Molecule;
var chargeMap = [0, 3, 2, 1, 0, -1, -2, -3];
var orderMap$1 = [0, 1, 2, 3, 1, 1, 1, 2];
var typeMap$1 = [
  Bond$1.BondType.UNKNOWN,
  Bond$1.BondType.COVALENT,
  Bond$1.BondType.COVALENT,
  Bond$1.BondType.COVALENT,
  Bond$1.BondType.AROMATIC,
  Bond$1.BondType.UNKNOWN,
  Bond$1.BondType.AROMATIC,
  Bond$1.BondType.AROMATIC
];
var sdfAndMolRegexp = /.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/;
var sdfRegExp = /.*($$$$).*|.*>\s+<(.+)>.*/;
var fileFormat = {
  SDF: "sdf",
  MOL: "mol"
};
var possibleNameTags = ["PUBCHEM_IUPAC_TRADITIONAL_NAME", /PUBCHEM_(.+)_NAME/, /(.+)name/, /(.+)NAME/];
var possibleIDTags = ["PUBCHEM_COMPOUND_CID", "id", "ID", /.*CID/, /.*ID/, /.*id/];
var possibleTitleTags = ["msg", "MSG", "message", "title", "description", "desc"];
var tagsNames = ["name", "id", "title"];
var tags = {
  name: possibleNameTags,
  id: possibleIDTags,
  title: possibleTitleTags
};
function buildChainID(index) {
  if (!index) {
    return "A";
  }
  var codes = [];
  while (index) {
    codes.push(65 + index % 26);
    index = Math.trunc(index / 26);
  }
  if (codes.length > 1) {
    codes.reverse();
    codes[0] -= 1;
  }
  return String.fromCharCode.apply(String, codes);
}
var SDFParser = function(_Parser) {
  _inherits(SDFParser2, _Parser);
  var _super = _createSuper$h(SDFParser2);
  function SDFParser2(data, options2) {
    var _this;
    _classCallCheck(this, SDFParser2);
    _this = _super.call(this, data, options2);
    _this._format = "sdf";
    _this._complex = null;
    _this._chain = null;
    _this._residue = null;
    _this._molecules = null;
    _this._metadata = {};
    _this._metadata.molecules = [];
    _this._currentMolProps = {};
    _this._compoundIndx = -1;
    _this._assemblies = [];
    _this._atomsParsed = 0;
    _this._atomsIndexes = [];
    return _this;
  }
  _createClass(SDFParser2, [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isString)(data) && sdfAndMolRegexp.test(data);
    }
  }, {
    key: "_parseHeader",
    value: function _parseHeader(stream) {
      var molecule = {};
      molecule.name = stream.getStringFromStart(0);
      var date = parseInt(stream.getStringFromStart(1).substr(10, 6).trim(), 10);
      molecule.date = date.toString() || "";
      molecule.title = stream.getStringFromStart(2);
      this._metadata.molecules.push(molecule);
    }
  }, {
    key: "_parseAtoms",
    value: function _parseAtoms(stream, atomsNum) {
      var curStr;
      var serial2 = this._atomsParsed;
      var chainID = buildChainID(this._compoundIndx);
      var resName = "UNK";
      var resSeq = 1;
      this._chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
      this._residue = this._chain.addResidue(resName, resSeq, " ");
      for (var i2 = 0; i2 < atomsNum; i2++) {
        curStr = stream.getNextString();
        serial2++;
        var x2 = parseFloat(curStr.substr(0, 10));
        var y2 = parseFloat(curStr.substr(10, 10));
        var z2 = parseFloat(curStr.substr(20, 10));
        var charge = chargeMap[parseInt(curStr.substr(36, 3), 10)];
        var xyz = new Vector3(x2, y2, z2);
        var name2 = curStr.substr(31, 3).trim().toUpperCase();
        var type = Element$2.getByName(name2);
        if (!this._atomsIndexes[name2]) {
          this._atomsIndexes[name2] = 0;
        }
        this._atomsIndexes[name2] += 1;
        name2 += this._atomsIndexes[name2];
        this._residue.addAtom(name2, type, xyz, void 0, true, serial2, " ", 1, 0, charge);
      }
    }
  }, {
    key: "_parseBonds",
    value: function _parseBonds(stream, bondsNum) {
      var curStr;
      for (var i2 = 0; i2 < bondsNum; i2++) {
        curStr = stream.getNextString();
        var atom1 = parseInt(curStr.substr(0, 3), 10) + this._atomsParsed;
        var atom2 = parseInt(curStr.substr(3, 3), 10) + this._atomsParsed;
        var bondType = parseInt(curStr.substr(6, 3), 10);
        if (atom1 > atom2) {
          var _ref = [atom2, atom1];
          atom1 = _ref[0];
          atom2 = _ref[1];
        }
        this._complex.addBond(atom1, atom2, orderMap$1[bondType] || 1, typeMap$1[bondType] || Bond$1.BondType.UNKNOWN, true);
      }
    }
  }, {
    key: "_parseMOL",
    value: function _parseMOL(stream) {
      this._compoundIndx++;
      this._parseHeader(stream);
      var countsLine = stream.getStringFromStart(3);
      var atomsNum = parseInt(countsLine.substr(0, 3), 10);
      var bondsNum = parseInt(countsLine.substr(3, 3), 10);
      this._parseAtoms(stream, atomsNum);
      this._parseBonds(stream, bondsNum);
      this._atomsParsed += atomsNum;
      this._metadata.molecules[this._compoundIndx]._residues = [];
      this._metadata.molecules[this._compoundIndx]._residues.push(this._residue);
    }
  }, {
    key: "_parseDataItem",
    value: function _parseDataItem(stream) {
      var tag = stream.getCurrentString();
      var data = [];
      var curStr = stream.getNextString();
      while (curStr.trim() !== "") {
        data.push(curStr);
        curStr = stream.getNextString();
      }
      if (data.length === 1) {
        var _data = data;
        var _data2 = _slicedToArray(_data, 1);
        data = _data2[0];
      }
      this._currentMolProps[tag.replace(/[<>]/g, "").trim()] = data;
    }
  }, {
    key: "_parseCompound",
    value: function _parseCompound(stream) {
      this._parseMOL(stream);
      if (this._format === fileFormat.SDF) {
        this._currentMolProps = {};
        while (stream.findNextDataItem()) {
          this._parseDataItem(stream);
        }
        if (Object.keys(this._currentMolProps).length !== 0) {
          var molecule = this._metadata.molecules[this._compoundIndx];
          molecule.props = this._currentMolProps;
          this._tryToUpdateMoleculeData(molecule);
        }
      }
    }
  }, {
    key: "_fixBondsArray",
    value: function _fixBondsArray() {
      var serialAtomMap = this._serialAtomMap;
      var complex = this._complex;
      var bonds = complex._bonds;
      for (var j2 = 0; j2 < bonds.length; j2++) {
        var bond = bonds[j2];
        if (bond._right < bond._left) {
          console.log("_fixBondsArray: Logic error.");
        }
        bond._left = serialAtomMap[bond._left] || null;
        bond._right = serialAtomMap[bond._right] || null;
      }
    }
  }, {
    key: "_buildAssemblies",
    value: function _buildAssemblies() {
      var chains = this._complex._chains;
      if (chains.length === 1) {
        return this._assemblies;
      }
      for (var i2 = 0; i2 < chains.length; i2++) {
        var assembly = new Assembly$3(this._complex);
        var matrix = new Matrix4();
        assembly.addMatrix(matrix);
        assembly.addChain(chains[i2]._name);
        this._assemblies.push(assembly);
      }
      return this._assemblies;
    }
  }, {
    key: "_buildMolecules",
    value: function _buildMolecules() {
      this._complex._molecules = [];
      var molecules = this._metadata.molecules;
      for (var i2 = 0; i2 < molecules.length; i2++) {
        var molecule = new Molecule$3(this._complex, molecules[i2].name, i2 + 1);
        molecule.residues = molecules[i2]._residues;
        this._complex._molecules[i2] = molecule;
      }
      return this._complex._molecules;
    }
  }, {
    key: "_searchTag",
    value: function _searchTag(tag, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        if (tag instanceof RegExp && tag.test(props[i2].tag) || tag === props[i2].tag) {
          return props[i2].data;
        }
      }
      return void 0;
    }
  }, {
    key: "_tryToFind",
    value: function _tryToFind(tagsList, props) {
      for (var j2 = 0; j2 < tagsList.length; j2++) {
        var res = this._searchTag(tagsList[j2], props);
        if (res) {
          return res;
        }
      }
      return void 0;
    }
  }, {
    key: "_tryToUpdateMoleculeData",
    value: function _tryToUpdateMoleculeData(molecule) {
      var res = false;
      for (var i2 = 0; i2 < tagsNames.length; i2++) {
        var tagPossibleNames = tags[tagsNames[i2]];
        var data = this._tryToFind(tagPossibleNames, molecule.props);
        if (data) {
          molecule[tagsNames[i2]] = data;
          res = true;
        }
      }
      molecule.name = molecule.name || molecule.id;
      if (molecule.name.match(/^\d+$/)) {
        molecule.name = "CID: ".concat(molecule.name);
      }
      return res;
    }
  }, {
    key: "_finalizeMetadata",
    value: function _finalizeMetadata() {
      var molecules = this._metadata.molecules;
      var metadata = this._complex.metadata;
      var complex = this._complex;
      if (molecules.length === 1) {
        complex.name = molecules[0].name;
        metadata.title = molecules[0].title;
        metadata.date = molecules[0].date;
        metadata.properties = molecules[0].props;
      } else if (molecules.length > 1) {
        metadata.molecules = [];
        for (var i2 = 0; i2 < molecules.length; i2++) {
          metadata.molecules.push({
            name: molecules[i2].name,
            date: molecules[i2].date,
            title: molecules[i2].title,
            properties: molecules[i2].props
          });
        }
      }
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      var serialAtomMap = this._serialAtomMap = {};
      var atoms = this._complex._atoms;
      for (var i2 = 0; i2 < atoms.length; i2++) {
        var atom = atoms[i2];
        serialAtomMap[atom.serial] = atom;
      }
      this._complex._finalizeBonds();
      this._fixBondsArray();
      this._finalizeMetadata();
      this._buildAssemblies();
      this._complex.units = this._complex.units.concat(this._assemblies);
      this._buildMolecules();
      this._complex.finalize({
        needAutoBonding: false,
        detectAromaticLoops: false,
        enableEditing: false,
        serialAtomMap: this._serialAtomMap
      });
    }
  }, {
    key: "defineFormat",
    value: function defineFormat(data) {
      var format;
      if (sdfRegExp.test(data)) {
        format = fileFormat.SDF;
      } else {
        format = fileFormat.MOL;
      }
      return format;
    }
  }, {
    key: "parseSync",
    value: function parseSync() {
      var result = this._complex = new Complex$2();
      var stream = new SDFStream(this._data);
      this._format = this.defineFormat(this._data);
      result.metadata.format = this._format;
      do {
        this._parseCompound(stream);
      } while (stream.findNextCompoundStart());
      this._finalize();
      return result;
    }
  }]);
  return SDFParser2;
}(Parser);
SDFParser.formats = ["mol", "sdf"];
SDFParser.extensions = [".mol", ".sdf"];
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var DSN6Header = {
  nstart: [valueType.array, "i16", 0],
  extent: [valueType.array, "i16", 3],
  grid: [valueType.array, "i16", 6],
  cellDims: [valueType.vector, "i16", 9],
  angles: [valueType.array, "i16", 12],
  div: [valueType.singular, "i16", 15],
  adder: [valueType.singular, "i16", 16],
  scaleFactor: [valueType.singular, "i16", 17]
};
var DSN6Model = function(_VolumeModel) {
  _inherits(DSN6Model2, _VolumeModel);
  var _super = _createSuper$g(DSN6Model2);
  function DSN6Model2() {
    _classCallCheck(this, DSN6Model2);
    return _super.apply(this, arguments);
  }
  _createClass(DSN6Model2, [{
    key: "_parseHeader",
    value: function _parseHeader(_buffer) {
      this._buff = _buffer;
      this._typedCheck();
      var arrays = {};
      arrays.i16 = new Int16Array(this._buff);
      if (arrays.i16[18] !== 100) {
        for (var i2 = 0, n2 = arrays.i16.length; i2 < n2; ++i2) {
          var val = arrays.i16[i2];
          arrays.i16[i2] = (val & 255) << 8 | val >> 8 & 255;
        }
      }
      if (arrays.i16[18] !== 100) {
        throw new Error("DSN6: Incorrect format ");
      }
      var header = this._header;
      this._fillHeader(DSN6Header, arrays);
      header.cellDims.multiplyScalar(1 / header.scaleFactor);
      header.angles.forEach(function(angle, i3, a2) {
        a2[i3] *= Math.PI / 180 / header.scaleFactor;
      });
      header.div /= 100;
    }
  }, {
    key: "_setAxisIndices",
    value: function _setAxisIndices() {
      this._xyz2crs[0] = 0;
      this._xyz2crs[1] = 1;
      this._xyz2crs[2] = 2;
    }
  }, {
    key: "_setOrigins",
    value: function _setOrigins() {
      var header = this._header;
      var _this$_getAxis = this._getAxis(), _this$_getAxis2 = _slicedToArray(_this$_getAxis, 3), xaxis = _this$_getAxis2[0], yaxis = _this$_getAxis2[1], zaxis = _this$_getAxis2[2];
      this._setAxisIndices();
      this._origin.addScaledVector(xaxis, header.nstart[0]);
      this._origin.addScaledVector(yaxis, header.nstart[1]);
      this._origin.addScaledVector(zaxis, header.nstart[2]);
      xaxis.multiplyScalar(header.extent[0]);
      yaxis.multiplyScalar(header.extent[1]);
      zaxis.multiplyScalar(header.extent[2]);
      this._setBoxParams(xaxis, yaxis, zaxis);
    }
  }, {
    key: "_pointCalculate",
    value: function _pointCalculate(xyzData, byteBuffer, z2, y2, x2, pos, i2) {
      var header = this._header;
      if (x2 < header.extent[0] && y2 < header.extent[1] && z2 < header.extent[2]) {
        var idx = x2 + header.extent[0] * (y2 + header.extent[1] * z2);
        xyzData[idx] = (byteBuffer[pos.counter] - header.adder) / header.div;
        ++pos.counter;
      } else {
        pos.counter += 8 - i2;
        return false;
      }
      return true;
    }
  }, {
    key: "_blockCalculate",
    value: function _blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos) {
      for (var k2 = 0; k2 < 8; ++k2) {
        var z2 = 8 * zBlock + k2;
        for (var j2 = 0; j2 < 8; ++j2) {
          var y2 = 8 * yBlock + j2;
          var inRange = true;
          var i2 = 0;
          while (inRange && i2 < 8) {
            var x2 = 8 * xBlock + i2;
            inRange = this._pointCalculate(xyzData, byteBuffer, z2, y2, x2, pos, i2);
            i2++;
          }
        }
      }
    }
  }, {
    key: "_toXYZData",
    value: function _toXYZData() {
      var header = this._header;
      var byteBuffer = new Uint8Array(this._buff);
      var xyzData = new Float32Array(header.extent[0] * header.extent[1] * header.extent[2]);
      var blocks = new Vector3(header.extent[0] / 8, header.extent[1] / 8, header.extent[2] / 8);
      var pos = {};
      pos.counter = 512;
      for (var zBlock = 0; zBlock < blocks.z; ++zBlock) {
        for (var yBlock = 0; yBlock < blocks.y; ++yBlock) {
          for (var xBlock = 0; xBlock < blocks.x; ++xBlock) {
            this._blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos);
          }
        }
      }
      this._calculateInfoParams(xyzData);
      return xyzData;
    }
  }, {
    key: "_calculateInfoParams",
    value: function _calculateInfoParams(xyzData) {
      this._header.dmean /= xyzData.length;
      var dispersion = 0;
      var minDensity = xyzData[0];
      var maxDensity = xyzData[0];
      for (var j2 = 0; j2 < xyzData.length; j2++) {
        dispersion += Math.pow(this._header.dmean - xyzData[j2], 2);
        if (xyzData[j2] < minDensity) {
          minDensity = xyzData[j2];
        }
        if (xyzData[j2] > maxDensity) {
          maxDensity = xyzData[j2];
        }
      }
      this._header.sd = Math.sqrt(dispersion / xyzData.length);
      this._header.dmax = maxDensity;
      this._header.dmin = minDensity;
    }
  }]);
  return DSN6Model2;
}(VolumeModel);
var DSN6Parser = function(_Parser) {
  _inherits(DSN6Parser2, _Parser);
  var _super2 = _createSuper$g(DSN6Parser2);
  function DSN6Parser2(data, options2) {
    var _this;
    _classCallCheck(this, DSN6Parser2);
    _this = _super2.call(this, data, options2);
    _this._options.fileType = "dsn6";
    _this.model = new DSN6Model();
    return _this;
  }
  _createClass(DSN6Parser2, [{
    key: "parseSync",
    value: function parseSync() {
      return this.model.parse(this._data);
    }
  }], [{
    key: "canParse",
    value: function canParse(data, options2) {
      if (!data) {
        return false;
      }
      return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options2, "dsn6");
    }
  }, {
    key: "canProbablyParse",
    value: function canProbablyParse(_data) {
      return false;
    }
  }]);
  return DSN6Parser2;
}(Parser);
DSN6Parser.formats = ["dsn6"];
DSN6Parser.extensions = [".dsn6", ".omap"];
DSN6Parser.binary = true;
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var GROReader = function(_PDBStream) {
  _inherits(GROReader2, _PDBStream);
  var _super = _createSuper$f(GROReader2);
  function GROReader2(data) {
    var _this;
    _classCallCheck(this, GROReader2);
    _this = _super.call(this, data);
    _this._next = -1;
    _this.next();
    return _this;
  }
  _createClass(GROReader2, [{
    key: "getNext",
    value: function getNext() {
      return this._next;
    }
  }]);
  return GROReader2;
}(PDBStream);
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex$1 = chem.Complex;
var Element$1 = chem.Element;
var Molecule$2 = chem.Molecule;
var GROParser = function(_Parser) {
  _inherits(GROParser2, _Parser);
  var _super = _createSuper$e(GROParser2);
  function GROParser2(data, options2) {
    var _this;
    _classCallCheck(this, GROParser2);
    _this = _super.call(this, data, options2);
    _this._time = null;
    _this._numAtoms = null;
    _this._residueNumber = null;
    _this._residueName = "";
    _this._atomName = "";
    _this._atomNumber = null;
    _this._atomPosition = [];
    _this._atomVelocity = [];
    _this._complex = null;
    _this._molecules = [];
    _this._molecule = null;
    _this._options.filetype = "gro";
    return _this;
  }
  _createClass(GROParser2, [{
    key: "canProbablyParse",
    value: function canProbablyParse(data) {
      return (0, import_lodash.isString)(this._data) && /^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(data);
    }
  }, {
    key: "_parseTitle",
    value: function _parseTitle(line) {
      var metadata = this._complex.metadata;
      metadata.id = line.readLine().trim();
      metadata.name = metadata.id.slice(metadata.id.lastIndexOf("\\") + 1, metadata.id.lastIndexOf("."));
      metadata.format = "gro";
    }
  }, {
    key: "_parseNumberOfAtoms",
    value: function _parseNumberOfAtoms(line) {
      this._numAtoms = line.readInt(0, line.getNext());
      if (Number.isNaN(this._numAtoms)) {
        throw new Error("Line 2 is not representing atom number. Consider checking input file");
      }
    }
  }, {
    key: "_parseAtom",
    value: function _parseAtom(line) {
      this._residueNumber = line.readInt(1, 5);
      this._residueName = line.readString(6, 10).trim();
      this._atomName = line.readString(11, 15).trim();
      this._atomNumber = line.readInt(16, 20);
      var positionX = line.readFloat(21, 28) * 10;
      var positionY = line.readFloat(29, 36) * 10;
      var positionZ = line.readFloat(37, 45) * 10;
      if (Number.isNaN(positionX) || Number.isNaN(positionY) || Number.isNaN(positionZ)) {
        this._complex.error = {
          message: 'Atom position is invalid in "'.concat(line.readLine(), '"')
        };
        return;
      }
      var type = Element$1.getByName(this._atomName[0]);
      if (type.fullName === "Unknown") {
        this._complex.error = {
          message: "".concat(this._atomName[0], " hasn't been recognised as an atom name.")
        };
        return;
      }
      var role = Element$1.Role[this._atomName];
      var chain2 = this._chain;
      if (!chain2) {
        this._chain = chain2 = this._complex.addChain("A");
      }
      var residue2 = this._residue;
      if (!residue2 || residue2.getSequence() !== this._residueNumber) {
        this._residue = residue2 = chain2.addResidue(this._residueName, this._residueNumber, " ");
      }
      this._atomPosition = new Vector3(positionX, positionY, positionZ);
      var het = true;
      var altLoc = " ";
      var occupancy = 1;
      var tempFactor = 1;
      var charge = 0;
      residue2.addAtom(this._atomName, type, this._atomPosition, role, het, this._atomNumber, altLoc, occupancy, tempFactor, charge);
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      var molecule = new Molecule$2(this._complex, this._complex.metadata.name, 1);
      molecule.residues = this._chain._residues;
      molecule._chains = this._chain;
      this._complex._molecules[0] = molecule;
      this._molecules.push(molecule);
      this._complex.finalize({
        needAutoBonding: true,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing,
        serialAtomMap: this._serialAtomMap
      });
    }
  }, {
    key: "parseSync",
    value: function parseSync() {
      var result = this._complex = new Complex$1();
      var reader = new GROReader(this._data);
      var counter = 0;
      this._parseTitle(reader);
      reader.next();
      this._parseNumberOfAtoms(reader);
      reader.next();
      for (counter = 0; counter < this._numAtoms; ++counter) {
        if (!reader.end()) {
          this._parseAtom(reader);
          reader.next();
        } else break;
      }
      if (counter < this._numAtoms) {
        this._complex.error = {
          message: "File ended unexpectedly."
        };
      }
      if (result.error) {
        throw new Error(result.error.message);
      }
      this._finalize();
      this._atomPosition = null;
      this._complex = null;
      this._molecules = null;
      this._molecule = null;
      return result;
    }
  }]);
  return GROParser2;
}(Parser);
GROParser.formats = ["gro"];
GROParser.extensions = [".gro"];
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Complex = chem.Complex;
var Element2 = chem.Element;
var Bond = chem.Bond;
var Molecule$1 = chem.Molecule;
var orderMap = {
  un: 0,
  1: 1,
  2: 2,
  3: 3,
  ar: 1,
  am: 1,
  nc: 0,
  du: 1
};
var typeMap = {
  un: Bond.BondType.UNKNOWN,
  1: Bond.BondType.COVALENT,
  2: Bond.BondType.COVALENT,
  3: Bond.BondType.COVALENT,
  ar: Bond.BondType.AROMATIC,
  am: Bond.BondType.COVALENT,
  nc: Bond.BondType.UNKNOWN,
  du: Bond.BondType.COVALENT
};
var resNumberRegex = /\d+$/;
var spacesRegex = /\s+/;
function splitToFields(str) {
  return str.trim().split(spacesRegex);
}
var MOL2Parser = function(_Parser) {
  _inherits(MOL2Parser2, _Parser);
  var _super = _createSuper$d(MOL2Parser2);
  function MOL2Parser2(data, options2) {
    var _this;
    _classCallCheck(this, MOL2Parser2);
    _this = _super.call(this, data, options2);
    _this._complex = null;
    _this._chain = null;
    _this._residue = null;
    _this._compoundIndx = -1;
    _this._molecules = [];
    _this._molecule = null;
    _this._currPosIdx = 0;
    _this._currStartIdx = 0;
    _this._serialAtomMap = {};
    _this._options.fileType = "mol2";
    return _this;
  }
  _createClass(MOL2Parser2, [{
    key: "_parseRawStrings",
    value: function _parseRawStrings(data) {
      return data.split(/\r?\n|\r/);
    }
  }, {
    key: "_toStringFromStart",
    value: function _toStringFromStart(numb, MOL2Data) {
      var newPosIdx = this._currStartIdx + numb;
      this._currPosIdx = newPosIdx < MOL2Data.length ? newPosIdx : this._currStartIdx;
    }
  }, {
    key: "_toHeaderString",
    value: function _toHeaderString(header, MOL2Data) {
      this._toStringFromStart(0, MOL2Data);
      while (this._currPosIdx < MOL2Data.length) {
        if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header))) {
          return;
        }
        this._currPosIdx++;
      }
      this._toStringFromStart(0, MOL2Data);
    }
  }, {
    key: "_toStringFromHeader",
    value: function _toStringFromHeader(header, numb, MOL2Data) {
      this._toHeaderString(header, MOL2Data);
      var newPosIdx = this._currPosIdx + numb;
      if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header)) && newPosIdx < MOL2Data.length) {
        this._currPosIdx = newPosIdx;
      }
    }
  }, {
    key: "_setStart",
    value: function _setStart(startPos, MOL2Data) {
      if (startPos >= MOL2Data.length) {
        this._currStartIdx = this._currPosIdx = MOL2Data.length - 1;
      } else {
        this._currStartIdx = this._currPosIdx = startPos;
      }
    }
  }, {
    key: "_probablyHaveDataToParse",
    value: function _probablyHaveDataToParse(MOL2Data) {
      return this._currPosIdx < MOL2Data.length - 2;
    }
  }, {
    key: "_findNextCompoundStart",
    value: function _findNextCompoundStart(MOL2Data) {
      while (this._currPosIdx < MOL2Data.length && MOL2Data[this._currPosIdx].trim() !== "@<TRIPOS>MOLECULE>") {
        this._currPosIdx++;
      }
      this._setStart(++this._currPosIdx, MOL2Data);
      return this._probablyHaveDataToParse(MOL2Data);
    }
  }, {
    key: "_parseMolecule",
    value: function _parseMolecule(MOL2Data) {
      this._toHeaderString("MOLECULE", MOL2Data);
      var metadata = this._complex.metadata;
      metadata.name = MOL2Data[++this._currPosIdx];
      metadata.format = "mol2";
      this._molecule = {
        _index: "",
        _chains: []
      };
      this._molecule._index = this._compoundIndx + 1;
      this._molecules.push(this._molecule);
    }
  }, {
    key: "_parseAtoms",
    value: function _parseAtoms(atomsNum, MOL2Data) {
      this._toHeaderString("ATOM", MOL2Data);
      for (var i2 = 0; i2 < atomsNum; i2++) {
        var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);
        if (parsedStr.length < 6) {
          throw new Error("MOL2 parsing error: Not enough information to create atom!");
        }
        var atomId = parseInt(parsedStr[0], 10);
        var atomName = parsedStr[1];
        var x2 = parseFloat(parsedStr[2]);
        var y2 = parseFloat(parsedStr[3]);
        var z2 = parseFloat(parsedStr[4]);
        var element = parsedStr[5].split(".")[0].toUpperCase();
        var charge = 0;
        if (parsedStr.length >= 9) {
          charge = parseFloat(parsedStr[8]) || 0;
        }
        var chain2 = this._chain;
        if (!chain2) {
          this._chain = chain2 = this._complex.getChain("A") || this._complex.addChain("A");
          this._residue = null;
        }
        if (!this._setResidue(parsedStr)) {
          continue;
        }
        var het = false;
        var altLoc = " ";
        var occupancy = 1;
        var tempFactor = 0;
        var type = Element2.getByName(element);
        var role = Element2.Role[atomName];
        var xyz = new Vector3(x2, y2, z2);
        this._residue.addAtom(atomName, type, xyz, role, het, atomId, altLoc, occupancy, tempFactor, charge);
      }
    }
  }, {
    key: "_setResidue",
    value: function _setResidue(parsedStr) {
      var resSeq = 1;
      var resName = "UNK";
      if (parsedStr.length >= 7) {
        resSeq = parseInt(parsedStr[6], 10);
      }
      if (parsedStr.length >= 8 && parsedStr[7] !== "<0>") {
        resName = parsedStr[7].replace(resNumberRegex, "");
      }
      if (this.settings.now.nowater) {
        if (resName === "HOH" || resName === "WAT") {
          return false;
        }
      }
      var residue2 = this._residue;
      var chain2 = this._chain;
      if (!residue2 || residue2.getSequence() !== resSeq) {
        this._residue = chain2.addResidue(resName, resSeq, "A");
      }
      return true;
    }
  }, {
    key: "_parseBonds",
    value: function _parseBonds(bondsNum, MOL2Data) {
      this._toHeaderString("BOND", MOL2Data);
      for (var i2 = 0; i2 < bondsNum; i2++) {
        var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);
        if (parsedStr.length < 3) {
          throw new Error("MOL2 parsing error: Missing information about bonds!");
        }
        var originAtomId = parseInt(parsedStr[1], 10);
        var targetAtomId = parseInt(parsedStr[2], 10);
        var bondType = parsedStr[3];
        if (originAtomId > targetAtomId) {
          var _ref = [targetAtomId, originAtomId];
          originAtomId = _ref[0];
          targetAtomId = _ref[1];
        }
        this._complex.addBond(originAtomId, targetAtomId, orderMap[bondType] || 0, typeMap[bondType] || Bond.BondType.UNKNOWN, true);
      }
    }
  }, {
    key: "_fixSerialAtoms",
    value: function _fixSerialAtoms() {
      var atoms = this._complex._atoms;
      for (var i2 = 0; i2 < atoms.length; i2++) {
        var atom = atoms[i2];
        this._serialAtomMap[atom.serial] = atom;
      }
    }
  }, {
    key: "_fixBondsArray",
    value: function _fixBondsArray() {
      var serialAtomMap = this._serialAtomMap;
      var complex = this._complex;
      if (Object.keys(serialAtomMap).length === 0) {
        throw new Error("MOL2 parsing error: Missing atom information!");
      }
      var bonds = complex._bonds;
      for (var j2 = 0; j2 < bonds.length; j2++) {
        var bond = bonds[j2];
        bond._left = serialAtomMap[bond._left] || null;
        bond._right = serialAtomMap[bond._right] || null;
      }
    }
  }, {
    key: "_finalizeMolecules",
    value: function _finalizeMolecules() {
      var chain2 = this._complex._chains[0];
      this._complex._molecules = [];
      for (var i2 = 0; i2 < this._molecules.length; i2++) {
        var currMolecule = this._molecules[i2];
        var molResidues = chain2._residues;
        var molecule = new Molecule$1(this._complex, currMolecule._name, i2 + 1);
        molecule.residues = molResidues;
        this._complex._molecules[i2] = molecule;
      }
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      this._complex._finalizeBonds();
      this._fixSerialAtoms();
      this._fixBondsArray();
      this._finalizeMolecules();
      this._complex.finalize({
        needAutoBonding: false,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing,
        serialAtomMap: this._serialAtomMap
      });
    }
  }, {
    key: "_parseCompound",
    value: function _parseCompound(MOL2Data) {
      this._compoundIndx++;
      this._parseMolecule(MOL2Data);
      this._toStringFromHeader("MOLECULE", 2, MOL2Data);
      var parsedStr = MOL2Data[this._currPosIdx].trim().split(spacesRegex);
      var atomsNum = parsedStr[0];
      var bondsNum = parsedStr[1];
      this._parseAtoms(atomsNum, MOL2Data);
      this._parseBonds(bondsNum, MOL2Data);
    }
  }, {
    key: "parseSync",
    value: function parseSync() {
      var result = this._complex = new Complex();
      var MOL2Data = this._parseRawStrings(this._data);
      do {
        this._parseCompound(MOL2Data);
      } while (this._findNextCompoundStart(MOL2Data));
      this._finalize();
      return result;
    }
  }]);
  return MOL2Parser2;
}(Parser);
MOL2Parser.formats = ["mol2"];
MOL2Parser.extensions = [".mol2", ".ml2", ".sy2"];
var parsers = new ParserList([
  PDBParser,
  CIFParser,
  MMTFParser,
  XYZParser,
  CMLParser,
  PubChemParser,
  SDFParser,
  CCP4Parser,
  DSN6Parser,
  GROParser,
  MOL2Parser
]);
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ExporterList = function(_EntityList) {
  _inherits(ExporterList2, _EntityList);
  var _super = _createSuper$c(ExporterList2);
  function ExporterList2() {
    var someExporters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, ExporterList2);
    return _super.call(this, someExporters, ["formats"]);
  }
  _createClass(ExporterList2, [{
    key: "find",
    value: function find2(specs) {
      var list = [];
      if (specs.format) {
        list = this._dict.formats[specs.format.toLowerCase()] || [];
      }
      return _toConsumableArray(list);
    }
  }]);
  return ExporterList2;
}(EntityList);
var Exporter = function() {
  function Exporter2(source, options2) {
    _classCallCheck(this, Exporter2);
    this._source = source;
    this._options = options2 || {};
    this._abort = false;
  }
  _createClass(Exporter2, [{
    key: "exportSync",
    value: function exportSync() {
      throw new Error("Exporting to this source is not implemented");
    }
  }, {
    key: "export",
    value: function _export() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        setTimeout(function() {
          try {
            if (_this._abort) {
              return reject(new Error("Export aborted"));
            }
            return resolve(_this.exportSync());
          } catch (error) {
            return reject(error);
          }
        });
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._abort = true;
    }
  }]);
  return Exporter2;
}();
makeContextDependent(Exporter.prototype);
var PDBResult = function() {
  function PDBResult2() {
    _classCallCheck(this, PDBResult2);
    this._resultArray = [];
    this._currentStr = -1;
    this._tag = null;
    this._fixedNumeration = false;
    this._numeration = false;
    this._tagStrNum = 0;
  }
  _createClass(PDBResult2, [{
    key: "getResult",
    value: function getResult() {
      this.writeString("\n", 81, 81);
      return this._resultArray.join("");
    }
  }, {
    key: "_currentStrLength",
    value: function _currentStrLength() {
      var curStr = this._resultArray[this._currentStr];
      return curStr ? curStr.length : 0;
    }
  }, {
    key: "newTag",
    value: function newTag(tag, numeration) {
      if (!tag) {
        this._tag = null;
      } else {
        this._tag = tag;
      }
      if (!(0, import_lodash.isUndefined)(numeration)) {
        if ((0, import_lodash.isNumber)(numeration)) {
          this._tagStrNum = numeration;
          this._numeration = true;
          this._fixedNumeration = true;
        } else if ((0, import_lodash.isBoolean)(numeration)) {
          this._tagStrNum = 0;
          this._numeration = numeration;
          this._fixedNumeration = false;
        }
      } else {
        this._numeration = false;
        this._fixedNumeration = false;
        this._tagStrNum = 0;
      }
    }
  }, {
    key: "newString",
    value: function newString(tag) {
      this.writeString("\n", 81, 81);
      this._currentStr++;
      this._resultArray.push("");
      if (tag) {
        this.writeString(tag, 1, 6);
      } else if (this._tag) {
        this.writeString(this._tag, 1, 6);
      }
      if (this._numeration) {
        if (!this._fixedNumeration) {
          this._tagStrNum++;
        }
        if (this._tagStrNum !== 1) {
          this.writeString(this._tagStrNum.toString(), 10, 8);
        }
      }
    }
  }, {
    key: "writeEntireString",
    value: function writeEntireString(string5, maxStrPos, concat) {
      if (!maxStrPos) {
        maxStrPos = 81;
      }
      for (var j2 = 0; j2 < string5.length; j2++) {
        if (this._currentStrLength() === maxStrPos && j2 !== string5.length - 1) {
          this.newString();
          if (concat) {
            this.writeString(concat.tag, concat.begin, concat.end);
          }
        }
        if (string5[j2] === "\n") {
          this.newString();
        } else {
          this.writeString(string5[j2]);
        }
      }
    }
  }, {
    key: "writeString",
    value: function writeString(string5, begin, end) {
      var curStr = this._resultArray[this._currentStr];
      var str;
      var curStrLength = curStr ? curStr.length : 0;
      if ((0, import_lodash.isUndefined)(string5)) {
        return;
      }
      if (!(0, import_lodash.isNumber)(begin)) {
        begin = curStrLength + 1;
      }
      if (!(0, import_lodash.isNumber)(end)) {
        end = curStrLength + string5.length;
      }
      if (!(0, import_lodash.isString)(string5)) {
        str = string5.toString();
      } else {
        str = string5;
      }
      var finish = begin < end ? end : begin;
      var start = begin < end ? begin : end;
      if (str.length > Math.abs(begin - end) + 1) {
        str = str.substr(0, Math.abs(begin - end + 1));
      }
      if (start > curStrLength + 1) {
        this._resultArray[this._currentStr] += " ".repeat(start - curStrLength - 1);
      } else if (start <= curStrLength) {
        var cStr = this._resultArray[this._currentStr];
        this._resultArray[this._currentStr] = cStr.slice(0, start - 1);
      }
      if (end < begin) {
        var len = begin - end + 1;
        str = " ".repeat(len - str.length) + str;
      }
      if (start === 11 && this._numeration && this._tagStrNum !== 1) {
        str = " ".concat(str);
      }
      this._resultArray[this._currentStr] += str;
      curStr = this._resultArray[this._currentStr];
      if (finish > curStr.length) {
        this._resultArray[this._currentStr] += " ".repeat(finish - curStr.length);
      }
    }
  }, {
    key: "writeBondsArray",
    value: function writeBondsArray(bonds, atom) {
      var bondsArrays = this._getSubArrays(bonds, 4);
      for (var k2 = 0; k2 < bondsArrays.length; k2++) {
        this.newString();
        this.writeString(atom.serial, 11, 7);
        for (var j2 = 0; j2 < bondsArrays[k2].length; j2++) {
          var serial2 = bondsArrays[k2][j2]._left.serial === atom.serial ? bondsArrays[k2][j2]._right.serial : bondsArrays[k2][j2]._left.serial;
          this.writeString(serial2, 16 + 5 * j2, 12 + 5 * j2);
        }
      }
    }
  }, {
    key: "_getSubArrays",
    value: function _getSubArrays(arr, subArraySize) {
      var subArrays = [];
      for (var i2 = 0; i2 < arr.length; i2 += subArraySize) {
        subArrays.push(arr.slice(i2, i2 + subArraySize));
      }
      return subArrays;
    }
  }, {
    key: "writeMatrix",
    value: function writeMatrix(matrix, matrixIndx, tag) {
      for (var j2 = 0; j2 < 3; j2++) {
        this.newString();
        this.writeString(tag, 14, 18);
        this.writeString((j2 + 1).toString(), 19, 19);
        this.writeString(matrixIndx.toString(), 23, 20);
        for (var k2 = 0; k2 < 3; k2++) {
          var _numb = parseFloat(matrix.elements[j2 * 4 + k2]).toFixed(6);
          this.writeString(_numb.toString(), 33 + k2 * 10, 24 + k2 * 10);
        }
        var numb = parseFloat(matrix.elements[j2 * 4 + 3]).toFixed(5);
        this.writeString(numb.toString(), 68, 55);
      }
    }
  }, {
    key: "writeMatrices",
    value: function writeMatrices(matrices, string5) {
      if (!matrices) {
        return;
      }
      var matrix = new Matrix4();
      for (var j2 = 0; j2 < matrices.length; j2++) {
        matrix.copy(matrices[j2]).transpose();
        this.writeMatrix(matrix, j2 + 1, string5);
      }
    }
  }]);
  return PDBResult2;
}();
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var PDBExporter = function(_Exporter) {
  _inherits(PDBExporter2, _Exporter);
  var _super = _createSuper$b(PDBExporter2);
  function PDBExporter2(source, options2) {
    var _this;
    _classCallCheck(this, PDBExporter2);
    _this = _super.call(this, source, options2);
    _this._tags = ["HEADER", "TITLE", "COMPND", "REMARK", "HELIX", "SHEET", "ATOM and HETATM", "CONECT"];
    _this._result = null;
    _this._tagExtractors = {
      HEADER: _this._extractHEADER,
      TITLE: _this._extractTITLE,
      "ATOM and HETATM": _this._extractATOM,
      CONECT: _this._extractCONECT,
      COMPND: _this._extractCOMPND,
      REMARK: _this._extractREMARK,
      HELIX: _this._extractHELIX,
      SHEET: _this._extractSHEET
    };
    _this._stringForRemark350 = "COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\nBIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\nMOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\nGIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\nCRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.";
    _this._stringForRemark290 = "CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\nTHE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\nRECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\nRELATED MOLECULES.";
    return _this;
  }
  _createClass(PDBExporter2, [{
    key: "exportSync",
    value: function exportSync() {
      var result = new PDBResult();
      if (!this._source) {
        return this._result;
      }
      for (var i2 = 0; i2 < this._tags.length; i2++) {
        var tag = this._tags[i2];
        var func3 = this._tagExtractors[tag];
        if (typeof func3 === "function") {
          func3.call(this, result);
        }
      }
      this._result = result.getResult();
      return this._result;
    }
  }, {
    key: "_extractHEADER",
    value: function _extractHEADER(result) {
      if (!this._source.metadata) {
        return;
      }
      var metadata = this._source.metadata;
      result.newTag("HEADER");
      result.newString();
      if (metadata.classification) {
        result.writeString(metadata.classification, 11, 50);
      }
      if (metadata.date) {
        result.writeString(metadata.date, 51, 59);
      }
      if (metadata.id) {
        result.writeString(metadata.id, 63, 66);
      }
    }
  }, {
    key: "_extractTITLE",
    value: function _extractTITLE(result) {
      if (!this._source.metadata) {
        return;
      }
      var metadata = this._source.metadata;
      if (!metadata.title) {
        return;
      }
      result.newTag("TITLE", true);
      for (var i2 = 0; i2 < metadata.title.length; i2++) {
        result.newString();
        result.writeString(metadata.title[i2], 11, 80);
      }
    }
  }, {
    key: "_extractCONECT",
    value: function _extractCONECT(result) {
      if (!this._source._atoms) {
        return;
      }
      var atoms = this._source._atoms;
      result.newTag("CONECT");
      for (var i2 = 0; i2 < atoms.length; i2++) {
        var fixedBonds = atoms[i2].bonds.filter(function(bond) {
          return bond._fixed;
        });
        if (fixedBonds.length !== 0) {
          result.writeBondsArray(fixedBonds.reverse(), atoms[i2]);
        }
      }
    }
  }, {
    key: "_extractSHEET",
    value: function _extractSHEET(result) {
      if (!this._source._sheets) {
        return;
      }
      result.newTag("SHEET");
      var sheets = this._source._sheets;
      for (var i2 = 0; i2 < sheets.length; i2++) {
        if (sheets[i2]._strands) {
          var strands = sheets[i2]._strands;
          for (var j2 = 0; j2 < strands.length; j2++) {
            result.newString();
            result.writeString(j2 + 1, 10, 8);
            result.writeString(sheets[i2]._name, 14, 12);
            result.writeString(strands.length, 16, 15);
            result.writeString(strands[j2].init._type._name, 18, 20);
            result.writeString(strands[j2].init._chain._name, 22, 22);
            result.writeString(strands[j2].init._sequence, 26, 23);
            result.writeString(strands[j2].init._icode, 27, 27);
            result.writeString(strands[j2].term._type._name, 29, 31);
            result.writeString(strands[j2].init._chain._name, 33, 33);
            result.writeString(strands[j2].term._sequence, 37, 34);
            result.writeString(strands[j2].term._icode, 38, 38);
            result.writeString(strands[j2].sense, 40, 39);
          }
        }
      }
    }
  }, {
    key: "_extractHELIX",
    value: function _extractHELIX(result) {
      if (!this._source._helices) {
        return;
      }
      result.newTag("HELIX");
      var helices = this._source._helices;
      for (var i2 = 0; i2 < helices.length; i2++) {
        var helix = helices[i2];
        var helixClass = (0, import_lodash.invert)(typeByPDBHelixClass);
        result.newString();
        result.writeString(helix.serial, 10, 8);
        result.writeString(helix.name, 14, 12);
        result.writeString(helix.init._type._name, 16, 18);
        result.writeString(helix.init._chain._name, 20, 20);
        result.writeString(helix.init._sequence, 25, 22);
        result.writeString(helix.init._icode, 26, 26);
        result.writeString(helix.term._type._name, 28, 30);
        result.writeString(helix.term._chain._name, 32, 32);
        result.writeString(helix.term._sequence, 37, 34);
        result.writeString(helix.term._icode, 38, 38);
        result.writeString(helixClass[helix.type], 40, 39);
        result.writeString(helix.comment, 41, 70);
        result.writeString(helix.length, 76, 72);
      }
    }
  }, {
    key: "_extractATOM",
    value: function _extractATOM(result) {
      if (!this._source._atoms) {
        return;
      }
      var atoms = this._source._atoms;
      for (var i2 = 0; i2 < atoms.length; i2++) {
        var tag = atoms[i2].het ? "HETATM" : "ATOM";
        result.newString(tag);
        var startIndx = atoms[i2].element.name.length > 1 || atoms[i2].name.length > 3 ? 13 : 14;
        result.writeString(atoms[i2].serial, 11, 7);
        result.writeString(atoms[i2].name, startIndx, 16);
        result.writeString(String.fromCharCode(atoms[i2].location), 17, 17);
        result.writeString(atoms[i2].residue._type._name, 20, 18);
        result.writeString(atoms[i2].residue._chain._name, 22, 22);
        result.writeString(atoms[i2].residue._sequence, 26, 23);
        result.writeString(atoms[i2].residue._icode, 27, 27);
        result.writeString(atoms[i2].position.x.toFixed(3), 38, 31);
        result.writeString(atoms[i2].position.y.toFixed(3), 46, 39);
        result.writeString(atoms[i2].position.z.toFixed(3), 54, 47);
        result.writeString(atoms[i2].occupancy.toFixed(2), 60, 55);
        result.writeString(atoms[i2].temperature.toFixed(2), 66, 61);
        result.writeString(atoms[i2].element.name, 78, 77);
        if (atoms[i2].charge) {
          result.writeString(atoms[i2].charge, 79, 80);
        }
      }
    }
  }, {
    key: "_extractCOMPND",
    value: function _extractCOMPND(result) {
      if (!this._source._molecules) {
        return;
      }
      var molecules = this._source._molecules;
      result.newTag("COMPND", true);
      for (var i2 = 0; i2 < molecules.length; i2++) {
        var chains = this._getMoleculeChains(molecules[i2]);
        result.newString();
        result.writeString("MOL_ID: ".concat(molecules[i2].index, ";"), 11, 80);
        result.newString();
        result.writeString("MOLECULE: ".concat(molecules[i2].name, ";"), 11, 80);
        result.newString();
        result.writeString("CHAIN: ", 11, 18);
        var chainsString = "".concat(chains.join(", "), ";");
        result.writeEntireString(chainsString, 81);
      }
    }
  }, {
    key: "_extractREMARK",
    value: function _extractREMARK(result) {
      this._Remark290(result);
      this._Remark350(result);
    }
  }, {
    key: "_Remark290",
    value: function _Remark290(result) {
      if (!this._source.symmetry) {
        return;
      }
      if (this._source.symmetry.length !== 0) {
        var matrices = this._source.symmetry;
        result.newTag("REMARK", 290);
        result.newString();
        result.newString();
        result.writeEntireString(this._stringForRemark290);
        result.writeMatrices(matrices, "SMTRY");
        result.newString();
        result.newString();
        result.writeString("REMARK: NULL", 11, 80);
      }
    }
  }, {
    key: "_Remark350",
    value: function _Remark350(result) {
      if (!this._source.units) {
        return;
      }
      var units = this._source.units;
      var biomolIndx = 0;
      result.newTag("REMARK", 350);
      result.newString();
      result.newString();
      result.writeEntireString(this._stringForRemark350);
      var assemblies = units.filter(function(unit) {
        return unit instanceof Assembly$3;
      });
      for (var i2 = 0; i2 < assemblies.length; i2++) {
        result.newString();
        result.newString();
        biomolIndx++;
        result.writeString("BIOMOLECULE: ".concat(biomolIndx), 11, 80);
        var chains = assemblies[i2].chains.join(", ");
        result.newString();
        result.writeString("APPLY THE FOLLOWING TO CHAINS: ");
        result.writeEntireString(chains, 69, {
          tag: "AND CHAINS: ",
          begin: 31,
          end: 42
        });
        var matrices = assemblies[i2].matrices;
        result.writeMatrices(matrices, "BIOMT");
      }
    }
  }, {
    key: "_getMoleculeChains",
    value: function _getMoleculeChains(molecule) {
      function getChainName(residue2) {
        return residue2._chain._name;
      }
      var chainNames = molecule.residues.map(getChainName);
      return chainNames.filter(function(item, pos) {
        return chainNames.indexOf(item) === pos;
      });
    }
  }]);
  return PDBExporter2;
}(Exporter);
PDBExporter.formats = ["pdb"];
PDBExporter.SourceClass = Complex$9;
var FBX_POS_SIZE = 3;
var FBX_NORM_SIZE = 3;
var FBX_COL_SIZE = 4;
function copyFbxPoint3(src, srcIdx, dst, dstIdx) {
  dst[dstIdx] = src[srcIdx];
  dst[dstIdx + 1] = src[srcIdx + 1];
  dst[dstIdx + 2] = src[srcIdx + 2];
}
function copyFbxPoint4(src, srcIdx, dst, dstIdx, value) {
  dst[dstIdx] = src[srcIdx];
  dst[dstIdx + 1] = src[srcIdx + 1];
  dst[dstIdx + 2] = src[srcIdx + 2];
  dst[dstIdx + 3] = value;
}
var vector4 = new Vector4();
function copyTransformedPoint3(src, srcIdx, dst, dstIdx, opts) {
  vector4.set(src[srcIdx], src[srcIdx + 1], src[srcIdx + 2], opts.w);
  vector4.applyMatrix4(opts.matrix);
  dst[dstIdx] = vector4.x;
  dst[dstIdx + 1] = vector4.y;
  dst[dstIdx + 2] = vector4.z;
}
function setSubArray(src, dst, count, copyFunctor, functorOpts) {
  if ((dst.array.length - dst.start) / dst.stride < count || (src.array.length - src.start) / src.stride < count) {
    return;
  }
  if (src.stride === dst.stride) {
    dst.array.set(src.array, dst.start);
  } else {
    var idx = dst.start;
    var arridx = src.start;
    for (var i2 = 0; i2 < count; ++i2, idx += dst.stride, arridx += src.stride) {
      copyFunctor(src.array, arridx, dst.array, idx, functorOpts);
    }
  }
}
var FBXModel = function() {
  function FBXModel2() {
    _classCallCheck(this, FBXModel2);
    this.positions = null;
    this.normals = null;
    this.colors = null;
    this.indices = null;
    this.lastPos = 0;
    this.lastNorm = 0;
    this.lastCol = 0;
    this.lastIdx = 0;
  }
  _createClass(FBXModel2, [{
    key: "init",
    value: function init2(vertsCount, indsCount) {
      this.positions = new Float32Array(vertsCount * FBX_POS_SIZE);
      this.normals = new Float32Array(vertsCount * FBX_NORM_SIZE);
      this.colors = new Float32Array(vertsCount * FBX_COL_SIZE);
      this.indices = new Int32Array(indsCount);
    }
  }, {
    key: "setPositions",
    value: function setPositions(array4, start, count, stride) {
      var src = {
        array: array4,
        start,
        stride
      };
      var dst = {
        array: this.positions,
        start: this.lastPos,
        stride: FBX_POS_SIZE
      };
      setSubArray(src, dst, count, copyFbxPoint3);
      this.lastPos += count * FBX_POS_SIZE;
    }
  }, {
    key: "setTransformedPositions",
    value: function setTransformedPositions(array4, start, count, stride, matrix) {
      var idx = this.lastPos;
      var arrIdx = start;
      var opts = {
        matrix,
        w: 1
      };
      for (var i2 = 0; i2 < count; ++i2, arrIdx += stride, idx += FBX_POS_SIZE) {
        copyTransformedPoint3(array4, arrIdx, this.positions, idx, opts);
      }
      this.lastPos += count * FBX_POS_SIZE;
    }
  }, {
    key: "setNormals",
    value: function setNormals(array4, start, count, stride) {
      var src = {
        array: array4,
        start,
        stride
      };
      var dst = {
        array: this.normals,
        start: this.lastNorm,
        stride: FBX_NORM_SIZE
      };
      setSubArray(src, dst, count, copyFbxPoint3);
      this.lastNorm += count * FBX_NORM_SIZE;
    }
  }, {
    key: "setTransformedNormals",
    value: function setTransformedNormals(array4, start, count, stride, matrix) {
      var idx = this.lastNorm;
      var arrIdx = start;
      var opts = {
        matrix,
        w: 0
      };
      for (var i2 = 0; i2 < count; ++i2, arrIdx += stride, idx += FBX_NORM_SIZE) {
        copyTransformedPoint3(array4, arrIdx, this.normals, idx, opts);
      }
      this.lastNorm += count * FBX_NORM_SIZE;
    }
  }, {
    key: "setColors",
    value: function setColors(array4, start, count, stride) {
      var src = {
        array: array4,
        start,
        stride
      };
      var dst = {
        array: this.colors,
        start: this.lastCol,
        stride: FBX_COL_SIZE
      };
      setSubArray(src, dst, count, copyFbxPoint4, 1);
      this.lastCol += count * FBX_COL_SIZE;
    }
  }, {
    key: "setIndices",
    value: function setIndices(array4, start, count) {
      this.indices.set(array4, this.lastIdx);
      this.lastIdx += count;
    }
  }, {
    key: "setShiftedIndices",
    value: function setShiftedIndices(array4, count, shift) {
      var shifted = array4.map(function(x2) {
        return x2 + shift;
      });
      this.setIndices(shifted, 0, count);
    }
  }, {
    key: "getVerticesNumber",
    value: function getVerticesNumber() {
      return this.lastPos / FBX_POS_SIZE;
    }
  }, {
    key: "addInstance",
    value: function addInstance(matrix, geo) {
      var currentCount = this.getVerticesNumber();
      this.setShiftedIndices(geo.indices, geo.indices.length, currentCount);
      var size = geo.itemSize;
      this.setTransformedPositions(geo.positions, 0, geo.vertsCount, size.position, matrix);
      this.setTransformedNormals(geo.normals, 0, geo.vertsCount, size.normal, matrix);
      this.setColors(geo.colors, 0, geo.vertsCount, size.color);
    }
  }]);
  return FBXModel2;
}();
var FBXGeometry = function() {
  function FBXGeometry2() {
    _classCallCheck(this, FBXGeometry2);
    this.positions = null;
    this.normals = null;
    this.colors = null;
    this.indices = null;
    this.vertsCount = 0;
    this.itemSize = null;
  }
  _createClass(FBXGeometry2, [{
    key: "init",
    value: function init2(geo, _info) {
      var attributes = geo.attributes;
      this.itemSize = {
        position: attributes.position.itemSize,
        normal: attributes.normal.itemSize,
        color: attributes.color.itemSize
      };
    }
  }]);
  return FBXGeometry2;
}();
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var FBX1CGeometry = function(_FBXGeometry) {
  _inherits(FBX1CGeometry2, _FBXGeometry);
  var _super = _createSuper$a(FBX1CGeometry2);
  function FBX1CGeometry2() {
    _classCallCheck(this, FBX1CGeometry2);
    return _super.apply(this, arguments);
  }
  _createClass(FBX1CGeometry2, [{
    key: "init",
    value: function init2(geo, _info) {
      _get(_getPrototypeOf(FBX1CGeometry2.prototype), "init", this).call(this, geo, _info);
      var _geo$attributes = geo.attributes, position = _geo$attributes.position, normal = _geo$attributes.normal, index = geo.index;
      this.vertsCount = position.count;
      this.positions = position.array;
      this.normals = normal.array;
      this.colors = new Float32Array(this.vertsCount * this.itemSize.color);
      this.indices = index.array;
    }
  }, {
    key: "setColors",
    value: function setColors(color2) {
      var offset = 0;
      for (var i2 = 0, l2 = this.colors.length, cl = this.itemSize.color; i2 < l2; i2 += cl) {
        this.colors[offset++] = color2.r;
        this.colors[offset++] = color2.g;
        this.colors[offset++] = color2.b;
      }
    }
  }]);
  return FBX1CGeometry2;
}(FBXGeometry);
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var FBX2CCylinder = function(_FBXGeometry) {
  _inherits(FBX2CCylinder2, _FBXGeometry);
  var _super = _createSuper$9(FBX2CCylinder2);
  function FBX2CCylinder2() {
    var _this;
    _classCallCheck(this, FBX2CCylinder2);
    _this = _super.call(this);
    _this._cutRawStart = 0;
    _this._cutRawEnd = 0;
    _this._facesPerSlice = 0;
    return _this;
  }
  _createClass(FBX2CCylinder2, [{
    key: "init",
    value: function init2(geo, info) {
      _get(_getPrototypeOf(FBX2CCylinder2.prototype), "init", this).call(this, geo, info);
      var position = geo.attributes.position, index = geo.index;
      this.vertsCount = position.count + info.addPerCylinder;
      this._facesPerSlice = info.addPerCylinder;
      this.positions = new Float32Array(this.vertsCount * position.itemSize);
      this.normals = new Float32Array(this.vertsCount * this.itemSize.normal);
      this.colors = new Float32Array(this.vertsCount * this.itemSize.color);
      this._extendVertices(geo, info);
      this.indices = new Uint32Array(index.count);
      this._extendIndices(geo, info);
    }
  }, {
    key: "_extendVertices",
    value: function _extendVertices(geo, info) {
      var position = geo.attributes.position;
      var normal = geo.attributes.normal;
      var geoParams = geo.getGeoParams();
      var cutRaw = 1;
      this._cutRawStart = cutRaw * geoParams.radialSegments;
      this._cutRawEnd = this._cutRawStart + info.addPerCylinder;
      {
        var temp = position.array.slice(0, this._cutRawEnd * position.itemSize);
        this.positions.set(temp, 0);
        temp = normal.array.slice(0, this._cutRawEnd * normal.itemSize);
        this.normals.set(temp, 0);
      }
      {
        var _temp = position.array.slice(this._cutRawStart * position.itemSize, position.array.length);
        this.positions.set(_temp, this._cutRawEnd * position.itemSize);
        _temp = normal.array.slice(this._cutRawStart * normal.itemSize, normal.array.length);
        this.normals.set(_temp, this._cutRawEnd * normal.itemSize);
      }
    }
  }, {
    key: "_extendIndices",
    value: function _extendIndices(geo, info) {
      var index = geo.index;
      var indicesPerQuad = 6;
      var startToShift = info.addPerCylinder * indicesPerQuad;
      var shift = info.addPerCylinder;
      var shifted = index.array.slice(startToShift, index.count);
      shifted = shifted.map(function(x2) {
        return x2 + shift;
      });
      this.indices.set(index.array, 0);
      this.indices.set(shifted, startToShift);
    }
  }, {
    key: "_setColorRange",
    value: function _setColorRange(start, end, array4, color2) {
      var colorSize = color2.length;
      for (var i2 = start; i2 < end; i2 += colorSize) {
        array4.set(color2, i2);
      }
    }
  }, {
    key: "setColors",
    value: function setColors(color1, color2) {
      var colorSize = this.itemSize.color;
      var part1End = this._cutRawEnd * colorSize;
      var part2End = part1End * 2;
      this._setColorRange(0, part1End, this.colors, color1.toArray());
      this._setColorRange(part1End, part2End, this.colors, color2.toArray());
      if (part2End < this.colors.length) {
        var capSize = (this._facesPerSlice + 1) * colorSize;
        var cap1End = part2End + capSize;
        this._setColorRange(part2End, cap1End, this.colors, color2.toArray());
        var cap2End = cap1End + capSize;
        this._setColorRange(cap1End, cap2End, this.colors, color1.toArray());
      }
    }
  }]);
  return FBX2CCylinder2;
}(FBXGeometry);
var FBXInfoExtractor = function() {
  function FBXInfoExtractor2() {
    _classCallCheck(this, FBXInfoExtractor2);
    this._materials = [];
    this._models = [];
  }
  _createClass(FBXInfoExtractor2, [{
    key: "process",
    value: function process2(data) {
      this._extractModelsAndMaterials(data);
      var models = this._flattenModels();
      return {
        name: data.name,
        models,
        materials: this._materials
      };
    }
  }, {
    key: "_extractModelsAndMaterials",
    value: function _extractModelsAndMaterials(data) {
      var _this = this;
      var layersOfInterest = new Layers();
      layersOfInterest.set(gfxutils.LAYERS.DEFAULT);
      layersOfInterest.enable(gfxutils.LAYERS.TRANSPARENT);
      data.traverse(function(object4) {
        if (object4 instanceof Mesh && object4.layers.test(layersOfInterest) && _this.checkExportAbility(object4)) {
          if (object4.geometry.type === "InstancedBufferGeometry") {
            _this._collectInstancedGeoInfo(object4);
          } else {
            _this._collectGeoInfo(object4);
          }
        }
      });
    }
  }, {
    key: "_reworkIndices",
    value: function _reworkIndices(indices) {
      var faceSize = 3;
      for (var i2 = faceSize - 1; i2 < indices.length; i2 += faceSize) {
        indices[i2] *= -1;
        indices[i2]--;
      }
    }
  }, {
    key: "_flattenModels",
    value: function _flattenModels() {
      var overallVertsCount = 0;
      function shift(x2) {
        return x2 + overallVertsCount;
      }
      var combined = [];
      for (var i2 = 0, n2 = this._models.length; i2 < n2; i2++) {
        var models = this._models[i2];
        var indices = [];
        var positions = [];
        var normals = [];
        var colors = [];
        overallVertsCount = 0;
        for (var j2 = 0; j2 < models.length; j2++) {
          var m2 = models[j2];
          indices.push(m2.indices.map(shift));
          overallVertsCount += m2.getVerticesNumber();
          positions.push(m2.positions);
          normals.push(m2.normals);
          colors.push(m2.colors);
        }
        indices = utils.mergeTypedArraysUnsafe(indices);
        this._reworkIndices(indices);
        positions = utils.mergeTypedArraysUnsafe(positions);
        normals = utils.mergeTypedArraysUnsafe(normals);
        colors = utils.mergeTypedArraysUnsafe(colors);
        combined.push({
          indices,
          positions,
          normals,
          colors,
          verticesCount: overallVertsCount
        });
      }
      return combined;
    }
  }, {
    key: "checkExportAbility",
    value: function checkExportAbility(mesh) {
      if (mesh.geometry.attributes.position.count === 0) {
        return false;
      }
      if (mesh instanceof ZSpriteMesh) {
        logger.warn("Currently we cannot export 'sprites' modes, like BS, WV, LC. Please turn of settings 'zSprites' and try again");
        return false;
      }
      if (mesh instanceof ThickLineMesh) {
        logger.warn("Currently we cannot export Lines mode");
        return false;
      }
      return true;
    }
  }, {
    key: "_collectGeoInfo",
    value: function _collectGeoInfo(mesh) {
      var _mesh$geometry = mesh.geometry, _mesh$geometry$attrib = _mesh$geometry.attributes, position = _mesh$geometry$attrib.position, color2 = _mesh$geometry$attrib.color, normal = _mesh$geometry$attrib.normal, index = _mesh$geometry.index, matrix = mesh.matrix;
      var model = new FBXModel();
      var vertCount = position.count;
      model.init(vertCount, index.count);
      if (matrix.isIdentity()) {
        model.setPositions(position.array, 0, vertCount, position.itemSize);
        model.setNormals(normal.array, 0, vertCount, normal.itemSize);
      } else {
        model.setTransformedPositions(position.array, 0, vertCount, position.itemSize, matrix);
        model.setTransformedNormals(normal.array, 0, vertCount, normal.itemSize, matrix);
      }
      model.setColors(color2.array, 0, vertCount, color2.itemSize);
      model.setIndices(index.array, 0, index.count);
      var material2 = this._collectMaterialInfo(mesh);
      this._addToPool(model, material2);
    }
  }, {
    key: "_collectSpheresInfo",
    value: function _collectSpheresInfo(mesh) {
      var _mesh$geometry2 = mesh.geometry, _mesh$geometry2$attri = _mesh$geometry2.attributes, position = _mesh$geometry2$attri.position, color2 = _mesh$geometry2$attri.color, index = _mesh$geometry2.index, matrix = mesh.matrix;
      var model = new FBXModel();
      var instCount = mesh.geometry.instanceCount;
      var vertCount = position.count;
      var indsCount = index.count;
      model.init(instCount * vertCount, instCount * indsCount);
      var geo = new FBX1CGeometry();
      geo.init(mesh.geometry);
      var instMatrix = new Matrix4();
      var objMatrix = new Matrix4();
      var sphereColor = new Color();
      for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
        var colorIdx = instanceIndex * color2.itemSize;
        sphereColor.fromArray(color2.array, colorIdx);
        geo.setColors(sphereColor);
        this._getSphereInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);
        objMatrix.multiplyMatrices(matrix, instMatrix);
        model.addInstance(objMatrix, geo);
      }
      var material2 = this._collectMaterialInfo(mesh);
      this._addToPool(model, material2);
    }
  }, {
    key: "_collectCylindersInfo",
    value: function _collectCylindersInfo(mesh) {
      var _mesh$geometry3 = mesh.geometry, _mesh$geometry3$attri = _mesh$geometry3.attributes, position = _mesh$geometry3$attri.position, color2 = _mesh$geometry3$attri.color, color22 = _mesh$geometry3$attri.color2, index = _mesh$geometry3.index, matrix = mesh.matrix;
      var model = new FBXModel();
      var instCount = mesh.geometry.instanceCount;
      var oneCCylinder = new FBX1CGeometry();
      oneCCylinder.init(mesh.geometry);
      var splittingInfo = this._gatherCylindersColoringInfo(mesh.geometry);
      var twoCCylinder = null;
      if (splittingInfo.needToSplit > 0) {
        twoCCylinder = new FBX2CCylinder();
        twoCCylinder.init(mesh.geometry, splittingInfo);
      }
      var additionalVertsCount = splittingInfo.addPerCylinder * splittingInfo.needToSplit;
      var vertCount = position.count;
      var indsCount = index.count;
      model.init(instCount * vertCount + additionalVertsCount, instCount * indsCount);
      var instMatrix = new Matrix4();
      var objMatrix = new Matrix4();
      var colorStart = new Color();
      var colorEnd = new Color();
      var geo = {};
      for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
        var colorIdx = instanceIndex * color2.itemSize;
        if (splittingInfo.is2Colored[instanceIndex]) {
          colorStart.fromArray(color22.array, colorIdx);
          colorEnd.fromArray(color2.array, colorIdx);
          if (twoCCylinder) {
            twoCCylinder.setColors(colorStart, colorEnd);
            geo = twoCCylinder;
          }
        } else {
          colorStart.fromArray(color2.array, colorIdx);
          oneCCylinder.setColors(colorStart);
          geo = oneCCylinder;
        }
        this._getCylinderInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);
        objMatrix.multiplyMatrices(matrix, instMatrix);
        model.addInstance(objMatrix, geo);
      }
      var material2 = this._collectMaterialInfo(mesh);
      this._addToPool(model, material2);
    }
  }, {
    key: "_addToPool",
    value: function _addToPool(model, material2) {
      var materialIdx = this._checkExistingMaterial(material2);
      if (materialIdx < 0) {
        this._models.push([model]);
        this._materials.push(material2);
      } else {
        var models = this._models[materialIdx];
        models.push(model);
      }
    }
  }, {
    key: "_checkExistingMaterial",
    value: function _checkExistingMaterial(material2) {
      return (0, import_lodash.findIndex)(this._materials, function(m2) {
        return (0, import_lodash.isEqual)(m2, material2);
      });
    }
  }, {
    key: "_gatherCylindersColoringInfo",
    value: function _gatherCylindersColoringInfo(geo) {
      var instCount = geo.instanceCount;
      var color1 = geo.attributes.color.array;
      var color2 = geo.attributes.color2.array;
      var stride = geo.attributes.color.itemSize;
      var is2Colored = new Array(instCount);
      var needToSplit = 0;
      var colIdx = 0;
      for (var i2 = 0; i2 < instCount; i2++, colIdx += stride) {
        var differs = Math.abs(color1[colIdx] - color2[colIdx]) > 1e-7 || Math.abs(color1[colIdx + 1] - color2[colIdx + 1]) > 1e-7 || Math.abs(color1[colIdx + 2] - color2[colIdx + 2]) > 1e-7;
        is2Colored[i2] = differs;
        needToSplit += differs;
      }
      var geoParams = geo.getGeoParams();
      var addPerCylinder = geoParams.radialSegments;
      return {
        is2Colored,
        needToSplit,
        addPerCylinder
      };
    }
  }, {
    key: "_collectInstancedGeoInfo",
    value: function _collectInstancedGeoInfo(mesh) {
      if (mesh.geometry instanceof InstancedSpheresGeometry) {
        this._collectSpheresInfo(mesh);
      } else if (mesh.geometry instanceof Instanced2CCylindersGeometry) {
        this._collectCylindersInfo(mesh);
      }
    }
  }, {
    key: "_collectMaterialInfo",
    value: function _collectMaterialInfo(mesh) {
      var uberOptions2 = mesh.material.uberOptions;
      return {
        diffuse: uberOptions2.diffuse.toArray(),
        opacity: uberOptions2.opacity,
        shininess: uberOptions2.shininess,
        specular: uberOptions2.specular.toArray()
      };
    }
  }, {
    key: "_getCylinderInstanceMatrix",
    value: function _getCylinderInstanceMatrix(geo, instIdx, matrix) {
      var matVector1 = geo.attributes.matVector1.array;
      var matVector2 = geo.attributes.matVector2.array;
      var matVector3 = geo.attributes.matVector3.array;
      var idxOffset = instIdx * 4;
      matrix.set(matVector1[idxOffset], matVector1[idxOffset + 1], matVector1[idxOffset + 2], matVector1[idxOffset + 3], matVector2[idxOffset], matVector2[idxOffset + 1], matVector2[idxOffset + 2], matVector2[idxOffset + 3], matVector3[idxOffset], matVector3[idxOffset + 1], matVector3[idxOffset + 2], matVector3[idxOffset + 3], 0, 0, 0, 1);
    }
  }, {
    key: "_getSphereInstanceMatrix",
    value: function _getSphereInstanceMatrix(geo, instIdx, matrix) {
      var offset = geo.attributes.offset;
      var idx = instIdx * offset.itemSize;
      var x2 = offset.array[idx];
      var y2 = offset.array[idx + 1];
      var z2 = offset.array[idx + 2];
      var scale = offset.array[idx + 3];
      matrix.set(scale, 0, 0, x2, 0, scale, 0, y2, 0, 0, scale, z2, 0, 0, 0, 1);
    }
  }]);
  return FBXInfoExtractor2;
}();
var defaultDefinitions = '\nDefinitions:  {\n  Version: 100\n  Count: 3\n  ObjectType: "Model" {\n    Count: 1\n  }\n  ObjectType: "Geometry" {\n    Count: 1\n  }\n  ObjectType: "Material" {\n    Count: 1\n  }\n  ObjectType: "Pose" {\n    Count: 1\n  }\n  ObjectType: "GlobalSettings" {\n    Count: 1\n  }\n} ';
var defaultProperties = 'Properties60: {\n      Property: "QuaternionInterpolate", "bool", "",0\n      Property: "Visibility", "Visibility", "A",1\n      Property: "Lcl Translation", "Lcl Translation", "A",0.000000000000000,0.000000000000000,-1789.238037109375000\n      Property: "Lcl Rotation", "Lcl Rotation", "A",0.000009334667643,-0.000000000000000,0.000000000000000\n      Property: "Lcl Scaling", "Lcl Scaling", "A",1.000000000000000,1.000000000000000,1.000000000000000\n      Property: "RotationOffset", "Vector3D", "",0,0,0\n      Property: "RotationPivot", "Vector3D", "",0,0,0\n      Property: "ScalingOffset", "Vector3D", "",0,0,0\n      Property: "ScalingPivot", "Vector3D", "",0,0,0\n      Property: "TranslationActive", "bool", "",0\n      Property: "TranslationMin", "Vector3D", "",0,0,0\n      Property: "TranslationMax", "Vector3D", "",0,0,0\n      Property: "TranslationMinX", "bool", "",0\n      Property: "TranslationMinY", "bool", "",0\n      Property: "TranslationMinZ", "bool", "",0\n      Property: "TranslationMaxX", "bool", "",0\n      Property: "TranslationMaxY", "bool", "",0\n      Property: "TranslationMaxZ", "bool", "",0\n      Property: "RotationOrder", "enum", "",0\n      Property: "RotationSpaceForLimitOnly", "bool", "",0\n      Property: "AxisLen", "double", "",10\n      Property: "PreRotation", "Vector3D", "",0,0,0\n      Property: "PostRotation", "Vector3D", "",0,0,0\n      Property: "RotationActive", "bool", "",0\n      Property: "RotationMin", "Vector3D", "",0,0,0\n      Property: "RotationMax", "Vector3D", "",0,0,0\n      Property: "RotationMinX", "bool", "",0\n      Property: "RotationMinY", "bool", "",0\n      Property: "RotationMinZ", "bool", "",0\n      Property: "RotationMaxX", "bool", "",0\n      Property: "RotationMaxY", "bool", "",0\n      Property: "RotationMaxZ", "bool", "",0\n      Property: "RotationStiffnessX", "double", "",0\n      Property: "RotationStiffnessY", "double", "",0\n      Property: "RotationStiffnessZ", "double", "",0\n      Property: "MinDampRangeX", "double", "",0\n      Property: "MinDampRangeY", "double", "",0\n      Property: "MinDampRangeZ", "double", "",0\n      Property: "MaxDampRangeX", "double", "",0\n      Property: "MaxDampRangeY", "double", "",0\n      Property: "MaxDampRangeZ", "double", "",0\n      Property: "MinDampStrengthX", "double", "",0\n      Property: "MinDampStrengthY", "double", "",0\n      Property: "MinDampStrengthZ", "double", "",0\n      Property: "MaxDampStrengthX", "double", "",0\n      Property: "MaxDampStrengthY", "double", "",0\n      Property: "MaxDampStrengthZ", "double", "",0\n      Property: "PreferedAngleX", "double", "",0\n      Property: "PreferedAngleY", "double", "",0\n      Property: "PreferedAngleZ", "double", "",0\n      Property: "InheritType", "enum", "",0\n      Property: "ScalingActive", "bool", "",0\n      Property: "ScalingMin", "Vector3D", "",1,1,1\n      Property: "ScalingMax", "Vector3D", "",1,1,1\n      Property: "ScalingMinX", "bool", "",0\n      Property: "ScalingMinY", "bool", "",0\n      Property: "ScalingMinZ", "bool", "",0\n      Property: "ScalingMaxX", "bool", "",0\n      Property: "ScalingMaxY", "bool", "",0\n      Property: "ScalingMaxZ", "bool", "",0\n      Property: "GeometricTranslation", "Vector3D", "",0,0,0\n      Property: "GeometricRotation", "Vector3D", "",0,0,0\n      Property: "GeometricScaling", "Vector3D", "",1,1,1\n      Property: "LookAtProperty", "object", ""\n      Property: "UpVectorProperty", "object", ""\n      Property: "Show", "bool", "",1\n      Property: "NegativePercentShapeSupport", "bool", "",1\n      Property: "DefaultAttributeIndex", "int", "",0\n      Property: "Color", "Color", "A+",0,0,0\n      Property: "Size", "double", "",100\n      Property: "Look", "enum", "",1\n    }';
var defaultMaterialLayer = '\n    LayerElementMaterial: 0 {\n      Version: 101\n      Name: ""\n      MappingInformationType: "AllSame"\n      ReferenceInformationType: "Direct"\n      Materials: 0\n    }';
var defaultLayerBlock = '\n    Layer: 0 {\n      Version: 100\n      LayerElement:  {\n        Type: "LayerElementNormal"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: "LayerElementColor"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: "LayerElementMaterial"\n        TypedIndex: 0\n      }\n    }';
var globalSettings = 'GlobalSettings: {\n    Version: 1000\n    Properties60:  {\n      Property: "UpAxis", "int", "",1\n      Property: "UpAxisSign", "int", "",1\n      Property: "FrontAxis", "int", "",2\n      Property: "FrontAxisSign", "int", "",1\n      Property: "CoordAxis", "int", "",0\n      Property: "CoordAxisSign", "int", "",1\n      Property: "UnitScaleFactor", "double", "",1\n    }\n  }';
var FBXResult = function() {
  function FBXResult2() {
    _classCallCheck(this, FBXResult2);
    this._resultArray = [];
    this._info = null;
  }
  _createClass(FBXResult2, [{
    key: "getResult",
    value: function getResult(info) {
      this._info = info;
      this._resultArray.push(this._writeHeader());
      this._resultArray.push(this._writeDefinitions());
      this._resultArray.push(this._writeObjects(info.models, info.materials));
      this._resultArray.push(this._writeRelations());
      this._resultArray.push(this._writeConnections());
      this._info = null;
      return this._resultArray.join("");
    }
  }, {
    key: "_writeHeader",
    value: function _writeHeader() {
      var FBXHeaderVersion = 1003;
      var FBXVersion = 6100;
      var date = /* @__PURE__ */ new Date();
      var timeStampVersion = 1e3;
      var creator = "Miew FBX Exporter v".concat(this._info.version);
      return "; FBX 6.1.0 project file\n; Created by ".concat(creator, " Copyright (c) 2015-2020 EPAM Systems, Inc.\n; For support please contact miew@epam.com\n; ----------------------------------------------------\n\nFBXHeaderExtension:  {\n  FBXHeaderVersion: ").concat(FBXHeaderVersion, "\n  FBXVersion: ").concat(FBXVersion, "\n  CreationTimeStamp:  {\n    Version: ").concat(timeStampVersion, "\n    Year: ").concat(date.getFullYear(), "\n    Month: ").concat(date.getMonth() + 1, " \n    Day: ").concat(date.getDate(), "\n    Hour: ").concat(date.getHours(), "\n    Minute: ").concat(date.getMinutes(), "\n    Second: ").concat(date.getSeconds(), "\n    Millisecond: ").concat(date.getMilliseconds(), '\n  }\n  Creator: "').concat(creator, '"\n  OtherFlags:  {\n    FlagPLE: 0\n  }\n}\nCreationTime: "').concat(date, '"\nCreator: "').concat(creator, '"  \n');
    }
  }, {
    key: "_writeDefinitions",
    value: function _writeDefinitions() {
      return "\n; Object definitions\n;------------------------------------------------------------------\n\n".concat(defaultDefinitions, "\n");
    }
  }, {
    key: "_models",
    value: function _models() {
      var modelVersion = 232;
      var allModels = "";
      var models = this._info.models;
      for (var i2 = 0; i2 < models.length; ++i2) {
        var model = models[i2];
        var vertCount = model.verticesCount;
        allModels += '\n  Model: "Model::'.concat(this._info.name, "_").concat(i2, '", "Mesh" {\n    Version: ').concat(modelVersion, " \n    ").concat(defaultProperties, "\n    ").concat(this._verticesIndices(model.positions, model.indices), "\n    ").concat(this._normalLayer(model.normals), " \n    ").concat(this._colorLayer(model.colors, vertCount), " \n    ").concat(defaultMaterialLayer, "  \n    ").concat(defaultLayerBlock, "\n  }");
      }
      return allModels;
    }
  }, {
    key: "_materials",
    value: function _materials() {
      var materialVersion = 102;
      var allMaterials = "";
      var materials2 = this._info.materials;
      for (var i2 = 0; i2 < materials2.length; ++i2) {
        var material2 = materials2[i2];
        allMaterials += '\n  Material: "Material::'.concat(this._info.name, "_").concat(i2, '_default", "" {\n    Version: ').concat(materialVersion, '\n    ShadingModel: "lambert"\n    MultiLayer: 0\n    ').concat(this._materialProperties(material2), "\n  }");
      }
      return allMaterials;
    }
  }, {
    key: "_writeObjects",
    value: function _writeObjects() {
      return "\n; Object properties\n;------------------------------------------------------------------\n\nObjects:  {\n  ".concat(this._models(), "\n  ").concat(this._materials(), "\n  ").concat(globalSettings, "\n}\n");
    }
  }, {
    key: "_writeRelations",
    value: function _writeRelations() {
      var modelsList = "";
      for (var i2 = 0; i2 < this._info.models.length; ++i2) {
        modelsList += '\n  Model: "Model::'.concat(this._info.name, "_").concat(i2, '", "Mesh" {\n  }');
      }
      var materialList2 = "";
      for (var _i = 0; _i < this._info.materials.length; ++_i) {
        materialList2 += '\n  Material: "Material::'.concat(this._info.name, "_").concat(_i, '_default", "" {\n  }');
      }
      return "\n; Object relations\n;------------------------------------------------------------------\n\nRelations:  {\n  ".concat(modelsList, '\n  Model: "Model::Producer Perspective", "Camera" {\n  }\n  Model: "Model::Producer Top", "Camera" {\n  }\n  Model: "Model::Producer Bottom", "Camera" {\n  }\n  Model: "Model::Producer Front", "Camera" {\n  }\n  Model: "Model::Producer Back", "Camera" {\n  }\n  Model: "Model::Producer Right", "Camera" {\n  }\n  Model: "Model::Producer Left", "Camera" {\n  }\n  Model: "Model::Camera Switcher", "CameraSwitcher" {\n  }\n  ').concat(materialList2, "\n}");
    }
  }, {
    key: "_writeConnections",
    value: function _writeConnections() {
      var modelsList = "";
      var name2 = this._info.name;
      for (var i2 = 0; i2 < this._info.models.length; ++i2) {
        modelsList += '\n  Connect: "OO", "Model::'.concat(name2, "_").concat(i2, '", "Model::Scene"');
      }
      var materialList2 = "";
      for (var _i2 = 0; _i2 < this._info.materials.length; ++_i2) {
        materialList2 += '\n  Connect: "OO", "Material::'.concat(name2, "_").concat(_i2, '_default", "Model::').concat(name2, "_").concat(_i2, '"');
      }
      return "\n; Object connections\n;------------------------------------------------------------------\n\nConnections:  {\n  ".concat(modelsList, "\n  ").concat(materialList2, "\n}");
    }
  }, {
    key: "_floatArrayToString",
    value: function _floatArrayToString(array4) {
      var str = [];
      for (var i2 = 0; i2 < array4.length; ++i2) {
        str[i2] = array4[i2].toFixed(6);
      }
      return str.join(",");
    }
  }, {
    key: "_colorLayer",
    value: function _colorLayer(colorArray, vertCount) {
      var layerElementColorNumber = 0;
      var layerElementColorVersion = 101;
      var layerElementColorName = "";
      var colorsStr = this._floatArrayToString(colorArray);
      var colorIndices = _toConsumableArray(Array(vertCount).keys());
      return "\n    LayerElementColor: ".concat(layerElementColorNumber, " {\n      Version: ").concat(layerElementColorVersion, '\n      Name: "').concat(layerElementColorName, '"\n      MappingInformationType: "ByVertice"\n      ReferenceInformationType: "Direct"\n      Colors: ').concat(colorsStr, "\n      ColorIndex: ").concat(colorIndices, "\n    }");
    }
  }, {
    key: "_normalLayer",
    value: function _normalLayer(normalArray) {
      var layerElementNormalNumber = 0;
      var layerElementNormalVersion = 101;
      var layerElementNormalName = "";
      var normalsStr = this._floatArrayToString(normalArray);
      return "\n    LayerElementNormal: ".concat(layerElementNormalNumber, " {\n      Version: ").concat(layerElementNormalVersion, '\n      Name: "').concat(layerElementNormalName, '"\n      MappingInformationType: "ByVertice"\n      ReferenceInformationType: "Direct" \n      Normals: ').concat(normalsStr, "\n    }");
    }
  }, {
    key: "_verticesIndices",
    value: function _verticesIndices(positions, indices) {
      var multiLayer = 0;
      var multiTake = 1;
      var shading = "Y";
      var culling = "CullingOff";
      var geometryVersion = 124;
      var vertStr = this._floatArrayToString(positions);
      return "MultiLayer: ".concat(multiLayer, "\n    MultiTake: ").concat(multiTake, "\n    Shading: ").concat(shading, '\n    Culling: "').concat(culling, '"\n    Vertices: ').concat(vertStr, "\n    PolygonVertexIndex: ").concat(indices, "\n    GeometryVersion: ").concat(geometryVersion);
    }
  }, {
    key: "_materialProperties",
    value: function _materialProperties(material2) {
      return 'Properties60:  {\n      Property: "ShadingModel", "KString", "", "Lambert"\n      Property: "MultiLayer", "bool", "",0\n      Property: "EmissiveColor", "ColorRGB", "",0,0,0\n      Property: "EmissiveFactor", "double", "",0.0000\n      Property: "AmbientColor", "ColorRGB", "",1,1,1\n      Property: "AmbientFactor", "double", "",0.0000\n      Property: "DiffuseColor", "ColorRGB", "",'.concat(material2.diffuse, '\n      Property: "DiffuseFactor", "double", "",1.0000\n      Property: "Bump", "Vector3D", "",0,0,0\n      Property: "TransparentColor", "ColorRGB", "",1,1,1\n      Property: "TransparencyFactor", "double", "",0.0000\n      Property: "SpecularColor", "ColorRGB", "",').concat(material2.specular, '\n      Property: "SpecularFactor", "double", "",1.0000\n      Property: "ShininessExponent", "double", "",').concat(material2.shininess, '\n      Property: "ReflectionColor", "ColorRGB", "",0,0,0\n      Property: "ReflectionFactor", "double", "",1\n      Property: "Ambient", "ColorRGB", "",1,1,1\n      Property: "Diffuse", "ColorRGB", "",').concat(material2.diffuse, '\n      Property: "Specular", "ColorRGB", "",').concat(material2.specular, '\n      Property: "Shininess", "double", "",').concat(material2.shininess, '\n      Property: "Opacity", "double", "",').concat(material2.opacity, '\n      Property: "Reflectivity", "double", "",0\n    }');
    }
  }]);
  return FBXResult2;
}();
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var FBXExporter = function(_Exporter) {
  _inherits(FBXExporter2, _Exporter);
  var _super = _createSuper$8(FBXExporter2);
  function FBXExporter2(source, options2) {
    var _this;
    _classCallCheck(this, FBXExporter2);
    _this = _super.call(this, source, options2);
    _this._data = source;
    _this._version = options2.miewVersion || "0.0-UNSPECIFIED";
    _this._extractor = new FBXInfoExtractor();
    return _this;
  }
  _createClass(FBXExporter2, [{
    key: "exportSync",
    value: function exportSync() {
      var result = new FBXResult();
      if (!this._source) {
        return this._result;
      }
      var info = this._extractor.process(this._data);
      info.version = this._version;
      this._result = result.getResult(info);
      return this._result;
    }
  }]);
  return FBXExporter2;
}(Exporter);
FBXExporter.formats = ["fbx"];
FBXExporter.SourceClass = ComplexVisual;
var exporters = new ExporterList([PDBExporter, FBXExporter]);
var io = {
  loaders,
  parsers,
  exporters
};
var tempColor = new Color();
var CSS2DRenderer = function() {
  function CSS2DRenderer2() {
    _classCallCheck(this, CSS2DRenderer2);
    this._width = 0;
    this._height = 0;
    this._widthHalf = 0;
    this._heightHalf = 0;
    this._vector = new Vector3();
    this._viewMatrix = new Matrix4();
    this._projectionMatrix = new Matrix4();
    this._domElement = document.createElement("div");
    this._domElement.style.overflow = "hidden";
    this._domElement.style.position = "absolute";
    this._domElement.style.top = "0";
    this._domElement.style.zIndex = "0";
    this._domElement.style.pointerEvents = "none";
  }
  _createClass(CSS2DRenderer2, [{
    key: "getElement",
    value: function getElement() {
      return this._domElement;
    }
  }, {
    key: "reset",
    value: function reset2() {
      var myNode = this.getElement();
      while (myNode.firstChild) {
        myNode.removeChild(myNode.firstChild);
      }
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this._width = width;
      this._height = height;
      this._widthHalf = this._width / 2;
      this._heightHalf = this._height / 2;
      this._domElement.style.width = "".concat(width, "px");
      this._domElement.style.height = "".concat(height, "px");
    }
  }, {
    key: "_renderObject",
    value: function _renderObject(object4, camera, scene) {
      function lerpColorAsHex(a2, b2, t2) {
        tempColor.setHex(a2);
        tempColor.lerp(b2, t2);
        return "#".concat(tempColor.getHexString());
      }
      function colorAsHex(a2) {
        tempColor.setHex(a2);
        return "#".concat(tempColor.getHexString());
      }
      if (object4 instanceof CSS2DObject) {
        this._vector.setFromMatrixPosition(object4.matrixWorld);
        if (object4.userData !== void 0 && object4.userData.offset !== void 0) {
          var localOffset = new Vector3(object4.userData.offset.x, object4.userData.offset.y, 0);
          this._vector.add(localOffset.multiplyScalar(object4.matrixWorld.getMaxScaleOnAxis()));
        }
        this._vector.applyMatrix4(this._viewMatrix);
        var visibility = this._vector.z > -camera.near ? "hidden" : "visible";
        var zIndex = 1e4 * (camera.far - -this._vector.z) / (camera.far - camera.near);
        var element = object4.getElement();
        if (typeof scene.fog === "undefined") {
          element.style.color = colorAsHex(object4.userData.color);
          if (object4.userData.background !== "transparent") {
            element.style.background = colorAsHex(object4.userData.background);
          }
        } else {
          var fogFactor = MathUtils.smoothstep(-this._vector.z, scene.fog.near, scene.fog.far);
          element.style.color = lerpColorAsHex(object4.userData.color, scene.fog.color, fogFactor);
          if (object4.userData.background !== "transparent") {
            element.style.background = lerpColorAsHex(object4.userData.background, scene.fog.color, fogFactor);
          }
        }
        this._vector.applyMatrix4(this._projectionMatrix);
        var style = "".concat(object4.userData !== {} ? object4.userData.translation : "translate(-50%, -50%) ", "translate(").concat(this._vector.x * this._widthHalf + this._widthHalf, "px,").concat(-this._vector.y * this._heightHalf + this._heightHalf, "px)");
        element.style.visibility = visibility;
        element.style.WebkitTransform = style;
        element.style.MozTransform = style;
        element.style.oTransform = style;
        element.style.transform = style;
        element.style.zIndex = Number(zIndex).toFixed(0);
        if (element.parentNode !== this._domElement) {
          this._domElement.appendChild(element);
        }
      }
      for (var i2 = 0, l2 = object4.children.length; i2 < l2; i2++) {
        this._renderObject(object4.children[i2], camera, scene);
      }
    }
  }, {
    key: "render",
    value: function render(scene, camera) {
      scene.updateMatrixWorld();
      if (camera.parent === null) {
        camera.updateMatrixWorld();
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      this._viewMatrix.copy(camera.matrixWorldInverse);
      this._projectionMatrix.copy(camera.projectionMatrix);
      this._renderObject(scene, camera, scene);
    }
  }]);
  return CSS2DRenderer2;
}();
var VK_LEFT = 37;
var VK_UP = 38;
var VK_RIGHT = 39;
var VK_DOWN = 40;
var STATE = {
  NONE: -1,
  ROTATE: 0,
  TRANSLATE: 1,
  SCALE: 2,
  TRANSLATE_PIVOT: 3
};
var FULL_STOP_THRESHOLD = 0.1;
var quaternion = new Quaternion();
var matrix4 = new Matrix4();
function ObjectHandler(objects, camera, pivot, options2) {
  this.objects = objects;
  var _objects = _slicedToArray(objects, 1);
  this.object = _objects[0];
  this.camera = camera;
  this.pivot = pivot;
  this.axis = new Vector3(0, 0, 1);
  this.options = options2;
  this.lastRotation = {
    axis: new Vector3(),
    angle: 0
  };
}
ObjectHandler.prototype._rotate = function() {
  var p2 = new Vector3();
  var q2 = new Quaternion();
  var s2 = new Vector3();
  var m2 = new Matrix4();
  return function(quat) {
    var zeroPivot = this.pivot.x === 0 && this.pivot.y === 0 && this.pivot.z === 0;
    m2.copy(this.object.matrix);
    if (zeroPivot) {
      m2.multiply(matrix4.makeRotationFromQuaternion(quat));
    } else {
      m2.multiply(matrix4.makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
      m2.multiply(matrix4.makeRotationFromQuaternion(quat));
      m2.multiply(matrix4.makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
    }
    m2.decompose(p2, q2, s2);
    if (!zeroPivot) {
      for (var i2 = 0; i2 < this.objects.length; ++i2) {
        this.objects[i2].position.copy(p2);
      }
    }
    for (var j2 = 0; j2 < this.objects.length; ++j2) {
      this.objects[j2].quaternion.copy(q2);
      this.objects[j2].updateMatrix();
    }
  };
}();
ObjectHandler.prototype.setObjects = function(objects) {
  this.objects = objects;
  var _objects2 = _slicedToArray(objects, 1);
  this.object = _objects2[0];
};
ObjectHandler.prototype.rotate = function() {
  var rot = {
    axis: new Vector3(),
    angle: 0
  };
  return function(quat, mousePrevPos, mouseCurPos, aboutAxis) {
    this.mouse2rotation(rot, mousePrevPos, mouseCurPos, aboutAxis);
    quat.setFromAxisAngle(rot.axis, rot.angle);
    if (rot.angle) {
      this._rotate(quat);
    }
    this.lastRotation = rot;
  };
}();
ObjectHandler.prototype.translate = function() {
  var dir = new Vector3();
  var pivot = new Vector3();
  return function(delta) {
    dir.set(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
    var dist = dir.length();
    dir.normalize();
    dir.transformDirection(matrix4.copy(this.object.matrixWorld).invert());
    pivot.copy(this.pivot);
    this.object.localToWorld(pivot);
    dist *= Math.abs(pivot.z - this.camera.position.z);
    dist /= this.object.matrixWorld.getMaxScaleOnAxis();
    for (var i2 = 0; i2 < this.objects.length; ++i2) {
      this.objects[i2].translateOnAxis(dir, dist);
    }
  };
}();
ObjectHandler.prototype.update = function() {
  var axis = new Vector3();
  return function(timeSinceLastUpdate, timeSinceMove) {
    if (settings$1.now.autoRotation !== 0) {
      if (settings$1.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0) {
        axis.set(0, 1, 0).transformDirection(matrix4.copy(this.object.matrixWorld).invert());
      } else {
        axis.copy(this.lastRotation.axis);
      }
      this._rotate(quaternion.setFromAxisAngle(axis, settings$1.now.autoRotation * timeSinceLastUpdate));
      return true;
    }
    if (this.options.intertia && this.lastRotation.angle) {
      var angle = this.lastRotation.angle * Math.pow(1 - this.options.dynamicDampingFactor, 40 * timeSinceMove);
      if (Math.abs(angle) <= this.options.intertiaThreshold) {
        this.lastRotation.angle = 0;
      } else {
        this._rotate(quaternion.setFromAxisAngle(this.lastRotation.axis, angle));
        return true;
      }
    }
    return false;
  };
}();
ObjectHandler.prototype.stop = function() {
  this.lastRotation.angle = 0;
};
ObjectHandler.prototype.mouse2rotation = function() {
  var center = new Vector3();
  var eye = new Vector3();
  var eyeDirection = new Vector3();
  var cameraUpDirection = new Vector3();
  var cameraSidewaysDirection = new Vector3();
  var moveDirection = new Vector3();
  var mouseDelta = new Vector2();
  return function(rot, mousePrev, mouseCur, aboutAxis) {
    if (aboutAxis) {
      rot.axis.copy(this.axis);
      rot.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);
    } else {
      mouseDelta.subVectors(mouseCur, mousePrev);
      var angle = mouseDelta.length();
      if (angle === 0) {
        return;
      }
      center.copy(this.pivot);
      this.object.localToWorld(center);
      eye.subVectors(this.camera.position, center);
      eyeDirection.copy(eye).normalize();
      cameraUpDirection.copy(this.camera.up).normalize();
      cameraSidewaysDirection.crossVectors(cameraUpDirection, eyeDirection).normalize();
      cameraUpDirection.setLength(mouseDelta.y);
      cameraSidewaysDirection.setLength(mouseDelta.x);
      moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection));
      rot.axis.crossVectors(moveDirection, eye);
      rot.angle = -angle * this.options.rotateFactor;
    }
    rot.axis.transformDirection(matrix4.copy(this.object.matrixWorld).invert());
    if (rot.angle < 0) {
      rot.axis.negate();
      rot.angle = -rot.angle;
    }
  };
}();
function ObjectControls(object4, objectPivot, camera, domElement, getAltObj) {
  EventDispatcher2.call(this);
  var self2 = this;
  this.object = object4;
  this.objectPivot = objectPivot;
  this.camera = camera;
  this.domElement = typeof domElement !== "undefined" ? domElement : document;
  this.getAltObj = getAltObj;
  this.enabled = true;
  this.hotkeysEnabled = true;
  this.screen = {
    left: 0,
    top: 0,
    width: 0,
    height: 0
  };
  this.options = {
    rotateFactor: Math.PI,
    axisRotateFactor: 4 * Math.PI,
    intertia: true,
    dynamicDampingFactor: 0.1,
    intertiaThreshold: 1e-3
  };
  this._state = STATE.NONE;
  this._mousePrevPos = new Vector2();
  this._mouseCurPos = new Vector2();
  this._mainObj = new ObjectHandler([this.object], this.camera, new Vector3(0, 0, 0), this.options);
  this._altObj = new ObjectHandler([this.object], this.camera, new Vector3(0, 0, 0), this.options);
  this._affectedObj = this._mainObj;
  this._isAltObjFreeRotationAllowed = true;
  this._isTranslationAllowed = true;
  this._isKeysTranslatingObj = false;
  this._pressedKeys = [];
  this._clock = new Timer();
  this._clock.start();
  this._lastUpdateTime = this._clock.getElapsedTime();
  this._listeners = [{
    obj: self2.domElement,
    type: "mousedown",
    handler: function handler(e2) {
      self2.mousedown(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mouseup",
    handler: function handler(e2) {
      self2.mouseup(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mousemove",
    handler: function handler(e2) {
      self2.mousemove(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mousewheel",
    handler: function handler(e2) {
      self2.mousewheel(e2);
    }
  }, {
    obj: self2.domElement,
    type: "DOMMouseScroll",
    handler: function handler(e2) {
      self2.mousewheel(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mouseout",
    handler: function handler(e2) {
      self2.mouseup(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchstart",
    handler: function handler(e2) {
      self2.touchstartend(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchend",
    handler: function handler(e2) {
      self2.touchstartend(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchmove",
    handler: function handler(e2) {
      self2.touchmove(e2);
    }
  }, {
    obj: self2.getKeyBindObject(),
    type: "keydown",
    handler: function handler(e2) {
      self2.keydownup(e2);
    }
  }, {
    obj: self2.getKeyBindObject(),
    type: "keyup",
    handler: function handler(e2) {
      self2.keydownup(e2);
    }
  }, {
    obj: window,
    type: "resize",
    handler: function handler() {
      self2.handleResize();
    }
  }, {
    obj: window,
    type: "blur",
    handler: function handler() {
      self2.resetKeys();
    }
  }, {
    obj: self2.domElement,
    type: "contextmenu",
    handler: function handler(e2) {
      self2.contextmenu(e2);
    }
  }];
  for (var i2 = 0; i2 < this._listeners.length; i2++) {
    var l2 = this._listeners[i2];
    l2.obj.addEventListener(l2.type, l2.handler);
  }
  this.handleResize();
  this.resetKeys();
  this.update();
}
ObjectControls.prototype = Object.create(EventDispatcher2.prototype);
ObjectControls.prototype.constructor = ObjectControls;
ObjectControls.prototype.resetKeys = function() {
  this._pressedKeys[VK_LEFT] = false;
  this._pressedKeys[VK_UP] = false;
  this._pressedKeys[VK_RIGHT] = false;
  this._pressedKeys[VK_DOWN] = false;
};
ObjectControls.prototype.contextmenu = function(e2) {
  e2.stopPropagation();
  e2.preventDefault();
};
ObjectControls.prototype.handleResize = function() {
  if (this.domElement === document) {
    this.screen.left = 0;
    this.screen.top = 0;
    this.screen.width = window.innerWidth;
    this.screen.height = window.innerHeight;
  } else {
    var box = this.domElement.getBoundingClientRect();
    var d2 = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d2.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d2.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
};
ObjectControls.prototype.enable = function(enable) {
  this.enabled = enable;
};
ObjectControls.prototype.enableHotkeys = function(enable) {
  this.hotkeysEnabled = enable;
};
ObjectControls.prototype.allowTranslation = function(allow) {
  this._isTranslationAllowed = allow;
};
ObjectControls.prototype.allowAltObjFreeRotation = function(allow) {
  this._isAltObjFreeRotationAllowed = allow;
};
ObjectControls.prototype.keysTranslateObj = function(on2) {
  this._isKeysTranslatingObj = on2;
};
ObjectControls.prototype.isEditingAltObj = function() {
  return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
};
ObjectControls.prototype.convertMouseToOnCircle = function(coords, pageX, pageY) {
  var screenSize = Math.min(this.screen.width, this.screen.height);
  if (screenSize === 0) {
    coords.set(0, 0);
    return;
  }
  coords.set((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
};
ObjectControls.prototype.convertMouseToViewport = function(coords, pageX, pageY) {
  if (this.screen.width === 0 || this.screen.height === 0) {
    coords.set(0, 0);
    return;
  }
  coords.set(2 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
};
ObjectControls.prototype.stop = function() {
  this._mainObj.stop();
  this._altObj.stop();
};
ObjectControls.prototype.rotateByMouse = function() {
  var quat = new Quaternion();
  return function(aboutZAxis) {
    this._affectedObj.rotate(quat, this._mousePrevPos, this._mouseCurPos, aboutZAxis);
    this.dispatchEvent({
      type: "change",
      action: "rotate",
      quaternion: quat
    });
  };
}();
ObjectControls.prototype.rotate = function(quat) {
  this.object.quaternion.multiply(quat);
  this.dispatchEvent({
    type: "change",
    action: "rotate",
    quaternion: quat
  });
};
ObjectControls.prototype.getOrientation = function() {
  return this.object.quaternion;
};
ObjectControls.prototype.setOrientation = function(quat) {
  this.object.quaternion.copy(quat);
};
ObjectControls.prototype.translate = function() {
  var delta = new Vector2();
  return function() {
    delta.subVectors(this._mouseCurPos, this._mousePrevPos);
    this._affectedObj.translate(delta);
    this.dispatchEvent({
      type: "change",
      action: "translate"
    });
  };
}();
ObjectControls.prototype.getScale = function() {
  return this.object.scale.x;
};
ObjectControls.prototype.setScale = function(scale) {
  this.object.scale.set(scale, scale, scale);
};
ObjectControls.prototype.scale = function(factor) {
  if (factor <= 0) {
    return;
  }
  this.setScale(this.object.scale.x * factor);
  this.dispatchEvent({
    type: "change",
    action: "zoom",
    factor
  });
};
ObjectControls.prototype.update = function() {
  var shift = new Vector2();
  return function() {
    var curTime = this._clock.getElapsedTime();
    var timeSinceLastUpdate = curTime - this._lastUpdateTime;
    if (this._state === STATE.NONE) {
      var timeSinceMove = curTime - this._lastMouseMoveTime;
      if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
        this.dispatchEvent({
          type: "change",
          action: "auto"
        });
      }
    }
    if (this._isKeysTranslatingObj) {
      var speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
      var speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);
      if (speedX !== 0 || speedY !== 0) {
        var delta = timeSinceLastUpdate;
        var altObj = this.getAltObj();
        if (altObj.objects.length > 0) {
          this._altObj.setObjects(altObj.objects);
          this._altObj.pivot = altObj.pivot;
          if ("axis" in altObj) {
            this._altObj.axis = altObj.axis.clone();
          } else {
            this._altObj.axis.set(0, 0, 1);
          }
          shift.set(delta * speedX, delta * speedY);
          this._altObj.translate(shift);
          this.dispatchEvent({
            type: "change",
            action: "translate"
          });
        }
      }
    }
    this._lastUpdateTime = curTime;
  };
}();
ObjectControls.prototype.reset = function() {
  this._state = STATE.NONE;
  this.object.quaternion.copy(quaternion.set(0, 0, 0, 1));
};
ObjectControls.prototype.mousedown = function(event) {
  if (this.enabled === false || this._state !== STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  if (this._state === STATE.NONE) {
    if (event.button === 0) {
      this._affectedObj.stop();
      var workWithAltObj = false;
      if (event.altKey) {
        var altObj = this.getAltObj();
        workWithAltObj = altObj.objects.length > 0;
        if (workWithAltObj) {
          this._altObj.setObjects(altObj.objects);
          this._altObj.pivot = altObj.pivot;
          if ("axis" in altObj) {
            this._altObj.axis = altObj.axis.clone();
          } else {
            this._altObj.axis.set(0, 0, 1);
          }
        }
      }
      this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;
      this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
    } else if (event.button === 2) {
      this._state = STATE.TRANSLATE_PIVOT;
    }
  }
  if (this._state === STATE.ROTATE) {
    this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
    this._mousePrevPos.copy(this._mouseCurPos);
  }
  if (this._state === STATE.TRANSLATE || this._state === STATE.TRANSLATE_PIVOT) {
    this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
    this._mousePrevPos.copy(this._mouseCurPos);
  }
};
ObjectControls.prototype.mousemove = function(event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
      this.rotateByMouse(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.TRANSLATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
      this.translate();
      break;
    case STATE.TRANSLATE_PIVOT:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
      this.translatePivotByMouse();
      break;
  }
};
ObjectControls.prototype.mousewheel = function(event) {
  if (this.enabled === false || !settings$1.now.zooming || this._state !== STATE.NONE || event.shiftKey) {
    return;
  }
  event.preventDefault();
  var delta = 0;
  if (event.wheelDelta) {
    delta = event.wheelDelta / 40;
  } else if (event.detail) {
    delta = -event.detail / 3;
  }
  var factor = 1 + delta * 0.05;
  factor = Math.max(factor, 0.01);
  this.scale(factor);
};
ObjectControls.prototype.mouseup = function(event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  this._state = STATE.NONE;
  if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
    this._affectedObj.stop();
  }
};
ObjectControls.prototype.touchstartend = function(event) {
  if (this.enabled === false) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (event.touches.length) {
    case 1:
      this._state = STATE.ROTATE;
      this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
      this._mousePrevPos.copy(this._mouseCurPos);
      break;
    case 2: {
      this._mainObj.stop();
      this._altObj.stop();
      this._state = STATE.SCALE;
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
      this._scaleStart = this.object.scale.x;
      break;
    }
    default:
      this._state = STATE.NONE;
  }
};
ObjectControls.prototype.touchmove = function(event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
      this.rotateByMouse(false);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.SCALE:
      if (settings$1.now.zooming) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
        var newScale = this._scaleStart * this._touchDistanceCur / this._touchDistanceStart;
        var factor = newScale / this.object.scale.x;
        this.scale(factor);
      }
      break;
  }
};
ObjectControls.prototype.keydownup = function(event) {
  if (this.enabled === false || this.hotkeysEnabled === false) {
    return;
  }
  switch (event.keyCode) {
    case VK_LEFT:
    case VK_UP:
    case VK_RIGHT:
    case VK_DOWN:
      this._pressedKeys[event.keyCode] = event.type === "keydown";
      event.preventDefault();
      event.stopPropagation();
      break;
  }
};
ObjectControls.prototype.getKeyBindObject = function() {
  return window.top;
};
ObjectControls.prototype.dispose = function() {
  for (var i2 = 0; i2 < this._listeners.length; i2++) {
    var l2 = this._listeners[i2];
    l2.obj.removeEventListener(l2.type, l2.handler);
  }
};
ObjectControls.prototype.translatePivotByMouse = function() {
  var delta = new Vector2();
  return function() {
    delta.subVectors(this._mouseCurPos, this._mousePrevPos);
    this.translatePivotInWorld(settings$1.now.translationSpeed * delta.x, settings$1.now.translationSpeed * delta.y, 0);
  };
}();
ObjectControls.prototype.translatePivotInWorld = function(x2, y2, z2) {
  var pos = this.objectPivot.position;
  pos.applyMatrix4(this.object.matrixWorld);
  pos.setX(pos.x + x2);
  pos.setY(pos.y + y2);
  pos.setZ(pos.z + z2);
  pos.applyMatrix4(matrix4.copy(this.object.matrixWorld).invert());
  this.dispatchEvent({
    type: "change",
    action: "translatePivot"
  });
};
ObjectControls.prototype.translatePivot = function(x2, y2, z2) {
  var pos = this.objectPivot.position;
  pos.setX(pos.x + x2);
  pos.setY(pos.y + y2);
  pos.setZ(pos.z + z2);
  this.dispatchEvent({
    type: "change",
    action: "translatePivot"
  });
};
ObjectControls.prototype.setPivot = function(newPivot) {
  this.objectPivot.position.copy(newPivot);
  this.dispatchEvent({
    type: "change",
    action: "translatePivot"
  });
};
function Picker(gfxObj, camera, domElement) {
  EventDispatcher2.call(this);
  var self2 = this;
  this.gfxObj = gfxObj;
  this.camera = camera;
  this.domElement = typeof domElement !== "undefined" ? domElement : document;
  this.screen = {
    left: 0,
    top: 0,
    width: 0,
    height: 0
  };
  this._lastMousePos = new Vector2(0, 0);
  this._mouseTotalDist = 0;
  this._lastClickBeginTime = -1e3;
  this._lastClickPos = new Vector2(0, 0);
  this._clickBeginTime = 0;
  this._clock = new Timer();
  this._clock.start();
  this._listeners = [{
    obj: self2.domElement,
    type: "mousedown",
    handler: function handler(e2) {
      self2.mousedown(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mouseup",
    handler: function handler(e2) {
      self2.mouseup(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mousemove",
    handler: function handler(e2) {
      self2.mousemove(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchstart",
    handler: function handler(e2) {
      self2.touchstart(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchend",
    handler: function handler(e2) {
      self2.touchend(e2);
    }
  }, {
    obj: window,
    type: "resize",
    handler: function handler() {
      self2.handleResize();
    }
  }];
  for (var i2 = 0; i2 < this._listeners.length; i2++) {
    var l2 = this._listeners[i2];
    l2.obj.addEventListener(l2.type, l2.handler);
  }
  this.handleResize();
}
Picker.prototype = Object.create(EventDispatcher2.prototype);
Picker.prototype.constructor = Picker;
Picker.prototype.reset = function() {
  this.picked = {};
  this.dispatchEvent({
    type: "newpick",
    obj: {}
  });
};
Picker.prototype.handleResize = function() {
  if (this.domElement === document) {
    this.screen.left = 0;
    this.screen.top = 0;
    this.screen.width = window.innerWidth;
    this.screen.height = window.innerHeight;
  } else {
    var box = this.domElement.getBoundingClientRect();
    var d2 = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d2.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d2.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
};
Picker.prototype.pickObject = function(screenPos) {
  if (!this.gfxObj) {
    this.picked = {};
    this.dispatchEvent({
      type: "newpick",
      obj: {}
    });
    return;
  }
  var gfxObj = this.gfxObj;
  var rayCaster = new Raycaster();
  rayCaster.ray.origin.setFromMatrixPosition(this.camera.matrixWorld);
  rayCaster.ray.direction.set(screenPos.x, screenPos.y, 0.5).unproject(this.camera).sub(rayCaster.ray.origin).normalize();
  var clipPlane = settings$1.now.draft.clipPlane && this.clipPlaneValue ? this.clipPlaneValue : Infinity;
  var fogFarPlane = settings$1.now.fog && this.fogFarValue ? this.fogFarValue : Infinity;
  var point = rayCaster.intersectVisibleObject(gfxObj, this.camera, clipPlane, fogFarPlane);
  if (!point) {
    this.picked = {};
    this.dispatchEvent({
      type: "newpick",
      obj: {}
    });
    return;
  }
  var picked = {};
  if (point.residue || point.atom) {
    var residue2 = point.residue || point.atom.residue;
    if (settings$1.now.pick === "chain") {
      picked = {
        chain: residue2.getChain()
      };
    } else if (settings$1.now.pick === "molecule") {
      picked = {
        molecule: residue2.getMolecule()
      };
    } else if (point.residue || settings$1.now.pick === "residue") {
      picked = {
        residue: residue2
      };
    } else if (point.atom) {
      picked = {
        atom: point.atom
      };
    }
  }
  this.picked = picked;
  this.dispatchEvent({
    type: "newpick",
    obj: picked
  });
};
Picker.prototype.getMouseInViewport = function(pageX, pageY) {
  return new Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
};
Picker.prototype.mousedown = function(event) {
  event.preventDefault();
  event.stopPropagation();
  if (event.button === 0) {
    this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
    this._mouseTotalDist = 0;
    this._clickBeginTime = this._clock.getElapsedTime();
  }
};
Picker.prototype.mousemove = function(event) {
  event.preventDefault();
  event.stopPropagation();
  var pos = this.getMouseInViewport(event.pageX, event.pageY);
  this._mouseTotalDist += pos.sub(this._lastMousePos).length();
};
Picker.prototype.mouseup = function(event) {
  var self2 = this;
  event.preventDefault();
  event.stopPropagation();
  if (event.button === 0) {
    if (this._mouseTotalDist < 0.01) {
      var curTime = this._clock.getElapsedTime();
      var curPos = this.getMouseInViewport(event.pageX, event.pageY);
      var timeSinceLastClickBegin = curTime - this._lastClickBeginTime;
      if (timeSinceLastClickBegin < 0.7) {
        var clickDist = new Vector2().subVectors(curPos, this._lastClickPos);
        if (clickDist.length() < 0.01) {
          this.dispatchEvent({
            type: "dblclick",
            obj: this.picked
          });
          this._lastClickPos = curPos;
          this._lastClickBeginTime = -1e3;
          return;
        }
      }
      setTimeout(function() {
        self2.pickObject(curPos);
      }, 0);
      this._lastClickPos = curPos;
      this._lastClickBeginTime = this._clickBeginTime;
    }
  }
};
Picker.prototype.touchstart = function(event) {
  event.preventDefault();
  event.stopPropagation();
  if (event.touches.length === 1) {
    this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
  }
};
Picker.prototype.touchend = function(event) {
  var self2 = this;
  event.preventDefault();
  event.stopPropagation();
  if (event.touches.length === 0 && event.changedTouches.length === 1) {
    var pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
    var dist = pos.sub(this._lastTouchdownPos).length();
    if (dist < 0.01) {
      setTimeout(function() {
        self2.pickObject(self2._lastTouchdownPos);
      }, 0);
    }
  }
};
Picker.prototype.dispose = function() {
  for (var i2 = 0; i2 < this._listeners.length; i2++) {
    var l2 = this._listeners[i2];
    l2.obj.removeEventListener(l2.type, l2.handler);
  }
};
var Axes = function() {
  function Axes2(target, targetCamera) {
    _classCallCheck(this, Axes2);
    this._target = target;
    this._targetCamera = targetCamera;
    this._camera = new PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
    this._object = new AxesHelper(1);
    this._scene = new Scene();
    this._scene.add(this._object);
    this._full = new Vector2();
    this._update();
  }
  _createClass(Axes2, [{
    key: "_update",
    value: function _update() {
      var fov2 = this._targetCamera.fov;
      var camera = this._camera;
      camera.aspect = this._targetCamera.aspect;
      camera.setMinimalFov(fov2);
      camera.setDistanceToFit(1, fov2);
      camera.updateProjectionMatrix();
      this._object.quaternion.copy(this._target.quaternion);
    }
  }, {
    key: "render",
    value: function render(renderer) {
      this._update();
      renderer.getSize(this._full);
      var width = this._full.width * 0.25;
      var height = this._full.height * 0.25;
      var autoClear = renderer.autoClear;
      renderer.autoClear = false;
      renderer.setViewport(0, 0, width, height);
      renderer.clear(false, true, false);
      renderer.render(this._scene, this._camera);
      renderer.setViewport(0, 0, this._full.width, this._full.height);
      renderer.autoClear = autoClear;
    }
  }]);
  return Axes2;
}();
var cDataOffset = 12;
var cFirstMask = 268435200;
var cFirstShift = 8;
var cSecMask1 = 255;
var cSecShift1 = 12;
var cSecMask2 = 4293918720;
var cSecShift2 = 20;
var cThirdMask = 1048575;
var cStrMask = 4026531840;
var cStrShift = 28;
var c219 = 1 << 19;
var c220 = 1 << 20;
var cHelixIdx = 1;
var cSheetIdx = 2;
var secTypes = ["helix", "strand"];
var cSecNames = ["fs", "ps", "ns", "us"];
function _createSecondary(strArray, complex) {
  var residues = complex._residues;
  var nRes = residues.length;
  var resid = new Uint8Array(nRes);
  var atoms = complex._atoms;
  for (var i2 = 0, n2 = strArray.length; i2 < n2; ++i2) {
    var atom = atoms[i2];
    resid[atom.residue._index] = strArray[i2];
  }
  var secondary = [];
  var rIdx = 0;
  while (rIdx < nRes) {
    if (resid[rIdx] !== 0) {
      var start = rIdx;
      var val = resid[rIdx];
      while (rIdx < nRes - 1 && resid[rIdx + 1] === val && residues[rIdx].isConnected(residues[rIdx + 1])) {
        ++rIdx;
      }
      secondary.push({
        start,
        end: rIdx,
        type: secTypes[val - 1]
      });
    }
    ++rIdx;
  }
  return secondary;
}
function fromUInt20ToInt20(uint20) {
  return uint20 >= c219 ? uint20 - c220 : uint20;
}
var FrameInfo = function() {
  function FrameInfo2(complex, payload, callbacks) {
    _classCallCheck(this, FrameInfo2);
    this._complex = complex;
    this._secondary = null;
    this.isLoading = false;
    this._framesRange = {
      start: 0,
      end: -1
    };
    this.frameIsReady = false;
    this._buffer = null;
    this._frameRequest = null;
    this._callbacks = callbacks;
    if (typeof payload === "function") {
      this._framesRequestLength = 1;
      this._downloadDataFn = payload;
    } else {
      this.parseBinaryData(payload, true);
    }
    this.reset();
    this.setFrame(0);
  }
  _createClass(FrameInfo2, [{
    key: "_prepareBuffer",
    value: function _prepareBuffer(framesStart, framesEnd) {
      if (framesStart === void 0 || framesStart === null) {
        framesStart = 0;
      }
      if (framesEnd === void 0 || framesEnd === null) {
        framesEnd = framesStart + this._framesRequestLength;
      }
      if (this._framesCount !== void 0) {
        framesEnd = Math.min(this._framesCount - 1, framesEnd);
      }
      if (this._downloadDataFn) {
        var self2 = this;
        var onDone = function onDone2(data) {
          self2.isLoading = false;
          if (self2._callbacks && typeof self2._callbacks.onLoadStatusChanged === "function") {
            self2._callbacks.onLoadStatusChanged();
          }
          self2._buffer = {
            data,
            state: "ready",
            start: framesStart,
            end: framesEnd
          };
          if (self2._frameRequest !== null) {
            var idx = self2._frameRequest;
            self2._frameRequest = null;
            self2.setFrame(idx);
          }
        };
        var onFail = function onFail2() {
          self2.isLoading = false;
          if (self2._callbacks && typeof self2._callbacks.onError === "function") {
            self2._callbacks.onError("Streaming failed");
          }
        };
        if (!this._buffer) {
          this._buffer = {};
        }
        this._buffer.state = "downloading";
        this.isLoading = true;
        if (self2._callbacks && typeof self2._callbacks.onLoadStatusChanged === "function") {
          self2._callbacks.onLoadStatusChanged();
        }
        this._downloadDataFn({
          start: framesStart,
          end: framesEnd + 1
        }, onDone, onFail);
      }
    }
  }, {
    key: "_parseBuffer",
    value: function _parseBuffer() {
      if (this._buffer && this._buffer.state === "ready") {
        this._framesRange = {
          start: this._buffer.start,
          end: this._buffer.end
        };
        this.parseBinaryData(this._buffer.data, false);
        var _bufferRequestStart = (this._buffer.end + 1) % this._framesCount;
        if (_bufferRequestStart >= this._framesCount) {
          _bufferRequestStart = 0;
        }
        this._buffer = {
          state: "none"
        };
        this._prepareBuffer(_bufferRequestStart, _bufferRequestStart + this._framesRequestLength);
        if (this._frameRequest !== null) {
          var idx = this._frameRequest;
          this._frameRequest = null;
          this.setFrame(idx);
        }
      }
    }
  }, {
    key: "parseBinaryData",
    value: function parseBinaryData(arrayBuffer) {
      var dataView = new DataView(arrayBuffer);
      var offset = 0;
      var atomsCount = dataView.getUint32(offset, true);
      offset += 4;
      var framesCount = dataView.getUint32(offset, true);
      this._framesCount = framesCount;
      this._framesRange.end = this._framesRange.end > 0 ? Math.min(this._framesRange.end, framesCount - 1) : framesCount - 1;
      offset += 4;
      this._atomsCount = atomsCount;
      var maxSize = 1024 * 1024;
      this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8));
      var chunkedFramesCount = this._framesRange.end - this._framesRange.start + 1;
      if (atomsCount !== this._complex._atoms.length || arrayBuffer.byteLength !== cDataOffset + chunkedFramesCount * atomsCount * 8) {
        throw new Error();
      }
      var complex = this._complex;
      var timeStep = dataView.getUint32(offset, true);
      var iName = 0;
      while (timeStep > 1e3 && iName < cSecNames.length - 1) {
        timeStep /= 1e3;
        ++iName;
      }
      this._timeStep = "".concat(timeStep.toString(), " ").concat(cSecNames[iName]);
      offset += 4;
      var secondary = [];
      var posData = new Float32Array(chunkedFramesCount * atomsCount * 3);
      var coordIdx = 0;
      var secondaryArr = new Int8Array(atomsCount);
      for (var j2 = 0; j2 < chunkedFramesCount; ++j2) {
        for (var i2 = 0; i2 < atomsCount; ++i2) {
          var hiWord = dataView.getUint32(offset, true);
          offset += 4;
          var loWord = dataView.getUint32(offset, true);
          offset += 4;
          var str = (loWord & cStrMask) >>> cStrShift;
          var x2 = fromUInt20ToInt20((loWord & cFirstMask) >>> cFirstShift >> 0);
          var y2 = fromUInt20ToInt20(((loWord & cSecMask1) << cSecShift1 | (hiWord & cSecMask2) >>> cSecShift2) >> 0);
          var z2 = fromUInt20ToInt20((hiWord & cThirdMask) >> 0);
          secondaryArr[i2] = 0;
          if (str > 0 && str < 4) {
            secondaryArr[i2] = cHelixIdx;
          } else if (str === 4) {
            secondaryArr[i2] = cSheetIdx;
          }
          posData[coordIdx++] = x2 / 100;
          posData[coordIdx++] = y2 / 100;
          posData[coordIdx++] = z2 / 100;
        }
        secondary.push(_createSecondary(secondaryArr, complex));
      }
      this._secondaryData = secondary;
      this._data = posData;
    }
  }, {
    key: "nextFrame",
    value: function nextFrame() {
      this.setFrame((this._currFrame + 1) % this._framesCount);
    }
  }, {
    key: "needsColorUpdate",
    value: function needsColorUpdate(colorer) {
      return colorer instanceof SecondaryStructureColorer;
    }
  }, {
    key: "getAtomColor",
    value: function getAtomColor(colorer, atom) {
      return colorer.getResidueColor(this._residues[atom.residue._index], this._complex);
    }
  }, {
    key: "getResidueColor",
    value: function getResidueColor(colorer, residue2) {
      return colorer.getResidueColor(this._residues[residue2._index], this._complex);
    }
  }, {
    key: "_updateSecondary",
    value: function _updateSecondary() {
      var i2;
      var myResidues = this._residues;
      var n2 = myResidues.length;
      for (i2 = 0; i2 < n2; ++i2) {
        myResidues[i2]._secondary = null;
      }
      var sec = this._secondaryData[this._currFrame - this._framesRange.start];
      for (i2 = 0, n2 = sec.length; i2 < n2; ++i2) {
        var oldSec = sec[i2];
        var start = oldSec.start, end = oldSec.end;
        var nSec = {
          _start: myResidues[start],
          _end: myResidues[end],
          type: oldSec.type,
          generic: oldSec.generic
        };
        for (var j2 = start; j2 <= end; ++j2) {
          myResidues[j2]._secondary = nSec;
        }
      }
    }
  }, {
    key: "reset",
    value: function reset2() {
      var compRes = this._complex._residues;
      var n2 = compRes.length;
      this._residues = new Array(n2);
      var myResidues = this._residues;
      var getSec = function getSec2() {
        return this._secondary;
      };
      for (var i2 = 0; i2 < n2; ++i2) {
        myResidues[i2] = {
          _type: compRes[i2]._type,
          _isValid: compRes[i2]._isValid,
          _controlPoint: null,
          _wingVector: null,
          _secondary: null,
          getSecondary: getSec
        };
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(frameIdx) {
      this.frameIsReady = false;
      if (frameIdx >= this._framesRange.start && frameIdx <= this._framesRange.end) {
        this._currFrame = frameIdx;
        this._cachedResidues = false;
        this._updateSecondary();
        this.frameIsReady = true;
      } else {
        this._frameRequest = frameIdx;
        if (!this._buffer) {
          this._prepareBuffer(frameIdx);
        } else {
          var self2 = this;
          switch (this._buffer.state) {
            case "none":
              this._prepareBuffer(frameIdx);
              break;
            case "ready":
              self2._parseBuffer();
              break;
          }
        }
      }
    }
  }, {
    key: "disableEvents",
    value: function disableEvents() {
      this._callbacks = null;
    }
  }, {
    key: "getAtomPos",
    value: function getAtomPos2(atomIdx) {
      var vec = FrameInfo2._vec;
      var self2 = this;
      var data = self2._data;
      var idx = (self2._atomsCount * (self2._currFrame - self2._framesRange.start) + atomIdx) * 3;
      vec.set(data[idx], data[idx + 1], data[idx + 2]);
      return vec;
    }
  }, {
    key: "getResidues",
    value: function getResidues() {
      if (this._cachedResidues) {
        return this._residues;
      }
      this._complex.updateToFrame(this);
      return this._residues;
    }
  }]);
  return FrameInfo2;
}();
_defineProperty2(FrameInfo, "_vec", new Vector3());
var SceneObject = function() {
  function SceneObject2(params, opts) {
    _classCallCheck(this, SceneObject2);
    if (this.constructor === SceneObject2) {
      throw new Error("Can not instantiate abstract class!");
    }
    this.params = params;
    this.opts = (0, import_lodash.merge)(utils.deriveDeep(settings$1.now.objects[this.type], true), opts);
    this.needsRebuild = false;
    this._mesh = null;
    this.id = null;
  }
  _createClass(SceneObject2, [{
    key: "identify",
    value: function identify() {
      var result = {
        type: this.type,
        params: this.params
      };
      var diff = utils.objectsDiff(this.opts, settings$1.now.modes[this.id]);
      if (!(0, import_lodash.isEmpty)(diff)) {
        result.opts = diff;
      }
      return result;
    }
  }, {
    key: "toString",
    value: function toString3() {
      var paramsStr = "o=".concat(this.type, ",").concat(this.params.join(","));
      var optsStr = utils.compareOptionsWithDefaults(this.opts, settings$1.defaults.objects[this.type]);
      return paramsStr + optsStr;
    }
  }, {
    key: "getGeometry",
    value: function getGeometry() {
      return this._mesh;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._mesh) {
        gfxutils.destroyObject(this._mesh);
      }
    }
  }]);
  return SceneObject2;
}();
SceneObject.prototype.type = "__";
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var LinesObj = function(_SceneObject) {
  _inherits(LinesObj2, _SceneObject);
  var _super = _createSuper$7(LinesObj2);
  function LinesObj2(params, opts) {
    var _this;
    _classCallCheck(this, LinesObj2);
    _this = _super.call(this, params, opts);
    if (params.length < 2) {
      throw new Error("Wrong number of argumets on line object creation!");
    }
    var _params = _slicedToArray(params, 2);
    _this._id1 = _params[0];
    _this._id2 = _params[1];
    return _this;
  }
  _createClass(LinesObj2, [{
    key: "_getAtomFromName",
    value: function _getAtomFromName(complex, atomId) {
      var err = " - Wrong atom format it must be '#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME' (e.g. 'A.38.CO1')";
      var atom1 = complex.getAtomByFullname(atomId);
      if (!atom1) {
        throw new Error(atomId + err);
      }
      return atom1;
    }
  }, {
    key: "build",
    value: function build(complex) {
      var geom = new BufferGeometry();
      this._atom1 = this._getAtomFromName(complex, this._id1);
      this._atom2 = this._getAtomFromName(complex, this._id2);
      var p1 = this._atom1.position;
      var p2 = this._atom2.position;
      var vertices = new Float32Array([p1.x, p1.y, p1.z, p2.x, p2.y, p2.z]);
      geom.setAttribute("position", new BufferAttribute(vertices, 3));
      geom.computeBoundingBox();
      var material2 = new UberMaterial();
      material2.setValues({
        lights: false,
        overrideColor: true,
        dashedLine: true,
        fogTransparent: settings$1.now.bg.transparent
      });
      this._line = new meshes.Line(geom, material2);
      this._line.computeLineDistances();
      this._line.material.setUberOptions({
        fixedColor: new Color(this.opts.color),
        dashedLineSize: this.opts.dashSize,
        dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
      });
      this._line.material.updateUniforms();
      this._line.raycast = function(_raycaster, _intersects) {
      };
      this._mesh = this._line;
      var transforms = complex.getTransforms();
      if (transforms.length > 0) {
        this._mesh = new Group();
        this._mesh.add(this._line);
        meshutils.applyTransformsToMeshes(this._mesh, transforms);
      }
    }
  }, {
    key: "updateToFrame",
    value: function updateToFrame(frameData) {
      if (!this._atom1 || !this._atom2 || !this._line) {
        return;
      }
      var geo = this._line.geometry;
      geo.vertices[0].copy(frameData.getAtomPos(this._atom1.index));
      geo.vertices[1].copy(frameData.getAtomPos(this._atom2.index));
      this._line.computeLineDistances();
      geo.computeBoundingSphere();
      geo.verticesNeedUpdate = true;
    }
  }]);
  return LinesObj2;
}(SceneObject);
LinesObj.prototype.constructor = LinesObj;
LinesObj.prototype.type = "line";
var fragmentShader$5 = "precision highp float;\r\n\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexSize;\r\nuniform vec2 thickness;\r\nvarying vec2 vUv;\r\n\r\n#ifdef DEPTH_OUTLINE\r\n  uniform sampler2D srcDepthTex; //depthTexture\r\n  uniform vec3 color;\r\n  uniform float threshold;\r\n#endif\r\n\r\nvoid main() {\r\n\r\n  vec2 pixelSize = thickness / srcTexSize;\r\n\r\n  #ifdef DEPTH_OUTLINE\r\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r\n\r\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n\r\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r\n\r\n  #else\r\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r\n\r\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n    gl_FragColor = grad;\r\n  #endif\r\n}\r\n";
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OutlineMaterial = function(_RawShaderMaterial) {
  _inherits(OutlineMaterial2, _RawShaderMaterial);
  var _super = _createSuper$6(OutlineMaterial2);
  function OutlineMaterial2(params) {
    var _this;
    _classCallCheck(this, OutlineMaterial2);
    _this = _super.call(this, params);
    var settings2 = {
      uniforms: {
        srcTex: {
          type: "t",
          value: null
        },
        srcDepthTex: {
          type: "t",
          value: null
        },
        srcTexSize: {
          type: "v2",
          value: new Vector2(512, 512)
        },
        color: {
          type: "v3",
          value: null
        },
        threshold: {
          type: "f",
          value: null
        },
        opacity: {
          type: "f",
          value: 1
        },
        thickness: {
          type: "v2",
          value: new Vector2(1, 1)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentShader$5,
      transparent: true,
      depthTest: false,
      depthWrite: false
    };
    _this.setValues(settings2);
    return _this;
  }
  _createClass(OutlineMaterial2, [{
    key: "copy",
    value: function copy2(source) {
      _get(_getPrototypeOf(OutlineMaterial2.prototype), "copy", this).call(this, source);
      this.depth = source.depth;
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      if (typeof values === "undefined") {
        return;
      }
      _get(_getPrototypeOf(OutlineMaterial2.prototype), "setValues", this).call(this, values);
      var defines = {};
      if (this.depth) {
        defines.DEPTH_OUTLINE = 1;
      }
      this.defines = defines;
    }
  }]);
  return OutlineMaterial2;
}(RawShaderMaterial);
OutlineMaterial.prototype.depth = false;
var fragmentShader$4 = "precision highp float;\r\n\r\n// edge end finding algorithm parameters\r\n#define FXAA_QUALITY_PS 8\r\n#define FXAA_QUALITY_P0 1.0\r\n#define FXAA_QUALITY_P1 1.5\r\n#define FXAA_QUALITY_P2 2.0\r\n#define FXAA_QUALITY_P3 2.0\r\n#define FXAA_QUALITY_P4 2.0\r\n#define FXAA_QUALITY_P5 2.0\r\n#define FXAA_QUALITY_P6 4.0\r\n#define FXAA_QUALITY_P7 12.0\r\n// constants\r\nfloat fxaaQualityEdgeThreshold = 0.125;\r\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\r\nfloat fxaaQualitySubpix = 0.7; //0.65;\r\n// global params\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexelSize;\r\nuniform vec3 bgColor;\r\n// from vs\r\nvarying vec2 vUv;\r\n//=====================================================================//\r\n// calc luminance from rgb\r\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r\n                                                                           // for non-real scene rendering\r\n// texture sampling by pixel position(coords) and offset(in pixels)\r\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos + off * res );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos + off * res ).xyz;\r\n  #endif\r\n}\r\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos).xyz;\r\n  #endif\r\n}\r\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r\n  return texture2D( tex, pos);\r\n}\r\n\r\n//=====================================================================//\r\nvoid main() {\r\n  // renaming\r\n  vec2 posM = vUv;\r\n  // get luminance for neighbours\r\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r\n  // find max and min luminance\r\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r\n  // calc maximum non-edge range\r\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r\n  float range = rangeMax - rangeMin;\r\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r\n  // exit when luma contrast is small (is not edge)\r\n  if(range < rangeMaxClamped){\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n    return;\r\n  }\r\n  float subpixRcpRange = 1.0/range;\r\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\r\n  // visibly, thus we decided to leave calculation here for better readability.\r\n  // calc other neighbours luminance\r\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r\n/*--------------span calculation and subpix amount calulation-----------------*/\r\n  float lumaNS = lumaN + lumaS;\r\n  float lumaWE = lumaW + lumaE;\r\n  float subpixNSWE = lumaNS + lumaWE;\r\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNESE = lumaNE + lumaSE;\r\n  float lumaNWNE = lumaNW + lumaNE;\r\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNWSW = lumaNW + lumaSW;\r\n  float lumaSWSE = lumaSW + lumaSE;\r\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r\n  float edgeVert = abs(edgeVert3) + edgeVert4;\r\n/*--------------------subpix amount calulation------------------------------*/\r\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r\n  float lengthSign = srcTexelSize.x;\r\n  bool horzSpan = edgeHorz >= edgeVert;\r\n   // debug  code edge span visualization\r\n/*'  if (horzSpan)\r\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n  else\r\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  return;*/\r\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r\n/*--------------------------------------------------------------------------*/\r\n  if(!horzSpan) lumaN = lumaW;\r\n  if(!horzSpan) lumaS = lumaE;\r\n  if(horzSpan) lengthSign = srcTexelSize.y;\r\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r\n/*--------------------------------------------------------------------------*/\r\n  float gradientN = lumaN - lumaM;\r\n  float gradientS = lumaS - lumaM;\r\n  float lumaNN = lumaN + lumaM;\r\n  float lumaSS = lumaS + lumaM;\r\n  bool pairN = abs(gradientN) >= abs(gradientS);\r\n  float gradient = max(abs(gradientN), abs(gradientS));\r\n  if(pairN) lengthSign = -lengthSign;\r\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posB;\r\n  posB = posM;\r\n  vec2 offNP;\r\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r\n  if(!horzSpan) posB.x += lengthSign * 0.5;\r\n  if( horzSpan) posB.y += lengthSign * 0.5;\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posN;\r\n  posN = posB - offNP * FXAA_QUALITY_P0;\r\n  vec2 posP;\r\n  posP = posB + offNP * FXAA_QUALITY_P0;\r\n  float subpixD = ((-2.0)*subpixC) + 3.0;\r\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r\n  float subpixE = subpixC * subpixC;\r\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r\n/*--------------------------------------------------------------------------*/\r\n  if(!pairN) lumaNN = lumaSS;\r\n  float gradientScaled = gradient * 1.0/4.0;\r\n  float lumaMM = lumaM - lumaNN * 0.5;\r\n  float subpixF = subpixD * subpixE;\r\n  bool lumaMLTZero = lumaMM < 0.0;\r\n/*---------------------looped edge-end search-------------------------------*/\r\n  lumaEndN -= lumaNN * 0.5;\r\n  lumaEndP -= lumaNN * 0.5;\r\n  bool doneN = abs(lumaEndN) >= gradientScaled;\r\n  bool doneP = abs(lumaEndP) >= gradientScaled;\r\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r\n  bool doneNP = (!doneN) || (!doneP);\r\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r\n/*--------------------------------------------------------------------------*/\r\n  if(doneNP) {\r\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n    doneN = abs(lumaEndN) >= gradientScaled;\r\n    doneP = abs(lumaEndP) >= gradientScaled;\r\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r\n    doneNP = (!doneN) || (!doneP);\r\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r\n/*--------------------------------------------------------------------------*/\r\n    #if (FXAA_QUALITY_PS > 3)\r\n      if(doneNP) {\r\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n        doneN = abs(lumaEndN) >= gradientScaled;\r\n        doneP = abs(lumaEndP) >= gradientScaled;\r\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r\n        doneNP = (!doneN) || (!doneP);\r\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r\n/*--------------------------------------------------------------------------*/\r\n        #if (FXAA_QUALITY_PS > 4)\r\n          if(doneNP) {\r\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n            doneN = abs(lumaEndN) >= gradientScaled;\r\n            doneP = abs(lumaEndP) >= gradientScaled;\r\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r\n            doneNP = (!doneN) || (!doneP);\r\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r\n/*--------------------------------------------------------------------------*/\r\n            #if (FXAA_QUALITY_PS > 5)\r\n               if(doneNP) {\r\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                 doneN = abs(lumaEndN) >= gradientScaled;\r\n                 doneP = abs(lumaEndP) >= gradientScaled;\r\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r\n                 doneNP = (!doneN) || (!doneP);\r\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r\n/*--------------------------------------------------------------------------*/\r\n                 #if (FXAA_QUALITY_PS > 6)\r\n                   if(doneNP) {\r\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                     doneN = abs(lumaEndN) >= gradientScaled;\r\n                     doneP = abs(lumaEndP) >= gradientScaled;\r\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r\n                     doneNP = (!doneN) || (!doneP);\r\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r\n/*--------------------------------------------------------------------------*/\r\n                     #if (FXAA_QUALITY_PS > 7)\r\n                       if(doneNP) {\r\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                         doneN = abs(lumaEndN) >= gradientScaled;\r\n                         doneP = abs(lumaEndP) >= gradientScaled;\r\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r\n                         doneNP = (!doneN) || (!doneP);\r\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r\n/*--------------------------------------------------------------------------*/\r\n                       }\r\n                     #endif\r\n                   }\r\n                 #endif\r\n               }\r\n             #endif\r\n           }\r\n         #endif\r\n      }\r\n    #endif\r\n  }\r\n/*----------------calculate subpix offset due to edge ends-------------------*/\r\n  float dstN = posM.x - posN.x;\r\n  float dstP = posP.x - posM.x;\r\n  if(!horzSpan) dstN = posM.y - posN.y;\r\n  if(!horzSpan) dstP = posP.y - posM.y;\r\n/*--------------------------------------------------------------------------*/\r\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r\n  float spanLength = (dstP + dstN);\r\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r\n  float spanLengthRcp = 1.0 / spanLength;\r\n/*--------------------------------------------------------------------------*/\r\n  bool directionN = dstN < dstP;\r\n  float dst = min(dstN, dstP);\r\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r\n  float subpixG = subpixF * subpixF;\r\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r\n  float subpixH = subpixG * fxaaQualitySubpix;\r\n/*-----------------calc texture offest using subpix-------------------------*/\r\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r\n\r\n  float offset = pixelOffsetSubpix * lengthSign;\r\n  #ifdef BG_TRANSPARENT\r\n    // get original texel\r\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r\n    // calc step to blended texel\r\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r\n    // get neighboring texel\r\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r\n    //  calc blend factor from offset\r\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r\n    f = abs(f);\r\n    // calc alpha (special formula to emulate blending with bg)\r\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r\n    // calc color (special formula to emulate blending with bg)\r\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r\n  #else\r\n    if(!horzSpan) {\r\n       posM.x += offset;\r\n    } else {\r\n       posM.y += offset;\r\n    }\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n  #endif\r\n  return;\r\n}\r\n";
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var FXAAMaterial = function(_RawShaderMaterial) {
  _inherits(FXAAMaterial2, _RawShaderMaterial);
  var _super = _createSuper$5(FXAAMaterial2);
  function FXAAMaterial2(params) {
    var _this;
    _classCallCheck(this, FXAAMaterial2);
    _this = _super.call(this, params);
    _this.setValues({
      uniforms: {
        srcTex: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new Vector2(1 / 512, 1 / 512)
        },
        bgColor: {
          type: "c",
          value: new Color(16777215)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentShader$4,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    _this.setValues(params);
    return _this;
  }
  _createClass(FXAAMaterial2, [{
    key: "copy",
    value: function copy2(source) {
      _get(_getPrototypeOf(FXAAMaterial2.prototype), "copy", this).call(this, source);
      this.depth = source.depth;
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      if (typeof values === "undefined") {
        return;
      }
      _get(_getPrototypeOf(FXAAMaterial2.prototype), "setValues", this).call(this, values);
      var defines = {};
      if (this.bgTransparent) {
        defines.BG_TRANSPARENT = 1;
      }
      this.defines = defines;
    }
  }]);
  return FXAAMaterial2;
}(RawShaderMaterial);
FXAAMaterial.prototype.bgTransparent = false;
var fragmentShader$3 = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 32\r\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r\nuniform sampler2D noiseTexture;\r\nuniform vec2      noiseTexelSize;\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D normalTexture;\r\nuniform vec2      srcTexelSize;\r\nuniform vec2      camNearFar;\r\nuniform mat4      projMatrix;\r\n\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\nuniform float kernelRadius;\r\nuniform float depthThreshold;\r\nuniform float factor;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\r\n                   );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  // remap coordinates to prevent noise exture rescale\r\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r\n  vec4 normalData = texture2D(normalTexture, vUv);\r\n  // return for background fragments (their normals are zero vectors)\r\n  if (length(normalData.rgb) < EPSILON) {\r\n    // 0.0 in alpha component means that it is background fragment\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  //[0, 1] -> [-1, 1]\r\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\r\n  // normalData.a store 1.0 if normal was build for frontfaced surface\r\n  // and 0.0 in other case\r\n  if (normalData.a < EPSILON) {\r\n    normal *= -1.0;\r\n  }\r\n  // get random vector for sampling sphere rotation\r\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r\n  randN = normalize(randN);\r\n  // build TBN (randomly rotated around normal)\r\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r\n  vec3 bitangent = cross(tangent, normal);\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n  // calc AO value\r\n  float AO = 0.0;\r\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r\n    // rotate sampling kernel around normal\r\n    vec3 reflectedSample = TBN * samplesKernel[i];\r\n    // get sample\r\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r\n\r\n    // project sample to screen to get sample's screen pos\r\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\r\n    // eye -> clip\r\n    SampleScrPos = projMatrix * SampleScrPos;\r\n    // normalize\r\n    SampleScrPos.xy /= SampleScrPos.w;\r\n    //[-1, 1] -> [0, 1]\r\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r\n\r\n    // get view z for sample projected to the objct surface\r\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r\n    // calc occlusion made by object surface at the sample\r\n    AO += step(samplePos.z, sampleDepth);\r\n  }\r\n  // calc result AO-map color\r\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\r\n  // write value to AO-map\r\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\r\n}\r\n";
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _samplesKernel = [
  new Vector3(0.295184, 0.077723, 0.068429),
  new Vector3(-0.271976, -0.365221, 0.838363),
  new Vector3(0.547713, 0.467576, 0.488515),
  new Vector3(0.662808, -0.031733, 0.584758),
  new Vector3(-0.025717, 0.218955, 0.657094),
  new Vector3(-0.310153, -0.365223, 0.370701),
  new Vector3(-0.101407, -6313e-6, 0.747665),
  new Vector3(-0.769138, 0.360399, 0.086847),
  new Vector3(-0.271988, -0.27514, 0.905353),
  new Vector3(0.09674, -0.566901, 0.700151),
  new Vector3(0.562872, -0.735136, 0.094647),
  new Vector3(0.379877, 0.359278, 0.190061),
  new Vector3(0.519064, -0.023055, 0.405068),
  new Vector3(-0.301036, 0.114696, 0.088885),
  new Vector3(-0.282922, 0.598305, 0.487214),
  new Vector3(-0.181859, 0.25167, 0.679702),
  new Vector3(-0.191463, -0.635818, 0.512919),
  new Vector3(-0.293655, 0.427423, 0.078921),
  new Vector3(-0.267983, 0.680534, 0.13288),
  new Vector3(0.139611, 0.319637, 0.477439),
  new Vector3(-0.352086, 0.31104, 0.653913),
  new Vector3(0.321032, 0.805279, 0.487345),
  new Vector3(0.073516, 0.820734, 0.414183),
  new Vector3(-0.155324, 0.589983, 0.41146),
  new Vector3(0.335976, 0.170782, 0.527627),
  new Vector3(0.46346, -0.355658, 0.167689),
  new Vector3(0.222654, 0.59655, 0.769406),
  new Vector3(0.922138, -0.04207, 0.147555),
  new Vector3(-0.72705, -0.329192, 0.369826),
  new Vector3(-0.090731, 0.53382, 0.463767),
  new Vector3(-0.323457, -0.876559, 0.238524),
  new Vector3(-0.663277, -0.372384, 0.342856)
];
var AOMaterial = function(_RawShaderMaterial) {
  _inherits(AOMaterial2, _RawShaderMaterial);
  var _super = _createSuper$4(AOMaterial2);
  function AOMaterial2() {
    var _this;
    _classCallCheck(this, AOMaterial2);
    _this = _super.call(this);
    _this.setValues({
      uniforms: {
        noiseTexture: {
          type: "t",
          value: noise.noiseTexture
        },
        noiseTexelSize: {
          type: "v2",
          value: new Vector2(1 / noise.noiseWidth, 1 / noise.noiseHeight)
        },
        diffuseTexture: {
          type: "t",
          value: null
        },
        normalTexture: {
          type: "t",
          value: null
        },
        depthTexture: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new Vector2(1 / 512, 1 / 512)
        },
        camNearFar: {
          type: "v2",
          value: new Vector2(1, 10)
        },
        projMatrix: {
          type: "mat4",
          value: new Matrix4()
        },
        aspectRatio: {
          type: "f",
          value: 0
        },
        tanHalfFOV: {
          type: "f",
          value: 0
        },
        samplesKernel: {
          type: "v3v",
          value: _samplesKernel
        },
        kernelRadius: {
          type: "f",
          value: 1
        },
        depthThreshold: {
          type: "f",
          value: 1
        },
        factor: {
          type: "f",
          value: 1
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentShader$3,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    return _this;
  }
  return _createClass(AOMaterial2);
}(RawShaderMaterial);
var fragmentShader$2 = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = res;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb = res.rgb / weightSum;\r\n  gl_FragColor = res;\r\n}\r\n";
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _kernelOffsets$1 = [-2, -1, 0, 1, 2];
var AOHorBlurMaterial = function(_RawShaderMaterial) {
  _inherits(AOHorBlurMaterial2, _RawShaderMaterial);
  var _super = _createSuper$3(AOHorBlurMaterial2);
  function AOHorBlurMaterial2() {
    var _this;
    _classCallCheck(this, AOHorBlurMaterial2);
    _this = _super.call(this);
    _this.setValues({
      uniforms: {
        depthTexture: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new Vector2(1 / 512, 1 / 512)
        },
        aoMap: {
          type: "t",
          value: null
        },
        samplesOffsets: {
          type: "fv1",
          value: _kernelOffsets$1
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentShader$2,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    return _this;
  }
  return _createClass(AOHorBlurMaterial2);
}(RawShaderMaterial);
var fragmentShader$1 = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nuniform mat4  projMatrix;\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\n#ifdef USE_FOG\r\n  uniform vec2 fogNearFar;\r\n  uniform vec4 fogColor;\r\n#endif\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n  projPos.y * tanHalfFOV * abs(viewPos.z)\r\n  );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = color;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb /= weightSum;\r\n\r\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\r\n    // Add fog to the result value\r\n    // Proper way to get an image with fog and ao requires formula:\r\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\r\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\r\n    // We have:  AO, fogFactor, fogColor,\r\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\r\n    //                                                                where molecule has been already drawn with fog)\r\n    // Transform:\r\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\r\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\r\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\r\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\r\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\r\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\r\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\r\n  #else\r\n    gl_FragColor.rgb = color.rgb * res.rgb;\r\n  #endif\r\n  gl_FragColor.a = color.a;\r\n}\r\n";
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _kernelOffsets = [-2, -1, 0, 1, 2];
var AOVertBlurWithBlendMaterial = function(_RawShaderMaterial) {
  _inherits(AOVertBlurWithBlendMaterial2, _RawShaderMaterial);
  var _super = _createSuper$2(AOVertBlurWithBlendMaterial2);
  function AOVertBlurWithBlendMaterial2(params) {
    var _this;
    _classCallCheck(this, AOVertBlurWithBlendMaterial2);
    _this = _super.call(this, params);
    _this.setValues({
      uniforms: {
        diffuseTexture: {
          type: "t",
          value: null
        },
        depthTexture: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new Vector2(1 / 512, 1 / 512)
        },
        aoMap: {
          type: "t",
          value: null
        },
        samplesOffsets: {
          type: "fv1",
          value: _kernelOffsets
        },
        projMatrix: {
          type: "mat4",
          value: new Matrix4()
        },
        aspectRatio: {
          type: "f",
          value: 0
        },
        tanHalfFOV: {
          type: "f",
          value: 0
        },
        fogNearFar: {
          type: "v2",
          value: new Vector2(100, 100)
        },
        fogColor: {
          type: "v4",
          value: new Vector4(0, 0.5, 0, 1)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentShader$1,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    _this.setValues(params);
    return _this;
  }
  _createClass(AOVertBlurWithBlendMaterial2, [{
    key: "setValues",
    value: function setValues(values) {
      if (typeof values === "undefined") {
        return;
      }
      _get(_getPrototypeOf(AOVertBlurWithBlendMaterial2.prototype), "setValues", this).call(this, values);
      var defines = {};
      if (this.useFog) {
        defines.USE_FOG = 1;
      }
      if (this.fogTransparent) {
        defines.FOG_TRANSPARENT = 1;
      }
      this.defines = defines;
    }
  }]);
  return AOVertBlurWithBlendMaterial2;
}(RawShaderMaterial);
AOVertBlurWithBlendMaterial.prototype.useFog = true;
AOVertBlurWithBlendMaterial.prototype.fogTransparent = false;
var fragmentShader = "precision highp float;\r\n\r\nuniform sampler2D srcL;\r\nuniform sampler2D srcR;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 l = texture2D(srcL, vUv);\r\n  vec4 r = texture2D(srcR, vUv);\r\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r\n}\r\n";
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var AnaglyphMaterial = function(_RawShaderMaterial) {
  _inherits(AnaglyphMaterial2, _RawShaderMaterial);
  var _super = _createSuper$1(AnaglyphMaterial2);
  function AnaglyphMaterial2() {
    var _this;
    _classCallCheck(this, AnaglyphMaterial2);
    _this = _super.call(this);
    var settings2 = {
      uniforms: {
        srcL: {
          type: "t",
          value: null
        },
        srcR: {
          type: "t",
          value: null
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader,
      transparent: false,
      depthTest: false,
      depthWrite: false
    };
    _this.setValues(settings2);
    return _this;
  }
  return _createClass(AnaglyphMaterial2);
}(RawShaderMaterial);
var View = function() {
  function View2() {
    _classCallCheck(this, View2);
    this.position = new Vector3(0, 0, 0);
    this.scale = 1;
    this.orientation = new Quaternion(0, 0, 0, 1);
  }
  _createClass(View2, [{
    key: "set",
    value: function set3(position, scale, orientation) {
      this.position = position;
      this.scale = scale;
      this.orientation = orientation;
    }
  }]);
  return View2;
}();
var _transitionTime = 1.5;
var ViewInterpolator = function() {
  function ViewInterpolator2() {
    _classCallCheck(this, ViewInterpolator2);
  }
  _createClass(ViewInterpolator2, [{
    key: "setup",
    value: function setup(startView, endView) {
      this._startTime = void 0;
      this._endTime = void 0;
      this._isPaused = false;
      this._srcView = startView;
      this._dstView = endView;
      this._isMoving = false;
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      return this._isMoving;
    }
  }, {
    key: "wasStarted",
    value: function wasStarted() {
      return typeof this._startTime !== "undefined" && typeof this._endTime !== "undefined";
    }
  }, {
    key: "start",
    value: function start() {
      this._startTime = Date.now();
      var transTime = settings$1.now.interpolateViews ? _transitionTime * 1e3 : 0;
      this._endTime = this._startTime + transTime;
      this._isMoving = true;
    }
  }, {
    key: "getCurrentView",
    value: function getCurrentView() {
      if (typeof this._srcView === "undefined" || typeof this._dstView === "undefined" || !this._isMoving || !this.wasStarted()) {
        return {
          success: false
        };
      }
      var view = this.createView();
      var time = Date.now();
      if (time > this._endTime) {
        view = this._dstView;
        this.reset();
        return {
          success: true,
          view
        };
      }
      var factor = (time - this._startTime) / (this._endTime - this._startTime);
      view.position.copy(this._srcView.position);
      view.position.lerp(this._dstView.position, factor);
      view.scale = (1 - factor) * this._srcView.scale + factor * this._dstView.scale;
      view.orientation.copy(this._srcView.orientation);
      view.orientation.slerp(this._dstView.orientation, factor);
      return {
        success: true,
        view
      };
    }
  }, {
    key: "reset",
    value: function reset2() {
      this._startTime = this._endTime = 0;
      this._isMoving = false;
    }
  }, {
    key: "pause",
    value: function pause() {
      if (!this._isPaused) {
        this.setup(this.getCurrentView().view, this._dstView);
        this._isPaused = true;
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this._isPaused = false;
    }
  }, {
    key: "createView",
    value: function createView() {
      return new View();
    }
  }]);
  return ViewInterpolator2;
}();
var MAX_COOKIE_LEN = 4e3;
var COUNT_SUFFIX = "Cnt";
function _chunkString(string5, chunkLen) {
  var l2 = string5.length;
  var chunks = [];
  for (var c2 = 0, lc = 0; lc < l2; c2++, lc += chunkLen) {
    chunks[c2] = string5.slice(lc, lc + chunkLen);
  }
  return chunks;
}
function Cookies(context, opts) {
  this.context = context;
  this._opts = (0, import_lodash.merge)({
    path: "/"
  }, opts);
}
makeContextDependent(Cookies.prototype);
Cookies.prototype.removeCookie = function(key) {
  var cntKey = this._toCount(key);
  var cntVal = this._getSimpleCookie(cntKey);
  if (!cntVal) {
    this._removeSimpleCookie(key);
    return;
  }
  this._removeSimpleCookie(cntKey);
  cntVal = parseInt(cntVal, 10);
  for (var i2 = 0; i2 < cntVal; ++i2) {
    this._removeSimpleCookie(key + i2);
  }
};
Cookies.prototype.setCookie = function(key, value) {
  this.removeCookie(key);
  value = encodeURIComponent(value);
  var values = _chunkString(value, MAX_COOKIE_LEN - key.length - 1);
  var cntVal = values.length;
  if (cntVal === 1) {
    this._setSimpleCookie(key, value);
    return;
  }
  var cntKey = this._toCount(key);
  this._setSimpleCookie(cntKey, cntVal.toString());
  for (var i2 = 0; i2 < cntVal; ++i2) {
    this._setSimpleCookie(key + i2, values[i2]);
  }
};
Cookies.prototype.getCookie = function(key) {
  var cntKey = this._toCount(key);
  var cntVal = this._getSimpleCookie(cntKey);
  if (!cntVal) {
    return this._getSimpleCookie(key);
  }
  cntVal = parseInt(cntVal, 10);
  var value = [];
  for (var i2 = 0; i2 < cntVal; ++i2) {
    value[i2] = this._getSimpleCookie(key + i2);
  }
  return value.join("");
};
Cookies.prototype._toCount = function(key) {
  return key + COUNT_SUFFIX;
};
Cookies.prototype._removeSimpleCookie = function(key) {
  document.cookie = "".concat(key, "=; expires=Thu, 01 Jan 1970 00:00:01 GMT;");
};
Cookies.prototype._getExpirationDate = function() {
  var today = /* @__PURE__ */ new Date();
  var EXP_PERIOD_YEARS = 10;
  today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS);
  return today;
};
Cookies.prototype._setSimpleCookie = function(key, value) {
  document.cookie = "".concat(key, "=").concat(value, ";expires=").concat(this._getExpirationDate().toUTCString(), ";path=").concat(this._opts.path);
};
Cookies.prototype._getSimpleCookie = function(key) {
  var matches = document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
  return matches ? decodeURIComponent(matches[1]) : "";
};
Cookies.prototype._exists = function(key) {
  return document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
};
function createWebVRButton(webVRPoC) {
  function showEnterVR(button2) {
    button2.style.display = "";
    button2.style.cursor = "pointer";
    button2.style.left = "calc(50% - 50px)";
    button2.style.width = "100px";
    button2.textContent = "ENTER VR";
    var currentSession = null;
    function onSessionEnded() {
      currentSession.removeEventListener("end", onSessionEnded);
      button2.textContent = "ENTER VR";
      currentSession = null;
    }
    function onSessionStarted(session) {
      session.addEventListener("end", onSessionEnded);
      webVRPoC._gfx.renderer.xr.setReferenceSpaceType("local");
      webVRPoC._gfx.renderer.xr.setSession(session);
      button2.textContent = "EXIT VR";
      currentSession = session;
    }
    button2.onmouseenter = function() {
      button2.style.opacity = "1.0";
    };
    button2.onmouseleave = function() {
      button2.style.opacity = "0.5";
    };
    button2.onclick = function() {
      if (currentSession === null) {
        var sessionInit = {
          optionalFeatures: ["local-floor", "bounded-floor"]
        };
        navigator.xr.requestSession("immersive-vr", sessionInit).then(onSessionStarted);
        webVRPoC.moveSceneBehindHeadset();
      } else {
        currentSession.end();
      }
    };
  }
  function showWebXRNotFound(button2) {
    button2.style.display = "";
    button2.style.cursor = "auto";
    button2.style.left = "calc(50% - 75px)";
    button2.style.width = "150px";
    button2.textContent = "VR NOT FOUND";
    button2.onmouseenter = null;
    button2.onmouseleave = null;
    button2.onclick = null;
  }
  function stylizeElement(element) {
    element.style.position = "absolute";
    element.style.bottom = "20px";
    element.style.padding = "12px 6px";
    element.style.border = "1px solid #fff";
    element.style.borderRadius = "4px";
    element.style.background = "transparent";
    element.style.color = "#fff";
    element.style.font = "normal 13px sans-serif";
    element.style.textAlign = "center";
    element.style.opacity = "0.5";
    element.style.outline = "none";
    element.style.zIndex = "999";
  }
  if ("xr" in navigator) {
    var button = document.createElement("button");
    button.style.display = "none";
    stylizeElement(button);
    navigator.xr.isSessionSupported("immersive-vr").then(function(supported) {
      return supported ? showEnterVR(button) : showWebXRNotFound(button);
    });
    return button;
  }
  var message = document.createElement("a");
  message.href = "https://webvr.info";
  message.innerHTML = "WEBXR NOT SUPPORTED";
  message.style.left = "calc(50% - 90px)";
  message.style.width = "180px";
  message.style.textDecoration = "none";
  stylizeElement(message);
  return message;
}
var WebVRPoC = function() {
  function WebVRPoC2(onToggle) {
    _classCallCheck(this, WebVRPoC2);
    this._mainCamera = new PerspectiveCamera();
    this._button = null;
    this._onToggle = onToggle;
    this._molContainer = new gfxutils.RCGroup();
    this._user = new gfxutils.RCGroup();
    this._scalingPivot = new Object3D();
    this._user.add(this._scalingPivot);
    this._controller1 = null;
    this._controller2 = null;
    this._pressedGripsCounter = 0;
    this._distance = 0;
    this._gfx = null;
  }
  _createClass(WebVRPoC2, [{
    key: "startScalingByControllers",
    value: function startScalingByControllers() {
      this._distance = this._controller1.position.distanceTo(this._controller2.position);
      gfxutils.getMiddlePoint(this._controller1.position, this._controller2.position, this._scalingPivot.position);
      this._scalingPivot.scale.set(1, 1, 1);
      this._scalingPivot.updateMatrix();
      this._scalingPivot.updateMatrixWorld();
      this._scalingPivot.addSavingWorldTransform(this._molContainer);
    }
  }, {
    key: "stopScalingByControllers",
    value: function stopScalingByControllers() {
      this._gfx.scene.addSavingWorldTransform(this._molContainer);
    }
  }, {
    key: "handleGripsDown",
    value: function handleGripsDown(event) {
      this._pressedGripsCounter++;
      if (this._pressedGripsCounter === 2) {
        this.startScalingByControllers();
      } else if (this._pressedGripsCounter === 1) {
        event.target.addSavingWorldTransform(this._molContainer);
      }
    }
  }, {
    key: "handleGripsUp",
    value: function handleGripsUp(event) {
      this._pressedGripsCounter--;
      if (this._pressedGripsCounter === 1) {
        this.stopScalingByControllers();
        var anotherController = event.target === this._controller1 ? this._controller2 : this._controller1;
        anotherController.addSavingWorldTransform(this._molContainer);
      } else if (this._pressedGripsCounter === 0) {
        this._gfx.scene.addSavingWorldTransform(this._molContainer);
      }
    }
  }, {
    key: "enable",
    value: function enable(gfx) {
      if (!gfx) {
        logger.warn("WebVR couldn't be enabled, because gfx is not defined");
        return;
      }
      this._gfx = gfx;
      var renderer = gfx.renderer, camera = gfx.camera;
      if (!renderer) {
        throw new Error("No renderer is available to toggle WebVR");
      }
      if (!camera) {
        throw new Error("No camera is available to toggle WebVR");
      }
      renderer.xr.enabled = true;
      if (!this._button) {
        this._button = createWebVRButton(this);
        document.body.appendChild(this._button);
      } else {
        this._button.style.display = "block";
      }
      this._mainFog = settings$1.now.fog;
      settings$1.set("fog", false);
      this._plugVRNodesIntoScene(gfx, renderer);
      this._setControllersListeners();
      if (this._onToggle) {
        this._onToggle(true);
      }
    }
  }, {
    key: "_plugVRNodesIntoScene",
    value: function _plugVRNodesIntoScene(gfx, renderer) {
      this._mainCamera.copy(gfx.camera);
      gfx.scene.add(this._user);
      gfx.scene.add(this._molContainer);
      this._molContainer.add(gfx.root);
      this._controller1 = renderer.xr.getController(0);
      this._controller2 = renderer.xr.getController(1);
      var mesh = this._createControllerMesh();
      this._controller1.add(mesh);
      this._controller2.add(mesh.clone());
      this._user.add(this._controller1);
      this._user.add(this._controller2);
    }
  }, {
    key: "_setControllersListeners",
    value: function _setControllersListeners() {
      var _this = this;
      this._controller1.addEventListener("selectstart", function(event) {
        _this.handleGripsDown(event);
      });
      this._controller1.addEventListener("selectend", function(event) {
        _this.handleGripsUp(event);
      });
      this._controller2.addEventListener("selectstart", function(event) {
        _this.handleGripsDown(event);
      });
      this._controller2.addEventListener("selectend", function(event) {
        _this.handleGripsUp(event);
      });
      this._controller1.addEventListener("squeezestart", function(event) {
        _this.handleGripsDown(event);
      });
      this._controller1.addEventListener("squeezeend", function(event) {
        _this.handleGripsUp(event);
      });
      this._controller2.addEventListener("squeezestart", function(event) {
        _this.handleGripsDown(event);
      });
      this._controller2.addEventListener("squeezeend", function(event) {
        _this.handleGripsUp(event);
      });
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this._gfx) {
        return;
      }
      var _this$_gfx = this._gfx, renderer = _this$_gfx.renderer, camera = _this$_gfx.camera;
      if (!renderer) {
        throw new Error("No renderer is available to toggle WebVR");
      }
      renderer.setAnimationLoop(null);
      var session = renderer.xr.getSession();
      if (session) {
        session.end();
      }
      renderer.xr.enabled = false;
      if (this._button) {
        this._button.style.display = "none";
      }
      settings$1.set("fog", this._mainFog);
      this._unplugVRNodesFromScene(camera);
      if (this._onToggle) {
        this._onToggle(false);
      }
    }
  }, {
    key: "_unplugVRNodesFromScene",
    value: function _unplugVRNodesFromScene(camera) {
      if (this._mainCamera && camera) {
        camera.copy(this._mainCamera);
      }
      var root = this._molContainer.children[0];
      if (root) {
        this._gfx.scene.add(root);
      }
      this._molContainer.parent.remove(this._molContainer);
      if (this._user) {
        this._gfx.scene.remove(this._user);
      }
      this._molContainer = null;
      this._user = null;
      this._scalingPivot = null;
      this._user = null;
      this._controller1 = null;
      this._controller2 = null;
    }
  }, {
    key: "_createControllerMesh",
    value: function _createControllerMesh() {
      var geometry = new CylinderGeometry(0.04, 0.04, 0.3);
      var material2 = new UberMaterial();
      material2.setValues({
        lights: false,
        overrideColor: true
      });
      material2.setUberOptions({
        fixedColor: new Color(4474111)
      });
      material2.updateUniforms();
      var cylinder = new Mesh(geometry, material2);
      cylinder.rotateX(-Math.PI / 2);
      return cylinder;
    }
  }, {
    key: "updateMoleculeScale",
    value: function updateMoleculeScale() {
      if (!this._controller1 || !this._controller2) {
        return;
      }
      var self2 = this;
      if (self2._pressedGripsCounter === 2) {
        gfxutils.getMiddlePoint(self2._controller1.position, self2._controller2.position, self2._scalingPivot.position);
        var dist = self2._controller1.position.distanceTo(self2._controller2.position);
        var scaler = dist / self2._distance;
        self2._scalingPivot.scale.multiplyScalar(scaler);
        self2._distance = dist;
      }
    }
  }, {
    key: "moveSceneBehindHeadset",
    value: function moveSceneBehindHeadset() {
      var gfx = this._gfx;
      var camera = gfx.camera;
      var container = this._molContainer;
      container.matrix.identity();
      container.position.set(0, 0, -4);
      container.updateMatrix();
      container.matrixWorld.multiplyMatrices(camera.matrixWorld, container.matrix);
      gfx.scene.addSavingWorldTransform(container);
      if (this._onToggle) {
        this._onToggle(true);
      }
    }
  }, {
    key: "getCanvas",
    value: function getCanvas() {
      var gfx = this._gfx;
      return gfx && gfx.renderer ? gfx.renderer.domElement : null;
    }
  }]);
  return WebVRPoC2;
}();
var fragmentScreenQuadFromDistTex = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform vec3 aberration;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  \r\n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\r\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\r\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\r\n  gl_FragColor.a = 1.0;\r\n}";
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var selectors$1 = chem.selectors;
var Atom = chem.Atom;
var Residue = chem.Residue;
var Chain = chem.Chain;
var Molecule = chem.Molecule;
var EDIT_MODE = {
  COMPLEX: 0,
  COMPONENT: 1,
  FRAGMENT: 2
};
var LOADER_NOT_FOUND = "Could not find suitable loader for this source";
var PARSER_NOT_FOUND = "Could not find suitable parser for this source";
var createElement = utils.createElement;
function updateFogRange(fog, center, radius) {
  fog.near = center - radius * settings$1.now.fogNearFactor;
  fog.far = center + radius * settings$1.now.fogFarFactor;
}
function removeExtension(fileName) {
  var dot = fileName.lastIndexOf(".");
  if (dot >= 0) {
    fileName = fileName.substr(0, dot);
  }
  return fileName;
}
function hasValidResidues(complex) {
  var hasValidRes = false;
  complex.forEachComponent(function(component) {
    component.forEachResidue(function(residue2) {
      if (residue2._isValid) {
        hasValidRes = true;
      }
    });
  });
  return hasValidRes;
}
function reportProgress(log, action, percent) {
  var TOTAL_PERCENT = 100;
  if (percent !== void 0) {
    log.debug("".concat(action, "... ").concat(Math.floor(percent * TOTAL_PERCENT), "%"));
  } else {
    log.debug("".concat(action, "..."));
  }
}
function chooseFogColor() {
  return settings$1.now.fogColorEnable ? settings$1.now.fogColor : settings$1.now.bg.color;
}
function _setContainerContents(container, element) {
  var parent = container;
  while (parent.firstChild) {
    parent.removeChild(parent.firstChild);
  }
  parent.appendChild(element);
}
function arezSpritesSupported(context) {
  return context.getExtension("EXT_frag_depth");
}
function isAOSupported(context) {
  return context.getExtension("WEBGL_depth_texture") && context.getExtension("WEBGL_draw_buffers");
}
var rePdbId = /^(?:(pdb|cif|mmtf|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i;
var rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i;
var reUrlScheme = /^([a-z][a-z\d\-+.]*):/i;
function resolveSourceShortcut(source, opts) {
  if (!(0, import_lodash.isString)(source)) {
    return source;
  }
  var matchesPdbId = rePdbId.exec(source);
  if (matchesPdbId) {
    var _matchesPdbId = _slicedToArray(matchesPdbId, 3), _matchesPdbId$ = _matchesPdbId[1], format = _matchesPdbId$ === void 0 ? "pdb" : _matchesPdbId$, id = _matchesPdbId[2];
    format = format.toLowerCase();
    id = id.toUpperCase();
    switch (format) {
      case "pdb":
        source = "https://files.rcsb.org/download/".concat(id, ".pdb");
        break;
      case "cif":
        source = "https://files.rcsb.org/download/".concat(id, ".cif");
        break;
      case "mmtf":
        source = "https://mmtf.rcsb.org/v1.0/full/".concat(id);
        break;
      case "ccp4":
        source = "https://www.ebi.ac.uk/pdbe/coordinates/files/".concat(id.toLowerCase(), ".ccp4");
        break;
      case "dsn6":
        source = "https://edmaps.rcsb.org/maps/".concat(id.toLowerCase(), "_2fofc.dsn6");
        break;
      default:
        throw new Error("Unexpected data format shortcut");
    }
    opts.fileType = format;
    opts.fileName = "".concat(id, ".").concat(format);
    opts.sourceType = "url";
    return source;
  }
  var matchesPubchem = rePubchem.exec(source);
  if (matchesPubchem) {
    var compound = matchesPubchem[1].toLowerCase();
    source = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/".concat(compound, "/JSON?record_type=3d");
    opts.fileType = "pubchem";
    opts.fileName = "".concat(compound, ".json");
    opts.sourceType = "url";
    return source;
  }
  if (opts.sourceType === "url" || opts.sourceType === void 0) {
    opts.sourceType = "url";
    if (!reUrlScheme.test(source)) {
      source = utils.resolveURL(source);
    }
  }
  return source;
}
function updateBinaryMode(opts) {
  var binary = opts.binary;
  if (opts.fileType !== void 0) {
    var TheParser = (0, import_lodash.head)(io.parsers.find({
      format: opts.fileType
    }));
    if (TheParser) {
      binary = TheParser.binary || false;
    } else {
      throw new Error("Could not find suitable parser for this format");
    }
  }
  if (binary === void 0 && opts.fileExt !== void 0) {
    var _TheParser = (0, import_lodash.head)(io.parsers.find({
      ext: opts.fileExt
    }));
    if (_TheParser) {
      binary = _TheParser.binary || false;
    }
  }
  if (opts.fileExt !== void 0 && opts.fileExt.toLowerCase() === ".man") {
    opts.binary = true;
    opts.animation = true;
  }
  if (binary !== void 0) {
    if (opts.binary !== void 0 && opts.binary !== binary) {
      opts.context.logger.warn("Overriding incorrect binary mode");
    }
  }
  opts.binary = binary || false;
}
function _fetchData(source, opts, job) {
  return new Promise(function(resolve) {
    if (job.shouldCancel()) {
      throw new Error("Operation cancelled");
    }
    job.notify({
      type: "fetching"
    });
    source = resolveSourceShortcut(source, opts);
    var TheLoader = (0, import_lodash.head)(io.loaders.find({
      type: opts.sourceType,
      source
    }));
    if (!TheLoader) {
      throw new Error(LOADER_NOT_FOUND);
    }
    var fileName = opts.fileName || TheLoader.extractName(source);
    if (fileName) {
      var _utils$splitFileName = utils.splitFileName(fileName), _utils$splitFileName2 = _slicedToArray(_utils$splitFileName, 2), name2 = _utils$splitFileName2[0], fileExt = _utils$splitFileName2[1];
      (0, import_lodash.defaults)(opts, {
        name: name2,
        fileExt,
        fileName
      });
    }
    updateBinaryMode(opts);
    var newOptions = (0, import_lodash.get)(opts, "preset.expression");
    if (!(0, import_lodash.isUndefined)(newOptions)) {
      newOptions = JSON.parse(newOptions);
      if (newOptions && newOptions.settings) {
        var keys2 = ["singleUnit"];
        for (var keyIndex = 0, keyCount = keys2.length; keyIndex < keyCount; ++keyIndex) {
          var key = keys2[keyIndex];
          var value = (0, import_lodash.get)(newOptions.settings, key);
          if (!(0, import_lodash.isUndefined)(value)) {
            settings$1.set(key, value);
          }
        }
      }
    }
    var loader = new TheLoader(source, opts);
    loader.context = opts.context;
    job.addEventListener("cancel", function() {
      return loader.abort();
    });
    loader.addEventListener("progress", function(event) {
      if (event.lengthComputable && event.total > 0) {
        reportProgress(loader.logger, "Fetching", event.loaded / event.total);
      } else {
        reportProgress(loader.logger, "Fetching");
      }
    });
    console.time("fetch");
    var promise4 = loader.load().then(function(data) {
      console.timeEnd("fetch");
      opts.context.logger.info("Fetching finished");
      job.notify({
        type: "fetchingDone",
        data
      });
      return data;
    }).catch(function(error) {
      console.timeEnd("fetch");
      opts.context.logger.debug(error.message);
      if (error.stack) {
        opts.context.logger.debug(error.stack);
      }
      opts.context.logger.error("Fetching failed");
      job.notify({
        type: "fetchingDone",
        error
      });
      throw error;
    });
    resolve(promise4);
  });
}
function _parseData(data, opts, job) {
  if (job.shouldCancel()) {
    return Promise.reject(new Error("Operation cancelled"));
  }
  job.notify({
    type: "parsing"
  });
  var TheParser = (0, import_lodash.head)(io.parsers.find({
    format: opts.fileType,
    ext: opts.fileExt,
    data
  }));
  if (!TheParser) {
    return Promise.reject(new Error("Could not find suitable parser"));
  }
  var parser2 = new TheParser(data, opts);
  parser2.context = opts.context;
  job.addEventListener("cancel", function() {
    return parser2.abort();
  });
  console.time("parse");
  return parser2.parse().then(function(dataSet) {
    console.timeEnd("parse");
    job.notify({
      type: "parsingDone",
      data: dataSet
    });
    return dataSet;
  }).catch(function(error) {
    console.timeEnd("parse");
    opts.error = error;
    opts.context.logger.debug(error.message);
    if (error.stack) {
      opts.context.logger.debug(error.stack);
    }
    opts.context.logger.error("Parsing failed");
    job.notify({
      type: "parsingDone",
      error
    });
    throw error;
  });
}
function _includesInCurSelection(atom, selectionBit) {
  return atom.mask & 1 << selectionBit;
}
function _includesInSelector(atom, selector) {
  return selector.selector.includesAtom(atom);
}
var Miew = function(_EventDispatcher) {
  _inherits(Miew2, _EventDispatcher);
  var _super = _createSuper(Miew2);
  function Miew2(opts) {
    var _this;
    _classCallCheck(this, Miew2);
    _this = _super.call(this);
    _this._opts = (0, import_lodash.merge)({
      settingsCookie: "settings",
      cookiePath: "/"
    }, opts);
    _this._gfx = null;
    _this._interpolator = new ViewInterpolator();
    _this._container = opts && opts.container || document.getElementById("miew-container") || (0, import_lodash.head)(document.getElementsByClassName("miew-container")) || document.body;
    _this._containerRoot = _this._container;
    _this._running = false;
    _this._halting = false;
    _this._building = false;
    _this._needRender = true;
    _this._hotKeysEnabled = true;
    _this.settings = settings$1;
    var log = logger;
    log.console = false;
    log.level = "info";
    _this.logger = log;
    _this._cookies = new Cookies(_assertThisInitialized(_this));
    _this.restoreSettings();
    if (opts && opts.settings) {
      _this.settings.set(opts.settings);
    }
    _this._spinner = null;
    _this._loading = [];
    _this._animInterval = null;
    _this._visuals = {};
    _this._curVisualName = null;
    _this._objects = [];
    _this._sourceWindow = null;
    _this.reset();
    if (_this._repr) {
      log.debug("Selected ".concat(_this._repr.mode.name, " mode with ").concat(_this._repr.colorer.name, " colorer."));
    }
    var self2 = _assertThisInitialized(_this);
    Miew2.registeredPlugins.forEach(function(plugin) {
      plugin.call(self2);
    });
    _this._initOnSettingsChanged();
    _this.shadowMatrix = new Matrix4();
    _this.direction = new Vector3();
    _this.OBB = {
      center: new Vector3(),
      halfSize: new Vector3()
    };
    _this._bSphereForOneVisual = new Sphere();
    _this._bBoxForOneVisual = new Box3();
    _this._bBox = new Box3();
    _this._invMatrix = new Matrix4();
    _this._points = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
    _this._anaglyphMat = new AnaglyphMaterial();
    _this._size = new Vector2();
    _this._scene = new Scene();
    _this._camera = new OrthographicCamera(-1, 1, 1, -1, -500, 1e3);
    _this._material = new RawShaderMaterial({
      uniforms: {
        srcTex: {
          type: "t",
          value: null
        },
        aberration: {
          type: "fv3",
          value: new Vector3(1)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentScreenQuadFromDistTex,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    _this._geo = gfxutils.buildDistorionMesh(10, 10, settings$1.now.debug.stereoBarrel);
    _this._outlineMaterial = new OutlineMaterial({
      depth: true
    });
    _this.pars = {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat
    };
    _this.VERSION = "0.10.0+20220125.134627.b36f6a2-mod";
    return _this;
  }
  _createClass(Miew2, [{
    key: "getMaxRepresentationCount",
    value: function getMaxRepresentationCount() {
      return ComplexVisual.NUM_REPRESENTATION_BITS;
    }
  }, {
    key: "_updateShadowCamera",
    value: function _updateShadowCamera() {
      this._gfx.scene.updateMatrixWorld();
      for (var i2 = 0; i2 < this._gfx.scene.children.length; i2++) {
        if (this._gfx.scene.children[i2].type === "DirectionalLight") {
          var light = this._gfx.scene.children[i2];
          this.shadowMatrix.copy(light.shadow.camera.matrixWorldInverse);
          this.getOBB(this.shadowMatrix, this.OBB);
          this.direction.subVectors(light.target.position, light.position);
          light.position.subVectors(this.OBB.center, this.direction);
          light.target.position.copy(this.OBB.center);
          light.shadow.bias = 0.09;
          light.shadow.camera.bottom = -this.OBB.halfSize.y;
          light.shadow.camera.top = this.OBB.halfSize.y;
          light.shadow.camera.right = this.OBB.halfSize.x;
          light.shadow.camera.left = -this.OBB.halfSize.x;
          light.shadow.camera.near = this.direction.length() - this.OBB.halfSize.z;
          light.shadow.camera.far = this.direction.length() + this.OBB.halfSize.z;
          light.shadow.camera.updateProjectionMatrix();
        }
      }
    }
  }, {
    key: "init",
    value: function init2() {
      var container = this._container;
      var elem2 = utils.createElement("div", {
        class: "miew-canvas"
      });
      _setContainerContents(container, elem2);
      this._container = elem2;
      var frag = document.createDocumentFragment();
      frag.appendChild(this._msgMode = createElement("div", {
        class: "mode-message overlay"
      }, createElement("p", {}, "COMPONENT EDIT MODE")));
      frag.appendChild(this._msgAtomInfo = createElement("div", {
        class: "atom-info overlay"
      }, createElement("p", {}, "")));
      container.appendChild(frag);
      if (this._gfx !== null) {
        return true;
      }
      var self2 = this;
      this._showMessage("Viewer is being initialized...");
      try {
        this._initGfx();
        this._initListeners();
        this._spinner = new Spinner({
          lines: 13,
          length: 28,
          width: 14,
          radius: 42,
          color: "#fff",
          zIndex: 700
        });
        window.top.addEventListener("keydown", function(event) {
          self2._onKeyDown(event);
        });
        window.top.addEventListener("keyup", function(event) {
          self2._onKeyUp(event);
        });
        this._objectControls = new ObjectControls(this._gfx.root, this._gfx.pivot, this._gfx.camera, this._gfx.renderer.domElement, function() {
          return self2._getAltObj();
        });
        this._objectControls.addEventListener("change", function(e2) {
          if (settings$1.now.shadow.on) {
            self2._updateShadowCamera();
          }
          switch (e2.action) {
            case "rotate":
              self2.dispatchEvent({
                type: "rotate",
                quaternion: e2.quaternion
              });
              break;
            case "zoom":
              self2.dispatchEvent({
                type: "zoom",
                factor: e2.factor
              });
              break;
            default:
              self2.dispatchEvent({
                type: e2.action
              });
          }
          self2.dispatchEvent({
            type: "transform"
          });
          self2._needRender = true;
        });
        var gfx = this._gfx;
        this._picker = new Picker(gfx.root, gfx.camera, gfx.renderer.domElement);
        this._picker.addEventListener("newpick", function(event) {
          self2._onPick(event);
        });
        this._picker.addEventListener("dblclick", function(event) {
          self2.center(event);
        });
      } catch (error) {
        if (error.name === "TypeError" && error.message === "Cannot read property 'getExtension' of null") {
          this._showMessage("Could not create WebGL context.");
        } else if (error.message.search(/webgl/i) > 1) {
          this._showMessage(error.message);
        } else {
          this._showMessage("Viewer initialization failed.");
          throw error;
        }
        return false;
      }
      var file = this._opts && this._opts.load;
      if (file) {
        var type = this._opts && this._opts.type;
        this.load(file, {
          fileType: type,
          keepRepsInfo: true
        });
      }
      return true;
    }
  }, {
    key: "term",
    value: function term() {
      this._showMessage("Viewer has been terminated.");
      this._loading.forEach(function(job) {
        job.cancel();
      });
      this._loading.length = 0;
      this.halt();
      this._gfx = null;
    }
  }, {
    key: "_showMessage",
    value: function _showMessage(msg) {
      var element = document.createElement("div");
      element.setAttribute("class", "miew-message");
      element.appendChild(document.createElement("p")).appendChild(document.createTextNode(msg));
      _setContainerContents(this._container, element);
    }
  }, {
    key: "_showCanvas",
    value: function _showCanvas() {
      _setContainerContents(this._container, this._gfx.renderer.domElement);
    }
  }, {
    key: "_requestAnimationFrame",
    value: function _requestAnimationFrame(callback) {
      var xr = this._gfx.renderer.xr;
      if (xr && xr.enabled) {
        this._gfx.renderer.setAnimationLoop(callback);
        return;
      }
      requestAnimationFrame(callback);
    }
  }, {
    key: "_initGfx",
    value: function _initGfx() {
      var gfx = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };
      var webGLOptions = {
        preserveDrawingBuffer: true,
        alpha: true,
        premultipliedAlpha: false
      };
      if (settings$1.now.antialias) {
        webGLOptions.antialias = true;
      }
      gfx.renderer2d = new CSS2DRenderer();
      gfx.renderer = new WebGL1Renderer(webGLOptions);
      gfx.renderer.shadowMap.enabled = settings$1.now.shadow.on;
      gfx.renderer.shadowMap.autoUpdate = false;
      gfx.renderer.shadowMap.type = PCFShadowMap;
      capabilities.init(gfx.renderer);
      if (!arezSpritesSupported(gfx.renderer.getContext())) {
        settings$1.set("zSprites", false);
      }
      if (!isAOSupported(gfx.renderer.getContext())) {
        settings$1.set("ao", false);
      }
      gfx.renderer.autoClear = false;
      gfx.renderer.setPixelRatio(window.devicePixelRatio);
      gfx.renderer.setSize(gfx.width, gfx.height);
      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      gfx.renderer.clearColor();
      gfx.renderer2d.setSize(gfx.width, gfx.height);
      gfx.camera = new PerspectiveCamera(settings$1.now.camFov, gfx.width / gfx.height, settings$1.now.camNear, settings$1.now.camFar);
      gfx.camera.setMinimalFov(settings$1.now.camFov);
      gfx.camera.position.z = settings$1.now.camDistance;
      gfx.camera.updateProjectionMatrix();
      gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT);
      gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME);
      gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE);
      gfx.stereoCam = new StereoCamera();
      gfx.scene = new Scene();
      var color2 = chooseFogColor();
      gfx.scene.fog = new Fog(color2, settings$1.now.camNear, settings$1.now.camFar);
      gfx.root = new gfxutils.RCGroup();
      gfx.scene.add(gfx.root);
      gfx.pivot = new gfxutils.RCGroup();
      gfx.root.add(gfx.pivot);
      gfx.selectionScene = new Scene();
      gfx.selectionRoot = new Group();
      gfx.selectionRoot.matrixAutoUpdate = false;
      gfx.selectionScene.add(gfx.selectionRoot);
      gfx.selectionPivot = new Group();
      gfx.selectionPivot.matrixAutoUpdate = false;
      gfx.selectionRoot.add(gfx.selectionPivot);
      var light12 = new DirectionalLight(16777215, 0.45);
      light12.position.set(0, 0.414, 1);
      light12.layers.enable(gfxutils.LAYERS.TRANSPARENT);
      light12.castShadow = true;
      light12.shadow.bias = 0.09;
      light12.shadow.radius = settings$1.now.shadow.radius;
      light12.shadow.camera.layers.set(gfxutils.LAYERS.SHADOWMAP);
      var pixelRatio = gfx.renderer.getPixelRatio();
      var shadowMapSize = Math.max(gfx.width, gfx.height) * pixelRatio;
      light12.shadow.mapSize.width = shadowMapSize;
      light12.shadow.mapSize.height = shadowMapSize;
      light12.target.position.set(0, 0, 0);
      gfx.scene.add(light12);
      gfx.scene.add(light12.target);
      var light3 = new AmbientLight(6710886);
      light3.layers.enable(gfxutils.LAYERS.TRANSPARENT);
      gfx.scene.add(light3);
      gfx.axes = new Axes(gfx.root, gfx.camera);
      var deviceWidth = gfx.width * pixelRatio;
      var deviceHeight = gfx.height * pixelRatio;
      gfx.offscreenBuf = new WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: LinearFilter,
        magFilter: NearestFilter,
        format: RGBAFormat,
        depthBuffer: true
      });
      if (gfx.renderer.getContext().getExtension("WEBGL_depth_texture")) {
        gfx.offscreenBuf.depthTexture = new DepthTexture();
        gfx.offscreenBuf.depthTexture.type = UnsignedShortType;
      }
      gfx.offscreenBuf2 = new WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        depthBuffer: false
      });
      gfx.offscreenBuf3 = new WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        depthBuffer: false
      });
      gfx.offscreenBuf4 = new WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        depthBuffer: false
      });
      gfx.volBFTex = gfx.offscreenBuf3;
      gfx.volFFTex = gfx.offscreenBuf4;
      gfx.volWFFTex = gfx.offscreenBuf;
      if (gfx.renderer.getContext().getExtension("OES_texture_float")) {
        gfx.offscreenBuf5 = new WebGLRenderTarget(deviceWidth, deviceHeight, {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat,
          type: FloatType,
          depthBuffer: false
        });
        gfx.offscreenBuf6 = new WebGLRenderTarget(deviceWidth, deviceHeight, {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat,
          type: FloatType,
          depthBuffer: false
        });
        gfx.offscreenBuf7 = new WebGLRenderTarget(deviceWidth, deviceHeight, {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat,
          type: FloatType,
          depthBuffer: true
        });
        gfx.volBFTex = gfx.offscreenBuf5;
        gfx.volFFTex = gfx.offscreenBuf6;
        gfx.volWFFTex = gfx.offscreenBuf7;
      } else {
        this.logger.warn("Device doesn't support OES_texture_float extension");
      }
      gfx.stereoBufL = new WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        depthBuffer: false
      });
      gfx.stereoBufR = new WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        depthBuffer: false
      });
      this._gfx = gfx;
      this._showCanvas();
      this._embedWebXR(settings$1.now.stereo === "WEBVR");
      this._container.appendChild(gfx.renderer2d.getElement());
      var stats = new Stats();
      stats.domElement.style.position = "absolute";
      stats.domElement.style.right = "0";
      stats.domElement.style.bottom = "0";
      this._container.appendChild(stats.domElement);
      this._fps = stats;
      this._fps.show(settings$1.now.fps);
    }
  }, {
    key: "_initListeners",
    value: function _initListeners() {
      var self2 = this;
      window.addEventListener("resize", function() {
        self2._onResize();
      });
    }
  }, {
    key: "_makeUniqueVisualName",
    value: function _makeUniqueVisualName(baseName) {
      if (!baseName) {
        return Math.random().toString();
      }
      var name2 = baseName;
      var suffix = 1;
      while (this._visuals.hasOwnProperty(name2)) {
        name2 = "".concat(baseName, " (").concat(suffix.toString(), ")");
        suffix++;
      }
      return name2;
    }
  }, {
    key: "_addVisual",
    value: function _addVisual(visual) {
      if (!visual) {
        return null;
      }
      var name2 = this._makeUniqueVisualName(visual.name);
      visual.name = name2;
      this._visuals[name2] = visual;
      this._gfx.pivot.add(visual);
      if (visual.getSelectionGeo) {
        this._gfx.selectionPivot.add(visual.getSelectionGeo());
      }
      return name2;
    }
  }, {
    key: "_removeVisual",
    value: function _removeVisual(visual) {
      var name2 = "";
      var obj = null;
      if (visual instanceof Visual) {
        name2 = visual.name;
        obj = visual;
      } else if (typeof visual === "string") {
        name2 = visual;
        obj = this._visuals[name2];
      }
      if (!obj || !this._visuals.hasOwnProperty(name2) || this._visuals[name2] !== obj) {
        return;
      }
      if (name2 === this._curVisualName) {
        this._curVisualName = void 0;
      }
      delete this._visuals[name2];
      obj.release();
      this._needRender = true;
    }
  }, {
    key: "_forEachVisual",
    value: function _forEachVisual(callback) {
      for (var name2 in this._visuals) {
        if (this._visuals.hasOwnProperty(name2)) {
          callback(this._visuals[name2]);
        }
      }
    }
  }, {
    key: "_releaseAllVisuals",
    value: function _releaseAllVisuals() {
      if (!this._gfx || !this._gfx.pivot) {
        return;
      }
      for (var name2 in this._visuals) {
        if (this._visuals.hasOwnProperty(name2)) {
          this._visuals[name2].release();
        }
      }
      this._visuals = {};
    }
  }, {
    key: "_forEachComplexVisual",
    value: function _forEachComplexVisual(callback) {
      if (!this._gfx || !this._gfx.pivot) {
        return;
      }
      for (var name2 in this._visuals) {
        if (this._visuals.hasOwnProperty(name2) && this._visuals[name2] instanceof ComplexVisual) {
          callback(this._visuals[name2]);
        }
      }
    }
  }, {
    key: "_getComplexVisual",
    value: function _getComplexVisual(name2) {
      name2 = name2 || this._curVisualName;
      var any = null;
      var named = null;
      this._forEachComplexVisual(function(visual) {
        any = visual;
        if (visual.name === name2) {
          named = visual;
        }
      });
      return named || any;
    }
  }, {
    key: "_getVolumeVisual",
    value: function _getVolumeVisual() {
      var any = null;
      this._forEachVisual(function(visual) {
        if (visual instanceof VolumeVisual) {
          any = visual;
        }
      });
      return any;
    }
  }, {
    key: "_getVisualForComplex",
    value: function _getVisualForComplex(complex) {
      if (!complex) {
        return null;
      }
      var found = null;
      this._forEachComplexVisual(function(visual) {
        if (visual.getComplex() === complex) {
          found = visual;
        }
      });
      return found;
    }
  }, {
    key: "getVisuals",
    value: function getVisuals() {
      return Object.keys(this._visuals);
    }
  }, {
    key: "getComplexVisualsCount",
    value: function getComplexVisualsCount() {
      var count = 0;
      this._forEachComplexVisual(function() {
        return count++;
      });
      return count;
    }
  }, {
    key: "getCurrentVisual",
    value: function getCurrentVisual() {
      return this._curVisualName;
    }
  }, {
    key: "setCurrentVisual",
    value: function setCurrentVisual(name2) {
      if (!this._visuals[name2]) {
        return;
      }
      this._curVisualName = name2;
    }
  }, {
    key: "run",
    value: function run() {
      var _this2 = this;
      if (!this._running) {
        this._running = true;
        if (this._halting) {
          this._halting = false;
          return;
        }
        this._objectControls.enable(true);
        this._interpolator.resume();
        this._requestAnimationFrame(function() {
          return _this2._onTick();
        });
      }
    }
  }, {
    key: "halt",
    value: function halt() {
      if (this._running) {
        this._discardComponentEdit();
        this._discardFragmentEdit();
        this._objectControls.enable(false);
        this._interpolator.pause();
        this._halting = true;
      }
    }
  }, {
    key: "enableHotKeys",
    value: function enableHotKeys(enabled) {
      this._hotKeysEnabled = enabled;
      this._objectControls.enableHotkeys(enabled);
    }
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._needRender = true;
      var gfx = this._gfx;
      gfx.width = this._container.clientWidth;
      gfx.height = this._container.clientHeight;
      gfx.camera.aspect = gfx.width / gfx.height;
      gfx.camera.setMinimalFov(settings$1.now.camFov);
      gfx.camera.updateProjectionMatrix();
      gfx.renderer.setSize(gfx.width, gfx.height);
      gfx.renderer2d.setSize(gfx.width, gfx.height);
      this.dispatchEvent({
        type: "resize"
      });
    }
  }, {
    key: "_resizeOffscreenBuffers",
    value: function _resizeOffscreenBuffers(width, height, stereo) {
      var gfx = this._gfx;
      stereo = stereo || "NONE";
      var isAnaglyph = stereo === "NONE" || stereo === "ANAGLYPH";
      var multi = isAnaglyph ? 1 : 0.5;
      gfx.offscreenBuf.setSize(multi * width, height);
      gfx.offscreenBuf2.setSize(multi * width, height);
      gfx.offscreenBuf3.setSize(multi * width, height);
      gfx.offscreenBuf4.setSize(multi * width, height);
      if (gfx.offscreenBuf5) {
        gfx.offscreenBuf5.setSize(multi * width, height);
      }
      if (gfx.offscreenBuf6) {
        gfx.offscreenBuf6.setSize(multi * width, height);
      }
      if (gfx.offscreenBuf7) {
        gfx.offscreenBuf7.setSize(multi * width, height);
      }
      if (isAnaglyph) {
        gfx.stereoBufL.setSize(width, height);
        gfx.stereoBufR.setSize(width, height);
      }
    }
  }, {
    key: "_onTick",
    value: function _onTick() {
      var _this3 = this;
      if (this._halting) {
        this._running = false;
        this._halting = false;
        return;
      }
      this._fps.update();
      this._requestAnimationFrame(function() {
        return _this3._onTick();
      });
      this._onUpdate();
      if (this._needRender) {
        this._onRender();
        this._needRender = !settings$1.now.suspendRender || settings$1.now.stereo === "WEBVR";
      }
    }
  }, {
    key: "_getBSphereRadius",
    value: function _getBSphereRadius() {
      var radius = 0;
      this._forEachVisual(function(visual) {
        radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius);
      });
      return radius * this._objectControls.getScale();
    }
  }, {
    key: "getOBB",
    value: function getOBB(matrix, OBB) {
      var _this4 = this;
      this._bBox.makeEmpty();
      this._forEachVisual(function(visual) {
        _this4._bSphereForOneVisual.copy(visual.getBoundaries().boundingSphere);
        _this4._bSphereForOneVisual.applyMatrix4(visual.matrixWorld).applyMatrix4(matrix);
        _this4._bSphereForOneVisual.getBoundingBox(_this4._bBoxForOneVisual);
        _this4._bBox.union(_this4._bBoxForOneVisual);
      });
      this._bBox.getCenter(OBB.center);
      this._invMatrix.copy(matrix).invert();
      OBB.center.applyMatrix4(this._invMatrix);
      var min = this._bBox.min;
      var max = this._bBox.max;
      this._points[0].set(min.x, min.y, min.z);
      this._points[1].set(max.x, min.y, min.z);
      this._points[2].set(min.x, max.y, min.z);
      this._points[3].set(min.x, min.y, max.z);
      for (var i2 = 0, l2 = this._points.length; i2 < l2; i2++) {
        this._points[i2].applyMatrix4(this._invMatrix);
      }
      OBB.halfSize.set(Math.abs(this._points[0].x - this._points[1].x), Math.abs(this._points[0].y - this._points[2].y), Math.abs(this._points[0].z - this._points[3].z)).multiplyScalar(0.5);
    }
  }, {
    key: "_updateFog",
    value: function _updateFog() {
      var gfx = this._gfx;
      if (settings$1.now.fog) {
        if (typeof gfx.scene.fog === "undefined" || gfx.scene.fog === null) {
          var color2 = chooseFogColor();
          gfx.scene.fog = new Fog(color2);
          this._setUberMaterialValues({
            fog: settings$1.now.fog
          });
        }
        updateFogRange(gfx.scene.fog, gfx.camera.position.z, this._getBSphereRadius());
      } else if (gfx.scene.fog) {
        gfx.scene.fog = void 0;
        this._setUberMaterialValues({
          fog: settings$1.now.fog
        });
      }
    }
  }, {
    key: "_onUpdate",
    value: function _onUpdate() {
      if (this.isScriptingCommandAvailable !== void 0 && this.isScriptingCommandAvailable() && !this._building) {
        this.callNextCmd();
      }
      this._objectControls.update();
      this._forEachComplexVisual(function(visual) {
        visual.getComplex().update();
      });
      if (settings$1.now.autobuild && !this._loading.length && !this._building && this._needRebuild()) {
        this.rebuild();
      }
      if (!this._loading.length && !this._building && !this._needRebuild()) {
        this._updateView();
      }
      this._updateFog();
      if (this._gfx.renderer.xr.enabled) {
        this.webVR.updateMoleculeScale();
      }
    }
  }, {
    key: "_onRender",
    value: function _onRender() {
      var gfx = this._gfx;
      gfx.scene.updateMatrixWorld();
      gfx.camera.updateMatrixWorld();
      this._clipPlaneUpdateValue(this._getBSphereRadius());
      this._fogFarUpdateValue();
      gfx.renderer.setRenderTarget(null);
      gfx.renderer.clear();
      this._renderFrame(settings$1.now.stereo);
    }
  }, {
    key: "_renderFrame",
    value: function _renderFrame(stereo) {
      var gfx = this._gfx;
      var renderer = gfx.renderer;
      renderer.getSize(this._size);
      if (stereo !== "NONE") {
        gfx.camera.focus = gfx.camera.position.z;
        gfx.stereoCam.aspect = 1;
        if (stereo === "ANAGLYPH") {
          gfx.stereoCam.update(gfx.camera);
        } else {
          gfx.stereoCam.updateHalfSized(gfx.camera, settings$1.now.camFov);
        }
      }
      var pixelRatio = gfx.renderer.getPixelRatio();
      this._resizeOffscreenBuffers(this._size.width * pixelRatio, this._size.height * pixelRatio, stereo);
      this._renderShadowMap();
      switch (stereo) {
        case "WEBVR":
        case "NONE":
          this._renderScene(gfx.camera, false);
          break;
        case "SIMPLE":
        case "DISTORTED":
          renderer.setScissorTest(true);
          renderer.setScissor(0, 0, this._size.width / 2, this._size.height);
          renderer.setViewport(0, 0, this._size.width / 2, this._size.height);
          this._renderScene(this._gfx.stereoCam.cameraL, stereo === "DISTORTED");
          renderer.setScissor(this._size.width / 2, 0, this._size.width / 2, this._size.height);
          renderer.setViewport(this._size.width / 2, 0, this._size.width / 2, this._size.height);
          this._renderScene(this._gfx.stereoCam.cameraR, stereo === "DISTORTED");
          renderer.setScissorTest(false);
          break;
        case "ANAGLYPH":
          this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL);
          this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR);
          renderer.setRenderTarget(null);
          this._anaglyphMat.uniforms.srcL.value = gfx.stereoBufL.texture;
          this._anaglyphMat.uniforms.srcR.value = gfx.stereoBufR.texture;
          gfx.renderer.renderScreenQuad(this._anaglyphMat);
          break;
      }
      gfx.renderer2d.render(gfx.scene, gfx.camera);
      if (settings$1.now.axes && gfx.axes && !gfx.renderer.xr.enabled) {
        gfx.axes.render(renderer);
      }
    }
  }, {
    key: "_onBgColorChanged",
    value: function _onBgColorChanged() {
      var gfx = this._gfx;
      var color2 = chooseFogColor();
      if (gfx) {
        if (gfx.scene.fog) {
          gfx.scene.fog.color.set(color2);
        }
        gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      }
      this._needRender = true;
    }
  }, {
    key: "_onFogColorChanged",
    value: function _onFogColorChanged() {
      var gfx = this._gfx;
      var color2 = chooseFogColor();
      if (gfx && gfx.scene.fog) {
        gfx.scene.fog.color.set(color2);
      }
      this._needRender = true;
    }
  }, {
    key: "_setUberMaterialValues",
    value: function _setUberMaterialValues(values) {
      this._gfx.root.traverse(function(obj) {
        if ((obj instanceof Mesh || obj instanceof LineSegments || obj instanceof Line) && obj.material instanceof UberMaterial) {
          obj.material.setValues(values);
          obj.material.needsUpdate = true;
        }
      });
    }
  }, {
    key: "_enableMRT",
    value: function _enableMRT(on2, renderBuffer, textureBuffer) {
      var gfx = this._gfx;
      var gl = gfx.renderer.getContext();
      var ext = gl.getExtension("WEBGL_draw_buffers");
      var properties = gfx.renderer.properties;
      if (!on2) {
        ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, null]);
        return;
      }
      gfx.renderer.setRenderTarget(textureBuffer);
      var tx8 = properties.get(textureBuffer.texture).__webglTexture;
      gl.bindTexture(gl.TEXTURE_2D, tx8);
      gfx.renderer.setRenderTarget(renderBuffer);
      var fb = properties.get(renderBuffer).__webglFramebuffer;
      var tx = properties.get(renderBuffer.texture).__webglTexture;
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      fb.width = renderBuffer.width;
      fb.height = renderBuffer.height;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tx, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, tx8, 0);
      ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL]);
    }
  }, {
    key: "_renderScene",
    value: function _renderScene(camera, distortion, target) {
      distortion = distortion || false;
      target = target || null;
      var gfx = this._gfx;
      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      gfx.renderer.setRenderTarget(target);
      gfx.renderer.clear();
      if (gfx.renderer.xr.enabled) {
        gfx.renderer.render(gfx.scene, camera);
        return;
      }
      gfx.renderer.setClearColor(0, 0);
      gfx.renderer.setRenderTarget(gfx.offscreenBuf4);
      gfx.renderer.clearColor();
      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.clear();
      var bHaveComplexes = this._getComplexVisual() !== null;
      var volumeVisual = this._getVolumeVisual();
      var ssao = bHaveComplexes && settings$1.now.ao;
      if (ssao) {
        this._enableMRT(true, gfx.offscreenBuf, gfx.offscreenBuf4);
      }
      if (settings$1.now.transparency === "prepass") {
        this._renderWithPrepassTransparency(camera, gfx.offscreenBuf);
      } else if (settings$1.now.transparency === "standard") {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.render(gfx.scene, camera);
      }
      if (ssao) {
        this._enableMRT(false, null, null);
      }
      var outline = bHaveComplexes && settings$1.now.outline.on;
      var fxaa = bHaveComplexes && settings$1.now.fxaa;
      var volume = volumeVisual !== null && volumeVisual.getMesh().material != null;
      var dstBuffer = ssao || outline || volume || fxaa || distortion ? gfx.offscreenBuf2 : target;
      var srcBuffer = gfx.offscreenBuf;
      if (ssao) {
        this._performAO(srcBuffer, gfx.offscreenBuf4, gfx.offscreenBuf.depthTexture, dstBuffer, gfx.offscreenBuf3, gfx.offscreenBuf2);
        if (!fxaa && !distortion && !volume && !outline) {
          srcBuffer = dstBuffer;
          dstBuffer = target;
          gfx.renderer.setRenderTarget(dstBuffer);
          gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1);
        }
      } else {
        gfx.renderer.setRenderTarget(dstBuffer);
        gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1);
      }
      if (outline) {
        srcBuffer = dstBuffer;
        dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target;
        if (srcBuffer != null) {
          this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer);
        }
      }
      this._renderSelection(camera, gfx.offscreenBuf, dstBuffer);
      if (volume) {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1);
        dstBuffer = gfx.offscreenBuf;
        this._renderVolume(volumeVisual, camera, dstBuffer, gfx.volBFTex, gfx.volFFTex, gfx.volWFFTex);
        if (!fxaa && !distortion) {
          gfx.renderer.setRenderTarget(target);
          gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1);
        }
      }
      srcBuffer = dstBuffer;
      if (fxaa) {
        dstBuffer = distortion ? gfx.offscreenBuf4 : target;
        this._performFXAA(srcBuffer, dstBuffer);
        srcBuffer = dstBuffer;
      }
      if (distortion) {
        dstBuffer = target;
        this._performDistortion(srcBuffer, dstBuffer, true);
      }
    }
  }, {
    key: "_performDistortion",
    value: function _performDistortion(srcBuffer, targetBuffer, mesh) {
      this._scene.add(new meshes.Mesh(this._geo, this._material));
      this._gfx.renderer.setRenderTarget(targetBuffer);
      this._gfx.renderer.clear();
      if (mesh) {
        this._material.uniforms.srcTex.value = srcBuffer.texture;
        this._material.uniforms.aberration.value.set(0.995, 1, 1.01);
        this._gfx.renderer.render(this._scene, this._camera);
      } else {
        this._gfx.renderer.renderScreenQuadFromTexWithDistortion(srcBuffer, settings$1.now.debug.stereoBarrel);
      }
    }
  }, {
    key: "_renderOutline",
    value: function _renderOutline(camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {
      var self2 = this;
      var gfx = self2._gfx;
      this._outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture;
      this._outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture;
      this._outlineMaterial.uniforms.srcTexSize.value.set(srcDepthBuffer.width, srcDepthBuffer.height);
      this._outlineMaterial.uniforms.color.value = new Color(settings$1.now.outline.color);
      this._outlineMaterial.uniforms.threshold.value = settings$1.now.outline.threshold;
      this._outlineMaterial.uniforms.thickness.value = new Vector2(settings$1.now.outline.thickness, settings$1.now.outline.thickness);
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(this._outlineMaterial);
    }
  }, {
    key: "_renderShadowMap",
    value: function _renderShadowMap() {
      if (!settings$1.now.shadow.on) {
        return;
      }
      var gfx = this._gfx;
      var currentRenderTarget = gfx.renderer.getRenderTarget();
      var activeCubeFace = gfx.renderer.getActiveCubeFace();
      var activeMipmapLevel = gfx.renderer.getActiveMipmapLevel();
      var _state = gfx.renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (var i2 = 0; i2 < gfx.scene.children.length; i2++) {
        if (gfx.scene.children[i2].type === "DirectionalLight") {
          var light = gfx.scene.children[i2];
          if (light.shadow.map == null) {
            light.shadow.map = new WebGLRenderTarget(light.shadow.mapSize.width, light.shadow.mapSize.height, this.pars);
            light.shadow.camera.updateProjectionMatrix();
          }
          light.shadow.updateMatrices(light);
          gfx.renderer.setRenderTarget(light.shadow.map);
          gfx.renderer.clear();
          gfx.renderer.render(gfx.scene, light.shadow.camera);
        }
      }
      gfx.renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    }
  }, {
    key: "_hasSelectionToRender",
    value: function _hasSelectionToRender() {
      var selPivot = this._gfx.selectionPivot;
      for (var i2 = 0; i2 < selPivot.children.length; i2++) {
        var selPivotChild = selPivot.children[i2];
        if (selPivotChild.children.length > 0) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "_renderSelection",
    value: function _renderSelection(camera, srcBuffer, targetBuffer) {
      var _outlineMaterial = new OutlineMaterial();
      var self2 = this;
      var gfx = self2._gfx;
      gfx.renderer.setClearColor("black", 0);
      gfx.renderer.setRenderTarget(srcBuffer);
      gfx.renderer.clear(true, false, false);
      if (self2._hasSelectionToRender()) {
        gfx.selectionRoot.matrix = gfx.root.matrix;
        gfx.selectionPivot.matrix = gfx.pivot.matrix;
        gfx.renderer.render(gfx.selectionScene, camera);
      } else {
        gfx.renderer.renderDummyQuad();
      }
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6);
      _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture;
      _outlineMaterial.uniforms.srcTexSize.value.set(srcBuffer.width, srcBuffer.height);
      gfx.renderer.renderScreenQuad(_outlineMaterial);
    }
  }, {
    key: "_checkVolumeRenderingSupport",
    value: function _checkVolumeRenderingSupport(renderTarget) {
      if (!renderTarget) {
        return false;
      }
      var gfx = this._gfx;
      var oldRT = gfx.renderer.getRenderTarget();
      gfx.renderer.setRenderTarget(renderTarget);
      var context = gfx.renderer.getContext();
      var result = context.checkFramebufferStatus(context.FRAMEBUFFER);
      gfx.renderer.setRenderTarget(oldRT);
      if (result !== context.FRAMEBUFFER_COMPLETE) {
        this.logger.warn("Device doesn't support electron density rendering");
        return false;
      }
      return true;
    }
  }, {
    key: "_renderVolume",
    value: function _renderVolume(volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
      var volumeBFMat = new VolumeMaterial$1.BackFacePosMaterial();
      var volumeFFMat = new VolumeMaterial$1.FrontFacePosMaterial();
      var cubeOffsetMat = new Matrix4().makeTranslation(0.5, 0.5, 0.5);
      var world2colorMat = new Matrix4();
      var volumeRenderingSupported;
      var gfx = this._gfx;
      if (typeof volumeRenderingSupported === "undefined") {
        volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1);
      }
      if (!volumeRenderingSupported) {
        return;
      }
      var mesh = volumeVisual.getMesh();
      mesh.rebuild(gfx.camera);
      gfx.renderer.setClearColor("black", 0);
      gfx.renderer.setRenderTarget(tmpBuf1);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf2);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf1);
      camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeBFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.setRenderTarget(tmpBuf2);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeFFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.scene.overrideMaterial = null;
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
      world2colorMat.copy(mesh.matrixWorld).invert();
      UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(cubeOffsetMat, world2colorMat);
      camera.layers.set(gfxutils.LAYERS.COLOR_FROM_POSITION);
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.render(gfx.scene, camera);
      var vm = mesh.material;
      vm.uniforms._BFRight.value = tmpBuf1.texture;
      vm.uniforms._FFRight.value = tmpBuf2.texture;
      vm.uniforms._WFFRight.value = tmpBuf3.texture;
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.renderer.setRenderTarget(dstBuf);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    }
  }, {
    key: "_renderWithPrepassTransparency",
    value: function _renderWithPrepassTransparency(camera, targetBuffer) {
      var gfx = this._gfx;
      gfx.renderer.setRenderTarget(targetBuffer);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT);
      gfx.renderer.getContext().colorMask(false, false, false, false);
      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.getContext().colorMask(true, true, true, true);
      camera.layers.set(gfxutils.LAYERS.TRANSPARENT);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    }
  }, {
    key: "_performFXAA",
    value: function _performFXAA(srcBuffer, targetBuffer) {
      var _fxaaMaterial = new FXAAMaterial();
      if (typeof srcBuffer === "undefined" || typeof targetBuffer === "undefined") {
        return;
      }
      var gfx = this._gfx;
      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.clear();
      _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture;
      _fxaaMaterial.uniforms.srcTexelSize.value.set(1 / srcBuffer.width, 1 / srcBuffer.height);
      _fxaaMaterial.uniforms.bgColor.value.set(settings$1.now.bg.color);
      if (_fxaaMaterial.bgTransparent !== settings$1.now.bg.transparent) {
        _fxaaMaterial.setValues({
          bgTransparent: settings$1.now.bg.transparent
        });
        _fxaaMaterial.needsUpdate = true;
      }
      gfx.renderer.renderScreenQuad(_fxaaMaterial);
    }
  }, {
    key: "_performAO",
    value: function _performAO(srcColorBuffer, normalBuffer, srcDepthTexture, targetBuffer, tempBuffer, tempBuffer1) {
      var _aoMaterial = new AOMaterial();
      var _horBlurMaterial = new AOHorBlurMaterial();
      var _vertBlurMaterial = new AOVertBlurWithBlendMaterial();
      var _scale2 = new Vector3();
      if (!srcColorBuffer || !normalBuffer || !srcDepthTexture || !targetBuffer || !tempBuffer || !tempBuffer1) {
        return;
      }
      var gfx = this._gfx;
      var tanHalfFOV = Math.tan(MathUtils.DEG2RAD * 0.5 * gfx.camera.fov);
      _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
      _aoMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture;
      _aoMaterial.uniforms.srcTexelSize.value.set(1 / srcColorBuffer.width, 1 / srcColorBuffer.height);
      _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far);
      _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _aoMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      gfx.root.matrix.extractScale(_scale2);
      _aoMaterial.uniforms.kernelRadius.value = settings$1.now.debug.ssaoKernelRadius * _scale2.x;
      _aoMaterial.uniforms.depthThreshold.value = 2 * this._getBSphereRadius();
      _aoMaterial.uniforms.factor.value = settings$1.now.debug.ssaoFactor;
      gfx.renderer.setRenderTarget(tempBuffer1);
      gfx.renderer.renderScreenQuad(_aoMaterial);
      _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture;
      _horBlurMaterial.uniforms.srcTexelSize.value.set(1 / tempBuffer1.width, 1 / tempBuffer1.height);
      _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      gfx.renderer.setRenderTarget(tempBuffer);
      gfx.renderer.renderScreenQuad(_horBlurMaterial);
      _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture;
      _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
      _vertBlurMaterial.uniforms.srcTexelSize.value.set(1 / tempBuffer.width, 1 / tempBuffer.height);
      _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _vertBlurMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _vertBlurMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _vertBlurMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      var fog = gfx.scene.fog;
      if (fog) {
        _vertBlurMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far);
        _vertBlurMaterial.uniforms.fogColor.value.set(fog.color.r, fog.color.g, fog.color.b, settings$1.now.fogAlpha);
      }
      if (_vertBlurMaterial.useFog !== settings$1.now.fog || _vertBlurMaterial.fogTransparent !== settings$1.now.bg.transparent) {
        _vertBlurMaterial.setValues({
          useFog: settings$1.now.fog,
          fogTransparent: settings$1.now.bg.transparent
        });
        _vertBlurMaterial.needsUpdate = true;
      }
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(_vertBlurMaterial);
    }
  }, {
    key: "reset",
    value: function reset2() {
      if (this._picker) {
        this._picker.reset();
      }
      this._lastPick = null;
      this._releaseAllVisuals();
      this._setEditMode(EDIT_MODE.COMPLEX);
      this._resetObjects();
      if (this._gfx) {
        gfxutils.clearTree(this._gfx.pivot);
        this._gfx.renderer2d.reset();
      }
      this.setNeedRender();
    }
  }, {
    key: "_resetScene",
    value: function _resetScene() {
      this._objectControls.reset();
      this._objectControls.allowTranslation(true);
      this._objectControls.allowAltObjFreeRotation(true);
      this.resetReps();
      this.resetPivot();
      this.rebuildAll();
    }
  }, {
    key: "resetView",
    value: function resetView() {
      if (this._picker) {
        this._picker.reset();
      }
      this._setEditMode(EDIT_MODE.COMPLEX);
      this._resetScene();
      this._forEachComplexVisual(function(visual) {
        visual.updateSelectionMask({});
        visual.rebuildSelectionGeometry();
      });
    }
  }, {
    key: "_export",
    value: function _export(format) {
      var TheExporter = (0, import_lodash.head)(io.exporters.find({
        format
      }));
      if (!TheExporter) {
        this.logger.error("Could not find suitable exporter for this source");
        return Promise.reject(new Error("Could not find suitable exporter for this source"));
      }
      this.dispatchEvent({
        type: "exporting"
      });
      if (this._visuals[this._curVisualName] instanceof ComplexVisual) {
        var dataSource = null;
        if (TheExporter.SourceClass === ComplexVisual) {
          dataSource = this._visuals[this._curVisualName];
        } else if (TheExporter.SourceClass === Complex$9) {
          dataSource = this._visuals[this._curVisualName]._complex;
        }
        var exporter = new TheExporter(dataSource, {
          miewVersion: Miew2.VERSION
        });
        return exporter.export().then(function(data) {
          return data;
        });
      }
      if (this._visuals[this._curVisualName] instanceof VolumeVisual) {
        return Promise.reject(new Error("Sorry, exporter for volume data not implemented yet"));
      }
      return Promise.reject(new Error("Unexpected format of data"));
    }
  }, {
    key: "load",
    value: function load(source, opts) {
      var _this5 = this;
      opts = (0, import_lodash.merge)({}, opts, {
        context: this
      });
      if (!this.settings.now.use.multiFile) {
        if (this._loading.length) {
          this._loading.forEach(function(job2) {
            job2.cancel();
          });
          this._loading.length = 0;
        }
        if (!opts.animation) {
          this.reset(true);
        }
      }
      this._interpolator.reset();
      this.dispatchEvent({
        type: "loading",
        options: opts,
        source
      });
      var job = new JobHandle();
      this._loading.push(job);
      job.addEventListener("notification", function(e2) {
        _this5.dispatchEvent(e2.slaveEvent);
      });
      this._spinner.spin(this._container);
      var onLoadEnd = function onLoadEnd2(anything) {
        var jobIndex = _this5._loading.indexOf(job);
        if (jobIndex !== -1) {
          _this5._loading.splice(jobIndex, 1);
        }
        _this5._spinner.stop();
        _this5._refreshTitle();
        job.notify({
          type: "loadingDone",
          anything
        });
        return anything;
      };
      return _fetchData(source, opts, job).then(function(data) {
        return _parseData(data, opts, job);
      }).then(function(object4) {
        var name2 = _this5._onLoad(object4, opts);
        return onLoadEnd(name2);
      }).catch(function(err) {
        _this5.logger.error("Could not load data");
        _this5.logger.debug(err);
        throw onLoadEnd(err);
      });
    }
  }, {
    key: "unload",
    value: function unload(name2) {
      this._removeVisual(name2 || this.getCurrentVisual());
      this.resetPivot();
      if (settings$1.now.shadow.on) {
        this._updateShadowCamera();
      }
    }
  }, {
    key: "_startAnimation",
    value: function _startAnimation(fileData) {
      this._stopAnimation();
      var self2 = this;
      var visual = this._getComplexVisual();
      if (visual === null) {
        this.logger.error("Unable to start animation - no molecule is loaded.");
        return;
      }
      try {
        this._frameInfo = new FrameInfo(visual.getComplex(), fileData, {
          onLoadStatusChanged: function onLoadStatusChanged() {
            self2.dispatchEvent({
              type: "mdPlayerStateChanged",
              state: {
                isPlaying: self2._isAnimating,
                isLoading: self2._frameInfo ? self2._frameInfo.isLoading : true
              }
            });
          },
          onError: function onError(message) {
            self2._stopAnimation();
            self2.logger.error(message);
          }
        });
      } catch (e2) {
        this.logger.error("Animation file does not fit to current complex!");
        return;
      }
      this._continueAnimation();
    }
  }, {
    key: "_pauseAnimation",
    value: function _pauseAnimation() {
      if (this._animInterval === null) {
        return;
      }
      this._isAnimating = false;
      clearInterval(this._animInterval);
      this._animInterval = null;
      if (this._frameInfo) {
        this.dispatchEvent({
          type: "mdPlayerStateChanged",
          state: {
            isPlaying: this._isAnimating,
            isLoading: this._frameInfo.isLoading
          }
        });
      }
    }
  }, {
    key: "_continueAnimation",
    value: function _continueAnimation() {
      this._isAnimating = true;
      var minFrameTime = 1e3 / settings$1.now.maxfps;
      minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime;
      var self2 = this;
      var pivot = self2._gfx.pivot;
      var visual = this._getComplexVisual();
      if (visual) {
        visual.resetSelectionMask();
        visual.rebuildSelectionGeometry();
        this._msgAtomInfo.style.opacity = 0;
      }
      this._animInterval = setInterval(function() {
        self2.dispatchEvent({
          type: "mdPlayerStateChanged",
          state: {
            isPlaying: self2._isAnimating,
            isLoading: self2._frameInfo.isLoading
          }
        });
        if (self2._frameInfo.frameIsReady) {
          pivot.updateToFrame(self2._frameInfo);
          self2._updateObjsToFrame(self2._frameInfo);
          self2._refreshTitle(" Frame ".concat(self2._frameInfo._currFrame, " of ").concat(self2._frameInfo._framesCount, " time interval - ").concat(self2._frameInfo._timeStep));
          try {
            self2._frameInfo.nextFrame();
          } catch (e2) {
            self2.logger.error("Error during animation");
            self2._stopAnimation();
            return;
          }
          self2._needRender = true;
        }
      }, minFrameTime);
    }
  }, {
    key: "_stopAnimation",
    value: function _stopAnimation() {
      if (this._animInterval === null) {
        return;
      }
      clearInterval(this._animInterval);
      this._frameInfo.disableEvents();
      this._frameInfo = null;
      this._animInterval = null;
      this.dispatchEvent({
        type: "mdPlayerStateChanged",
        state: null
      });
    }
  }, {
    key: "_onLoad",
    value: function _onLoad(dataSource, opts) {
      var gfx = this._gfx;
      var visualName = null;
      if (opts.animation) {
        this._refreshTitle();
        this._startAnimation(dataSource);
        return null;
      }
      this._stopAnimation();
      if (!opts || !opts.keepRepsInfo) {
        this._opts.reps = null;
        this._opts._objects = null;
      }
      if (dataSource.id === "Complex") {
        var complex = dataSource;
        if (opts.fileName) {
          complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
        } else if (opts.amberFileName) {
          complex.name = complex.name || removeExtension(opts.amberFileName).toUpperCase();
        } else {
          complex.name = "Dynamic ".concat(opts.fileType, " molecule");
        }
        visualName = this._addVisual(new ComplexVisual(complex.name, complex));
        this._curVisualName = visualName;
        var desc = this.info();
        this.logger.info("Parsed ".concat(opts.fileName, " (").concat(desc.atoms, " atoms, ").concat(desc.bonds, " bonds, ").concat(desc.residues, " residues, ").concat(desc.chains, " chains)."));
        if ((0, import_lodash.isNumber)(this._opts.unit)) {
          complex.setCurrentUnit(this._opts.unit);
        }
        if (opts.preset) ;
        else if (settings$1.now.autoPreset) {
          switch (opts.fileType) {
            case "cml":
              this.resetReps("small");
              break;
            case "pdb":
            case "mmtf":
            case "cif":
              if (hasValidResidues(complex)) {
                this.resetReps("macro");
              } else {
                this.resetReps("small");
              }
              break;
            default:
              this.resetReps("default");
              break;
          }
        } else {
          this.resetReps("default");
        }
      } else if (dataSource.id === "Volume") {
        this.resetEd();
        visualName = this._onLoadEd(dataSource);
      }
      gfx.camera.updateProjectionMatrix();
      this._updateFog();
      gfx.root.resetTransform();
      this.resetPivot();
      this._objectControls.setScale(settings$1.now.radiusToFit / this._getBSphereRadius());
      this._resetObjects();
      if (settings$1.now.autoResolution) {
        this._tweakResolution();
      }
      if (settings$1.now.shadow.on) {
        this._updateShadowCamera();
      }
      if (this._opts.view) {
        this.view(this._opts.view);
        delete this._opts.view;
      }
      this._refreshTitle();
      return visualName;
    }
  }, {
    key: "resetEd",
    value: function resetEd() {
      if (this._edLoader) {
        this._edLoader.abort();
        this._edLoader = null;
      }
      this._removeVisual(this._getVolumeVisual());
      this._needRender = true;
    }
  }, {
    key: "loadEd",
    value: function loadEd(source) {
      var _this6 = this;
      this.resetEd();
      var TheLoader = (0, import_lodash.head)(io.loaders.find({
        source
      }));
      if (!TheLoader) {
        this.logger.error(LOADER_NOT_FOUND);
        return Promise.reject(new Error(LOADER_NOT_FOUND));
      }
      var loader = this._edLoader = new TheLoader(source, {
        binary: true
      });
      loader.context = this;
      return loader.load().then(function(data) {
        var TheParser = (0, import_lodash.head)(io.parsers.find({
          format: "ccp4"
        }));
        if (!TheParser) {
          throw new Error(PARSER_NOT_FOUND);
        }
        var parser2 = new TheParser(data);
        parser2.context = _this6;
        return parser2.parse().then(function(dataSource) {
          _this6._onLoadEd(dataSource);
        });
      }).catch(function(error) {
        _this6.logger.error("Could not load ED data");
        _this6.logger.debug(error);
      });
    }
  }, {
    key: "_onLoadEd",
    value: function _onLoadEd(dataSource) {
      dataSource.normalize();
      var volumeVisual = new VolumeVisual("volume", dataSource);
      volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME);
      var visualName = this._addVisual(volumeVisual);
      this._needRender = true;
      return visualName;
    }
  }, {
    key: "_needRebuild",
    value: function _needRebuild() {
      var needsRebuild = false;
      this._forEachComplexVisual(function(visual) {
        needsRebuild = needsRebuild || visual.needsRebuild();
      });
      return needsRebuild;
    }
  }, {
    key: "_rebuildObjects",
    value: function _rebuildObjects() {
      var self2 = this;
      var gfx = this._gfx;
      var i2;
      var n2;
      var toRemove = [];
      for (i2 = 0; i2 < gfx.pivot.children.length; ++i2) {
        var child = gfx.pivot.children[i2];
        if (!(child instanceof Visual)) {
          toRemove.push(child);
        }
      }
      for (i2 = 0; i2 < toRemove.length; ++i2) {
        toRemove[i2].parent.remove(toRemove[i2]);
      }
      setTimeout(function() {
        var objList = self2._objects;
        for (i2 = 0, n2 = objList.length; i2 < n2; ++i2) {
          var obj = objList[i2];
          if (obj.needsRebuild) {
            obj.build();
          }
          if (obj.getGeometry()) {
            gfx.pivot.add(obj.getGeometry());
          }
        }
      }, 10);
    }
  }, {
    key: "changeUnit",
    value: function changeUnit(unitIdx, name2) {
      var visual = this._getComplexVisual(name2);
      if (!visual) {
        throw new Error("There is no complex to change!");
      }
      function currentUnitInfo() {
        var unit = visual ? visual.getComplex().getCurrentUnit() : 0;
        var type = unit > 0 ? "Bio molecule ".concat(unit) : "Asymmetric unit";
        return "Current unit: ".concat(unit, " (").concat(type, ")");
      }
      if (unitIdx === void 0) {
        return currentUnitInfo();
      }
      if ((0, import_lodash.isString)(unitIdx)) {
        unitIdx = Math.max(parseInt(unitIdx, 10), 0);
      }
      if (visual.getComplex().setCurrentUnit(unitIdx)) {
        this._resetScene();
        this._updateInfoPanel();
      }
      return currentUnitInfo();
    }
  }, {
    key: "rebuild",
    value: function rebuild() {
      var _this7 = this;
      if (this._building) {
        this.logger.warn("Miew.rebuild(): already building!");
        return;
      }
      this._building = true;
      this.dispatchEvent({
        type: "rebuilding"
      });
      this._rebuildObjects();
      this._gfx.renderer2d.reset();
      var rebuildActions = [];
      this._forEachComplexVisual(function(visual) {
        if (visual.needsRebuild()) {
          rebuildActions.push(visual.rebuild().then(function() {
            return new Promise(function(resolve) {
              visual.rebuildSelectionGeometry();
              resolve();
            });
          }));
        }
      });
      var self2 = this;
      this._spinner.spin(this._container);
      Promise.all(rebuildActions).then(function() {
        self2._spinner.stop();
        self2._needRender = true;
        self2._refreshTitle();
        _this7.dispatchEvent({
          type: "buildingDone"
        });
        self2._building = false;
      });
    }
  }, {
    key: "rebuildAll",
    value: function rebuildAll() {
      this._forEachComplexVisual(function(visual) {
        visual.setNeedsRebuild();
      });
    }
  }, {
    key: "_refreshTitle",
    value: function _refreshTitle(appendix) {
      var title;
      appendix = appendix === void 0 ? "" : appendix;
      var visual = this._getComplexVisual();
      if (visual) {
        title = visual.getComplex().name;
        var rep2 = visual.repGet(visual.repCurrent());
        title += rep2 ? "  ".concat(rep2.mode.name, " Mode") : "";
      } else {
        title = Object.keys(this._visuals).length > 0 ? "Unknown" : "No Data";
      }
      title += appendix;
      this.dispatchEvent({
        type: "titleChanged",
        data: title
      });
    }
  }, {
    key: "setNeedRender",
    value: function setNeedRender() {
      this._needRender = true;
    }
  }, {
    key: "_extractRepresentation",
    value: function _extractRepresentation() {
      var _this8 = this;
      var changed2 = [];
      this._forEachComplexVisual(function(visual) {
        if (visual.getSelectionCount() === 0) {
          return;
        }
        var selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit());
        var defPreset = settings$1.now.presets.default;
        var res = visual.repAdd({
          selector,
          mode: defPreset[0].mode.id,
          colorer: defPreset[0].colorer.id,
          material: defPreset[0].material.id
        });
        if (!res) {
          if (visual.repCount() === ComplexVisual.NUM_REPRESENTATION_BITS) {
            _this8.logger.warn("Number of representations is limited to ".concat(ComplexVisual.NUM_REPRESENTATION_BITS));
          }
          return;
        }
        _this8.dispatchEvent({
          type: "repAdded",
          index: res.index,
          name: visual.name
        });
        visual.repCurrent(res.index);
        changed2.push(visual.name);
      });
      if (changed2.length > 0) {
        this.logger.report("New representation from selection for complexes: ".concat(changed2.join(", ")));
      }
    }
  }, {
    key: "_setReps",
    value: function _setReps(reps) {
      reps = reps || this._opts && this._opts.reps || [];
      this._forEachComplexVisual(function(visual) {
        return visual.resetReps(reps);
      });
    }
  }, {
    key: "applyPreset",
    value: function applyPreset(preset2) {
      var presets = settings$1.now.presets;
      var presList = [preset2 || settings$1.defaults.preset, settings$1.defaults.preset, Object.keys(presets)[0]];
      var reps = null;
      for (var i2 = 0; !reps && i2 < presList.length; ++i2) {
        settings$1.set("preset", presList[i2]);
        reps = presets[settings$1.now.preset];
        if (!reps) {
          this.logger.warn('Unknown preset "'.concat(settings$1.now.preset, '"'));
        }
      }
      this._setReps(reps);
    }
  }, {
    key: "resetReps",
    value: function resetReps(preset2) {
      var reps = this._opts && this._opts.reps;
      if (reps) {
        this._setReps(reps);
      } else {
        this.applyPreset(preset2);
      }
    }
  }, {
    key: "repCount",
    value: function repCount(name2) {
      var visual = this._getComplexVisual(name2);
      return visual ? visual.repCount() : 0;
    }
  }, {
    key: "repCurrent",
    value: function repCurrent(index, name2) {
      var visual = this._getComplexVisual(name2);
      var newIdx = visual ? visual.repCurrent(index) : -1;
      if (index && newIdx !== index) {
        this.logger.warn("Representation ".concat(index, " was not found. Current rep remains unchanged."));
      }
      return newIdx;
    }
  }, {
    key: "rep",
    value: function rep2(index, _rep) {
      var visual = this._getComplexVisual("");
      if (!visual) {
        return null;
      }
      var res = visual.rep(index, _rep);
      if (res.status === "created") {
        this.dispatchEvent({
          type: "repAdded",
          index: res.index,
          name: visual.name
        });
      } else if (res.status === "changed") {
        this.dispatchEvent({
          type: "repChanged",
          index: res.index,
          name: visual.name
        });
      }
      return res.desc;
    }
  }, {
    key: "repGet",
    value: function repGet(index, name2) {
      var visual = this._getComplexVisual(name2);
      return visual ? visual.repGet(index) : null;
    }
  }, {
    key: "repAdd",
    value: function repAdd(rep2, name2) {
      var visual = this._getComplexVisual(name2);
      if (!visual) {
        return -1;
      }
      var res = visual.repAdd(rep2);
      if (res) {
        this.dispatchEvent({
          type: "repAdded",
          index: res.index,
          name: name2
        });
        return res.index;
      }
      return -1;
    }
  }, {
    key: "repRemove",
    value: function repRemove(index, name2) {
      var visual = this._getComplexVisual(name2);
      if (!visual) {
        return;
      }
      visual.repRemove(index);
      this.dispatchEvent({
        type: "repRemoved",
        index,
        name: name2
      });
    }
  }, {
    key: "repHide",
    value: function repHide(index, hide, name2) {
      this._needRender = true;
      var visual = this._getComplexVisual(name2);
      return visual ? visual.repHide(index, hide) : null;
    }
  }, {
    key: "_setEditMode",
    value: function _setEditMode(mode2) {
      this._editMode = mode2;
      var elem2 = this._msgMode;
      if (elem2) {
        elem2.style.opacity = mode2 === EDIT_MODE.COMPLEX ? 0 : 1;
        if (mode2 !== EDIT_MODE.COMPLEX) {
          var t2 = elem2.getElementsByTagName("p")[0];
          t2.innerHTML = mode2 === EDIT_MODE.COMPONENT ? "COMPONENT EDIT MODE" : "FRAGMENT EDIT MODE";
        }
      }
      this.dispatchEvent({
        type: "editModeChanged",
        data: mode2 === EDIT_MODE.COMPLEX
      });
    }
  }, {
    key: "_enterComponentEditMode",
    value: function _enterComponentEditMode() {
      if (this._editMode !== EDIT_MODE.COMPLEX) {
        return;
      }
      var editors = [];
      this._forEachComplexVisual(function(visual) {
        var editor = visual.beginComponentEdit();
        if (editor) {
          editors.push(editor);
        }
      });
      if (editors === []) {
        return;
      }
      this._editors = editors;
      this.logger.info("COMPONENT EDIT MODE -- ON");
      this._setEditMode(EDIT_MODE.COMPONENT);
      this._objectControls.keysTranslateObj(true);
    }
  }, {
    key: "_applyComponentEdit",
    value: function _applyComponentEdit() {
      if (this._editMode !== EDIT_MODE.COMPONENT) {
        return;
      }
      this._objectControls.stop();
      this._objectControls.keysTranslateObj(false);
      for (var i2 = 0; i2 < this._editors.length; ++i2) {
        this._editors[i2].apply();
      }
      this._editors = [];
      this.logger.info("COMPONENT EDIT MODE -- OFF (applied)");
      this._setEditMode(EDIT_MODE.COMPLEX);
      this.rebuildAll();
    }
  }, {
    key: "_discardComponentEdit",
    value: function _discardComponentEdit() {
      if (this._editMode !== EDIT_MODE.COMPONENT) {
        return;
      }
      this._objectControls.stop();
      this._objectControls.keysTranslateObj(false);
      for (var i2 = 0; i2 < this._editors.length; ++i2) {
        this._editors[i2].discard();
      }
      this._editors = [];
      this.logger.info("COMPONENT EDIT MODE -- OFF (discarded)");
      this._setEditMode(EDIT_MODE.COMPLEX);
      this._needRender = true;
      this.rebuildAll();
    }
  }, {
    key: "_enterFragmentEditMode",
    value: function _enterFragmentEditMode() {
      if (this._editMode !== EDIT_MODE.COMPLEX) {
        return;
      }
      var selectedVisuals = [];
      this._forEachComplexVisual(function(visual) {
        if (visual instanceof ComplexVisual && visual.getSelectionCount() > 0) {
          selectedVisuals.push(visual);
        }
      });
      if (selectedVisuals.length !== 1) {
        return;
      }
      var editor = selectedVisuals[0].beginFragmentEdit();
      if (!editor) {
        return;
      }
      this._editors = [editor];
      this.logger.info("FRAGMENT EDIT MODE -- ON (single bond)");
      this._setEditMode(EDIT_MODE.FRAGMENT);
      this._objectControls.allowTranslation(false);
      this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed());
      this._needRender = true;
    }
  }, {
    key: "_applyFragmentEdit",
    value: function _applyFragmentEdit() {
      if (this._editMode !== EDIT_MODE.FRAGMENT) {
        return;
      }
      this._objectControls.stop();
      for (var i2 = 0; i2 < this._editors.length; ++i2) {
        this._editors[i2].apply();
      }
      this._editors = [];
      this.logger.info("FRAGMENT EDIT MODE -- OFF (applied)");
      this._setEditMode(EDIT_MODE.COMPLEX);
      this._objectControls.allowTranslation(true);
      this._objectControls.allowAltObjFreeRotation(true);
      this.rebuildAll();
    }
  }, {
    key: "_discardFragmentEdit",
    value: function _discardFragmentEdit() {
      if (this._editMode !== EDIT_MODE.FRAGMENT) {
        return;
      }
      this._objectControls.stop();
      for (var i2 = 0; i2 < this._editors.length; ++i2) {
        this._editors[i2].discard();
      }
      this._editors = [];
      this.logger.info("FRAGMENT EDIT MODE -- OFF (discarded)");
      this._setEditMode(EDIT_MODE.COMPLEX);
      this._objectControls.allowTranslation(true);
      this._objectControls.allowAltObjFreeRotation(true);
      this._needRender = true;
    }
  }, {
    key: "_onPick",
    value: function _onPick(event) {
      if (!settings$1.now.picking) {
        return;
      }
      if (this._animInterval !== null) {
        return;
      }
      if (this._editMode === EDIT_MODE.FRAGMENT) {
        return;
      }
      if (this._objectControls.isEditingAltObj()) {
        return;
      }
      var complex = null;
      if (event.obj.atom) {
        complex = event.obj.atom.residue.getChain().getComplex();
        this._lastPick = event.obj.atom;
      } else if (event.obj.residue) {
        complex = event.obj.residue.getChain().getComplex();
        this._lastPick = event.obj.residue;
      } else if (event.obj.chain) {
        complex = event.obj.chain.getComplex();
        this._lastPick = event.obj.chain;
      } else if (event.obj.molecule) {
        complex = event.obj.molecule.complex;
        this._lastPick = event.obj.molecule;
      } else {
        this._lastPick = null;
      }
      function _updateSelection(visual2) {
        visual2.updateSelectionMask(event.obj);
        visual2.rebuildSelectionGeometry();
      }
      if (complex) {
        var visual = this._getVisualForComplex(complex);
        if (visual) {
          _updateSelection(visual);
          this._needRender = true;
        }
      } else {
        this._forEachComplexVisual(_updateSelection);
        this._needRender = true;
      }
      this._updateInfoPanel();
      this.dispatchEvent(event);
    }
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(event) {
      if (!this._running || !this._hotKeysEnabled) {
        return;
      }
      switch (event.keyCode) {
        case "C".charCodeAt(0):
          if (settings$1.now.editing) {
            this._enterComponentEditMode();
          }
          break;
        case "F".charCodeAt(0):
          if (settings$1.now.editing) {
            this._enterFragmentEditMode();
          }
          break;
        case "A".charCodeAt(0):
          switch (this._editMode) {
            case EDIT_MODE.COMPONENT:
              this._applyComponentEdit();
              break;
            case EDIT_MODE.FRAGMENT:
              this._applyFragmentEdit();
              break;
          }
          break;
        case "D".charCodeAt(0):
          switch (this._editMode) {
            case EDIT_MODE.COMPONENT:
              this._discardComponentEdit();
              break;
            case EDIT_MODE.FRAGMENT:
              this._discardFragmentEdit();
              break;
          }
          break;
        case "S".charCodeAt(0):
          event.preventDefault();
          event.stopPropagation();
          settings$1.set("ao", !settings$1.now.ao);
          this._needRender = true;
          break;
        case 107:
          event.preventDefault();
          event.stopPropagation();
          this._forEachComplexVisual(function(visual) {
            visual.expandSelection();
            visual.rebuildSelectionGeometry();
          });
          this._updateInfoPanel();
          this._needRender = true;
          break;
        case 109:
          event.preventDefault();
          event.stopPropagation();
          this._forEachComplexVisual(function(visual) {
            visual.shrinkSelection();
            visual.rebuildSelectionGeometry();
          });
          this._updateInfoPanel();
          this._needRender = true;
          break;
      }
    }
  }, {
    key: "_onKeyUp",
    value: function _onKeyUp(event) {
      if (!this._running || !this._hotKeysEnabled) {
        return;
      }
      if (event.keyCode === "X".charCodeAt(0)) {
        this._extractRepresentation();
      }
    }
  }, {
    key: "_updateInfoPanel",
    value: function _updateInfoPanel() {
      var info = this._msgAtomInfo.getElementsByTagName("p")[0];
      var atom;
      var residue2;
      var count = 0;
      this._forEachComplexVisual(function(visual) {
        count += visual.getSelectionCount();
      });
      while (info.firstChild) {
        info.removeChild(info.firstChild);
      }
      if (count === 0) {
        this._msgAtomInfo.style.opacity = 0;
        return;
      }
      var firstLine = "".concat(String(count), " atom").concat(count !== 1 ? "s" : "", " selected");
      if (this._lastPick !== null) {
        firstLine += ", the last pick:";
      }
      var secondLine = "";
      var aName = "";
      var coordLine = "";
      if (this._lastPick instanceof Atom) {
        atom = this._lastPick;
        residue2 = atom.residue;
        aName = atom.name;
        var location = atom.location !== 32 ? String.fromCharCode(atom.location) : "";
        secondLine = "".concat(atom.element.fullName, " #").concat(atom.serial).concat(location, ":       ").concat(residue2._chain._name, ".").concat(residue2._type._name).concat(residue2._sequence).concat(residue2._icode.trim(), ".");
        secondLine += aName;
        coordLine = "Coord: (".concat(atom.position.x.toFixed(2).toString(), ",     ").concat(atom.position.y.toFixed(2).toString(), ",     ").concat(atom.position.z.toFixed(2).toString(), ")");
      } else if (this._lastPick instanceof Residue) {
        residue2 = this._lastPick;
        secondLine = "".concat(residue2._type._fullName, ":       ").concat(residue2._chain._name, ".").concat(residue2._type._name).concat(residue2._sequence).concat(residue2._icode.trim());
      } else if (this._lastPick instanceof Chain) {
        secondLine = "chain ".concat(this._lastPick._name);
      } else if (this._lastPick instanceof Molecule) {
        secondLine = "molecule ".concat(this._lastPick._name);
      }
      info.appendChild(document.createTextNode(firstLine));
      if (secondLine !== "") {
        info.appendChild(document.createElement("br"));
        info.appendChild(document.createTextNode(secondLine));
      }
      if (coordLine !== "") {
        info.appendChild(document.createElement("br"));
        info.appendChild(document.createTextNode(coordLine));
      }
      this._msgAtomInfo.style.opacity = 1;
    }
  }, {
    key: "_getAltObj",
    value: function _getAltObj() {
      if (this._editors) {
        var altObj = null;
        for (var i2 = 0; i2 < this._editors.length; ++i2) {
          var nextAltObj = this._editors[i2].getAltObj();
          if (nextAltObj.objects.length > 0) {
            if (altObj) {
              altObj = null;
              break;
            }
            altObj = nextAltObj;
          }
        }
        if (altObj) {
          return altObj;
        }
      }
      return {
        objects: [],
        pivot: new Vector3(0, 0, 0)
      };
    }
  }, {
    key: "resetPivot",
    value: function resetPivot() {
      var boundingBox = new Box3();
      var center = new Vector3();
      boundingBox.makeEmpty();
      this._forEachVisual(function(visual) {
        boundingBox.union(visual.getBoundaries().boundingBox);
      });
      boundingBox.getCenter(center);
      this._objectControls.setPivot(center.negate());
      this.dispatchEvent({
        type: "transform"
      });
    }
  }, {
    key: "setPivotResidue",
    value: function setPivotResidue(residue2) {
      var center = new Vector3();
      var visual = this._getVisualForComplex(residue2.getChain().getComplex());
      if (!visual) {
        return;
      }
      if (residue2._controlPoint) {
        center.copy(residue2._controlPoint);
      } else {
        var x2 = 0;
        var y2 = 0;
        var z2 = 0;
        var amount = residue2._atoms.length;
        for (var i2 = 0; i2 < amount; ++i2) {
          var p2 = residue2._atoms[i2].position;
          x2 += p2.x / amount;
          y2 += p2.y / amount;
          z2 += p2.z / amount;
        }
        center.set(x2, y2, z2);
      }
      center.applyMatrix4(visual.matrix).negate();
      this._objectControls.setPivot(center);
      this.dispatchEvent({
        type: "transform"
      });
    }
  }, {
    key: "setPivotAtom",
    value: function setPivotAtom(atom) {
      var center = new Vector3();
      var visual = this._getVisualForComplex(atom.residue.getChain().getComplex());
      if (!visual) {
        return;
      }
      center.copy(atom.position);
      center.applyMatrix4(visual.matrix).negate();
      this._objectControls.setPivot(center);
      this.dispatchEvent({
        type: "transform"
      });
    }
  }, {
    key: "getSelectionCenter",
    value: function getSelectionCenter(center, includesAtom, selector) {
      var _centerInVisual = new Vector3(0, 0, 0);
      center.set(0, 0, 0);
      var count = 0;
      this._forEachComplexVisual(function(visual) {
        if (visual.getSelectionCenter(_centerInVisual, includesAtom, selector || visual.getSelectionBit())) {
          center.add(_centerInVisual);
          count++;
        }
      });
      if (count === 0) {
        return false;
      }
      center.divideScalar(count);
      center.negate();
      return true;
    }
  }, {
    key: "setPivotSubset",
    value: function setPivotSubset(selector) {
      var _center2 = new Vector3(0, 0, 0);
      var includesAtom = selector ? _includesInSelector : _includesInCurSelection;
      if (this.getSelectionCenter(_center2, includesAtom, selector)) {
        this._objectControls.setPivot(_center2);
        this.dispatchEvent({
          type: "transform"
        });
      } else {
        this.logger.warn("selection is empty. Center operation not performed");
      }
    }
  }, {
    key: "screenshot",
    value: function screenshot(width, height) {
      var gfx = this._gfx;
      var deviceWidth = gfx.renderer.domElement.width;
      var deviceHeight = gfx.renderer.domElement.height;
      function fov2Tan(fov2) {
        return Math.tan(MathUtils.degToRad(0.5 * fov2));
      }
      function tan2Fov(tan) {
        return MathUtils.radToDeg(Math.atan(tan)) * 2;
      }
      function getDataURL() {
        var dataURL;
        var currBrowser = utils.getBrowser();
        if (currBrowser === utils.browserType.SAFARI) {
          var canvas = document.createElement("canvas");
          var canvasContext = canvas.getContext("2d");
          canvas.width = width === void 0 ? deviceWidth : width;
          canvas.height = height === void 0 ? deviceHeight : height;
          canvasContext.drawImage(gfx.renderer.domElement, 0, 0, canvas.width, canvas.height);
          dataURL = canvas.toDataURL("image/png");
        } else {
          dataURL = gfx.renderer.domElement.toDataURL("image/png");
        }
        return dataURL;
      }
      height = height || width;
      var screenshotURI;
      if (width === void 0 && height === void 0 || width === deviceWidth && height === deviceHeight) {
        screenshotURI = getDataURL();
      } else {
        var originalAspect = gfx.camera.aspect;
        var originalFov = gfx.camera.fov;
        var originalTanFov2 = fov2Tan(gfx.camera.fov);
        var areaOfInterestSize = Math.min(gfx.width, gfx.height);
        var areaOfInterestTanFov2 = originalTanFov2 * areaOfInterestSize / gfx.height;
        var shotAspect = width / height;
        gfx.renderer.setPixelRatio(1);
        gfx.camera.aspect = shotAspect;
        gfx.camera.fov = tan2Fov(areaOfInterestTanFov2 / Math.min(shotAspect, 1));
        gfx.camera.updateProjectionMatrix();
        gfx.renderer.setDrawingBufferSize(width, height, 1);
        this._renderFrame(settings$1.now.stereo);
        screenshotURI = getDataURL();
        gfx.renderer.setPixelRatio(window.devicePixelRatio);
        gfx.camera.aspect = originalAspect;
        gfx.camera.fov = originalFov;
        gfx.camera.updateProjectionMatrix();
        gfx.renderer.setDrawingBufferSize(gfx.width, gfx.height, window.devicePixelRatio);
        this._needRender = true;
      }
      return screenshotURI;
    }
  }, {
    key: "screenshotSave",
    value: function screenshotSave(filename, width, height) {
      var uri = this.screenshot(width, height);
      utils.shotDownload(uri, filename);
    }
  }, {
    key: "save",
    value: function save(opts) {
      var _this9 = this;
      this._export(opts.fileType).then(function(dataString) {
        var filename = _this9._visuals[_this9._curVisualName]._complex.name;
        utils.download(dataString, filename, opts.fileType);
        _this9._refreshTitle();
        _this9.dispatchEvent({
          type: "exportingDone"
        });
      }).catch(function(error) {
        _this9.logger.error("Could not export data");
        _this9.logger.debug(error);
        _this9._refreshTitle();
        _this9.dispatchEvent({
          type: "exportingDone",
          error
        });
      });
    }
  }, {
    key: "_tweakResolution",
    value: function _tweakResolution() {
      var maxPerf = [["poor", 100], ["low", 500], ["medium", 1e3], ["high", 5e3], ["ultra", Number.MAX_VALUE]];
      var atomCount = 0;
      this._forEachComplexVisual(function(visual) {
        atomCount += visual.getComplex().getAtomCount();
      });
      if (atomCount > 0) {
        var performance2 = this._gfxScore * 1e6 / atomCount;
        for (var i2 = 0; i2 < maxPerf.length; ++i2) {
          if (performance2 < maxPerf[i2][1]) {
            this._autoChangeResolution(maxPerf[i2][0]);
            break;
          }
        }
      }
    }
  }, {
    key: "_autoChangeResolution",
    value: function _autoChangeResolution(resolution) {
      if (resolution !== settings$1.now.resolution) {
        this.logger.report('Your rendering resolution was changed to "'.concat(resolution, '" for best performance.'));
      }
      settings$1.now.resolution = resolution;
    }
  }, {
    key: "saveSettings",
    value: function saveSettings() {
      this._cookies.setCookie(this._opts.settingsCookie, JSON.stringify(this.settings.getDiffs(true)));
    }
  }, {
    key: "restoreSettings",
    value: function restoreSettings() {
      try {
        var cookie = this._cookies.getCookie(this._opts.settingsCookie);
        var diffs = cookie ? JSON.parse(cookie) : {};
        this.settings.applyDiffs(diffs, true);
      } catch (e2) {
        this.logger.error("Cookies parse error: ".concat(e2.message));
      }
    }
  }, {
    key: "resetSettings",
    value: function resetSettings() {
      this.settings.reset();
    }
  }, {
    key: "setOptions",
    value: function setOptions(opts) {
      if (typeof opts === "string") {
        opts = Miew2.options.fromAttr(opts);
      }
      if (opts.reps) {
        this._opts.reps = null;
      }
      (0, import_lodash.merge)(this._opts, opts);
      if (opts.settings) {
        this.set(opts.settings);
      }
      this._opts._objects = opts._objects;
      this._resetObjects();
      if (opts.load) {
        this.load(opts.load, {
          fileType: opts.type
        });
      }
      if (opts.preset) {
        settings$1.now.preset = opts.preset;
      }
      if (opts.reps) {
        this.resetReps(opts.preset);
      }
      if (this._opts.view) {
        this.view(this._opts.view);
        delete this._opts.view;
      }
      var visual = this._getComplexVisual();
      if (visual) {
        visual.getComplex().resetCurrentUnit();
        if ((0, import_lodash.isNumber)(opts.unit)) {
          visual.getComplex().setCurrentUnit(opts.unit);
        }
        this.resetView();
        this.rebuildAll();
      }
    }
  }, {
    key: "info",
    value: function info(name2) {
      var visual = this._getComplexVisual(name2);
      if (!visual) {
        return {};
      }
      var complex = visual.getComplex();
      var metadata = complex.metadata;
      return {
        id: metadata.id || complex.name || "UNKNOWN",
        title: metadata.title && metadata.title.join(" ") || "UNKNOWN DATA",
        atoms: complex.getAtomCount(),
        bonds: complex.getBondCount(),
        residues: complex.getResidueCount(),
        chains: complex.getChainCount()
      };
    }
  }, {
    key: "addObject",
    value: function addObject2(objData, bThrow) {
      var Ctor = null;
      if (objData.type === LinesObj.prototype.type) {
        Ctor = LinesObj;
      }
      if (Ctor === null) {
        throw new Error("Unknown scene object type - ".concat(objData.type));
      }
      try {
        var newObj = new Ctor(objData.params, objData.opts);
        this._addSceneObject(newObj);
      } catch (error) {
        if (!bThrow) {
          this.logger.debug("Error during scene object creation: ".concat(error.message));
        } else {
          throw error;
        }
      }
      this._needRender = true;
    }
  }, {
    key: "_addSceneObject",
    value: function _addSceneObject(sceneObject) {
      var visual = this._getComplexVisual();
      if (sceneObject.build && visual) {
        sceneObject.build(visual.getComplex());
        this._gfx.pivot.add(sceneObject.getGeometry());
      }
      var objects = this._objects;
      objects[objects.length] = sceneObject;
    }
  }, {
    key: "_updateObjsToFrame",
    value: function _updateObjsToFrame(frameData) {
      var objs = this._objects;
      for (var i2 = 0, n2 = objs.length; i2 < n2; ++i2) {
        if (objs[i2].updateToFrame) {
          objs[i2].updateToFrame(frameData);
        }
      }
    }
  }, {
    key: "_resetObjects",
    value: function _resetObjects() {
      var objs = this._opts._objects;
      this._objects = [];
      if (objs) {
        for (var i2 = 0, n2 = objs.length; i2 < n2; ++i2) {
          this.addObject(objs[i2], false);
        }
      }
    }
  }, {
    key: "removeObject",
    value: function removeObject(index) {
      var obj = this._objects[index];
      if (!obj) {
        throw new Error("Scene object with index ".concat(index, " does not exist"));
      }
      obj.destroy();
      this._objects.splice(index, 1);
      this._needRender = true;
    }
  }, {
    key: "getURL",
    value: function getURL(opts) {
      return options$1.toURL(this.getState((0, import_lodash.defaults)(opts, {
        compact: true,
        settings: false,
        view: false
      })));
    }
  }, {
    key: "getScript",
    value: function getScript(opts) {
      return options$1.toScript(this.getState((0, import_lodash.defaults)(opts, {
        compact: true,
        settings: true,
        view: true
      })));
    }
  }, {
    key: "_compareReps",
    value: function _compareReps(complexVisual, compareWithDefaults) {
      var ans = {};
      var repCount = 0;
      if (complexVisual) {
        repCount = complexVisual.repCount();
      }
      var currPreset = settings$1.defaults.presets[settings$1.now.preset];
      var compare = compareWithDefaults;
      if (currPreset === void 0 || currPreset.length > repCount) {
        compare = false;
        ans.preset = "empty";
      } else if (settings$1.now.preset !== settings$1.defaults.preset) {
        ans.preset = settings$1.now.preset;
      }
      var repsDiff = [];
      var emptyReps = true;
      for (var i2 = 0, n2 = repCount; i2 < n2; ++i2) {
        repsDiff[i2] = complexVisual.repGet(i2).compare(compare ? currPreset[i2] : null);
        if (!(0, import_lodash.isEmpty)(repsDiff[i2])) {
          emptyReps = false;
        }
      }
      if (!emptyReps) {
        ans.reps = repsDiff;
      }
      return ans;
    }
  }, {
    key: "getState",
    value: function getState(opts) {
      var state = {};
      opts = (0, import_lodash.defaults)(opts, {
        compact: true,
        settings: false,
        view: false
      });
      var visual = this._getComplexVisual();
      if (visual !== null) {
        var complex = visual.getComplex();
        var metadata = complex.metadata;
        if (metadata.id) {
          var format = metadata.format ? "".concat(metadata.format, ":") : "";
          state.load = format + metadata.id;
        }
        var unit = complex.getCurrentUnit();
        if (unit !== 1) {
          state.unit = unit;
        }
      }
      var repsInfo = this._compareReps(visual, opts.compact);
      if (repsInfo.preset) {
        state.preset = repsInfo.preset;
      }
      if (repsInfo.reps) {
        state.reps = repsInfo.reps;
      }
      var objects = this._objects;
      var objectsState = [];
      for (var i2 = 0, n2 = objects.length; i2 < n2; ++i2) {
        objectsState[i2] = objects[i2].identify();
      }
      if (objects.length > 0) {
        state._objects = objectsState;
      }
      if (opts.view) {
        state.view = this.view();
      }
      if (opts.settings) {
        var diff = this.settings.getDiffs(false);
        if (!(0, import_lodash.isEmpty)(diff)) {
          state.settings = diff;
        }
      }
      return state;
    }
  }, {
    key: "get",
    value: function get3(param, value) {
      return settings$1.get(param, value);
    }
  }, {
    key: "_clipPlaneUpdateValue",
    value: function _clipPlaneUpdateValue(radius) {
      var clipPlaneValue = Math.max(this._gfx.camera.position.z - radius * settings$1.now.draft.clipPlaneFactor, settings$1.now.camNear);
      var opts = {
        clipPlaneValue
      };
      this._forEachComplexVisual(function(visual) {
        visual.setUberOptions(opts);
      });
      for (var i2 = 0, n2 = this._objects.length; i2 < n2; ++i2) {
        var obj = this._objects[i2];
        if (obj._line) {
          obj._line.material.setUberOptions(opts);
        }
      }
      if (this._picker !== null) {
        this._picker.clipPlaneValue = clipPlaneValue;
      }
    }
  }, {
    key: "_fogFarUpdateValue",
    value: function _fogFarUpdateValue() {
      if (this._picker !== null) {
        if (this._gfx.scene.fog) {
          this._picker.fogFarValue = this._gfx.scene.fog.far;
        } else {
          this._picker.fogFarValue = void 0;
        }
      }
    }
  }, {
    key: "_updateShadowmapMeshes",
    value: function _updateShadowmapMeshes(process2) {
      this._forEachComplexVisual(function(visual) {
        var reprList = visual._reprList;
        for (var i2 = 0, n2 = reprList.length; i2 < n2; ++i2) {
          var repr = reprList[i2];
          process2(repr.geo, repr.material);
        }
      });
    }
  }, {
    key: "_updateMaterials",
    value: function _updateMaterials(values) {
      var needTraverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var process2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      this._forEachComplexVisual(function(visual) {
        return visual.setMaterialValues(values, needTraverse, process2);
      });
      for (var i2 = 0, n2 = this._objects.length; i2 < n2; ++i2) {
        var obj = this._objects[i2];
        if (obj._line) {
          obj._line.material.setValues(values);
          obj._line.material.needsUpdate = true;
        }
      }
    }
  }, {
    key: "_fogAlphaChanged",
    value: function _fogAlphaChanged() {
      this._forEachComplexVisual(function(visual) {
        visual.setUberOptions({
          fogAlpha: settings$1.now.fogAlpha
        });
      });
    }
  }, {
    key: "_embedWebXR",
    value: function _embedWebXR() {
      var _this10 = this;
      if (settings$1.now.stereo !== "WEBVR") {
        if (this.webVR) {
          this.webVR.disable();
        }
        this.webVR = null;
        return;
      }
      if (!this.webVR) {
        this.webVR = new WebVRPoC(function() {
          _this10._requestAnimationFrame(function() {
            return _this10._onTick();
          });
          _this10._needRender = true;
          _this10._onResize();
        });
      }
      this.webVR.enable(this._gfx);
    }
  }, {
    key: "_initOnSettingsChanged",
    value: function _initOnSettingsChanged() {
      var _this11 = this;
      var on2 = function on3(props, func3) {
        props = (0, import_lodash.isArray)(props) ? props : [props];
        props.forEach(function(prop) {
          _this11.settings.addEventListener("change:".concat(prop), func3);
        });
      };
      on2("modes.VD.frame", function() {
        var volume = _this11._getVolumeVisual();
        if (volume === null) return;
        volume.showFrame(settings$1.now.modes.VD.frame);
        _this11._needRender = true;
      });
      on2("modes.VD.isoMode", function() {
        var volume = _this11._getVolumeVisual();
        if (volume === null) return;
        volume.getMesh().material.updateDefines();
        _this11._needRender = true;
      });
      on2("bg.color", function() {
        _this11._onBgColorChanged();
      });
      on2("ao", function() {
        if (settings$1.now.ao && !isAOSupported(_this11._gfx.renderer.getContext())) {
          _this11.logger.warn("Your device or browser does not support ao");
          settings$1.set("ao", false);
        } else {
          var values = {
            normalsToGBuffer: settings$1.now.ao
          };
          _this11._setUberMaterialValues(values);
        }
      });
      on2("zSprites", function() {
        if (settings$1.now.zSprites && !arezSpritesSupported(_this11._gfx.renderer.getContext())) {
          _this11.logger.warn("Your device or browser does not support zSprites");
          settings$1.set("zSprites", false);
        }
        _this11.rebuildAll();
      });
      on2("fogColor", function() {
        _this11._onFogColorChanged();
      });
      on2("fogColorEnable", function() {
        _this11._onFogColorChanged();
      });
      on2("bg.transparent", function(evt) {
        var gfx = _this11._gfx;
        if (gfx) {
          gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
        }
        _this11._updateMaterials({
          fogTransparent: evt.value
        });
        _this11.rebuildAll();
      });
      on2("draft.clipPlane", function(evt) {
        _this11._updateMaterials({
          clipPlane: evt.value
        });
        _this11.rebuildAll();
      });
      on2("shadow.on", function(evt) {
        var values = {
          shadowmap: evt.value,
          shadowmapType: settings$1.now.shadow.type
        };
        var gfx = _this11._gfx;
        if (gfx) {
          gfx.renderer.shadowMap.enabled = Boolean(values.shadowmap);
        }
        _this11._updateMaterials(values, true);
        if (values.shadowmap) {
          _this11._updateShadowCamera();
          _this11._updateShadowmapMeshes(meshutils.createShadowmapMaterial);
        } else {
          _this11._updateShadowmapMeshes(meshutils.removeShadowmapMaterial);
        }
        _this11._needRender = true;
      });
      on2("shadow.type", function(evt) {
        if (settings$1.now.shadow.on) {
          _this11._updateMaterials({
            shadowmapType: evt.value
          }, true);
          _this11._needRender = true;
        }
      });
      on2("shadow.radius", function(evt) {
        for (var i2 = 0; i2 < _this11._gfx.scene.children.length; i2++) {
          if (_this11._gfx.scene.children[i2].shadow !== void 0) {
            var light = _this11._gfx.scene.children[i2];
            light.shadow.radius = evt.value;
            _this11._needRender = true;
          }
        }
      });
      on2("fps", function() {
        _this11._fps.show(settings$1.now.fps);
      });
      on2(["fog", "fogNearFactor", "fogFarFactor"], function() {
        _this11._updateFog();
        _this11._needRender = true;
      });
      on2("fogAlpha", function() {
        var fogAlpha = settings$1.now.fogAlpha;
        if (fogAlpha < 0 || fogAlpha > 1) {
          _this11.logger.warn("fogAlpha must belong range [0,1]");
        }
        _this11._fogAlphaChanged();
        _this11._needRender = true;
      });
      on2("autoResolution", function(evt) {
        if (evt.value && !_this11._gfxScore) {
          _this11.logger.warn("Benchmarks are missed, autoresolution will not work! Autoresolution should be set during miew startup.");
        }
      });
      on2("stereo", function() {
        _this11._embedWebXR(settings$1.now.stereo === "WEBVR");
        _this11._needRender = true;
      });
      on2(["transparency", "palette"], function() {
        _this11.rebuildAll();
      });
      on2("resolution", function() {
        _this11.rebuildAll();
        var volume = _this11._getVolumeVisual();
        if (volume) {
          volume.getMesh().material.updateDefines();
          _this11._needRender = true;
        }
      });
      on2(["axes", "fxaa", "ao", "outline.on", "outline.color", "outline.threshold", "outline.thickness"], function() {
        _this11._needRender = true;
      });
    }
  }, {
    key: "set",
    value: function set3(params, value) {
      settings$1.set(params, value);
    }
  }, {
    key: "select",
    value: function select3(expression, append) {
      var visual = this._getComplexVisual();
      if (!visual) {
        return;
      }
      var sel = expression;
      if ((0, import_lodash.isString)(expression)) {
        sel = selectors$1.parse(expression).selector;
      }
      visual.select(sel, append);
      this._lastPick = null;
      this._updateInfoPanel();
      this._needRender = true;
    }
  }, {
    key: "view",
    value: function view(expression) {
      var VIEW_VERSION = "1";
      var self2 = this;
      var pivot = this._gfx.pivot;
      var transform = [];
      var eulerOrder = "ZXY";
      function encode() {
        var pos = pivot.position;
        var scale = self2._objectControls.getScale() / settings$1.now.radiusToFit;
        var euler = new Euler();
        euler.setFromQuaternion(self2._objectControls.getOrientation(), eulerOrder);
        transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z];
        return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array);
      }
      function decode() {
        if (expression.length === 40) {
          expression = "0".concat(expression);
        }
        var version = expression[0];
        transform = utils.arrayFromBase64(expression.substr(1), Float32Array);
        if (version !== VIEW_VERSION) {
          if (version === "0") {
            transform[3] /= 8;
          } else {
            self2.logger.warn("Encoded view version mismatch, stored as ".concat(version, " vs ").concat(VIEW_VERSION, " expected"));
            return;
          }
        }
        var interpolator = self2._interpolator;
        var srcView = interpolator.createView();
        srcView.position.copy(pivot.position);
        srcView.scale = self2._objectControls.getScale();
        srcView.orientation.copy(self2._objectControls.getOrientation());
        var dstView = interpolator.createView();
        dstView.position.set(transform[0], transform[1], transform[2]);
        if (self2._getComplexVisual()) {
          dstView.position.sub(self2._getComplexVisual().position);
        }
        dstView.scale = transform[3];
        dstView.orientation.setFromEuler(new Euler(transform[4], transform[5], transform[6], eulerOrder));
        interpolator.setup(srcView, dstView);
      }
      if (typeof expression === "undefined") {
        return encode();
      }
      decode();
      return expression;
    }
  }, {
    key: "_updateView",
    value: function _updateView() {
      var self2 = this;
      var pivot = this._gfx.pivot;
      var interpolator = this._interpolator;
      if (!interpolator.wasStarted()) {
        interpolator.start();
      }
      if (!interpolator.isMoving()) {
        return;
      }
      var res = interpolator.getCurrentView();
      if (res.success) {
        var curr = res.view;
        pivot.position.copy(curr.position);
        self2._objectControls.setScale(curr.scale * settings$1.now.radiusToFit);
        self2._objectControls.setOrientation(curr.orientation);
        this.dispatchEvent({
          type: "transform"
        });
        self2._needRender = true;
      }
    }
  }, {
    key: "translate",
    value: function translate(x2, y2, z2) {
      this._objectControls.translatePivot(x2, y2, z2);
      this.dispatchEvent({
        type: "transform"
      });
      this._needRender = true;
    }
  }, {
    key: "rotate",
    value: function rotate(x2, y2, z2) {
      this._objectControls.rotate(new Quaternion().setFromEuler(new Euler(x2, y2, z2, "XYZ")));
      this.dispatchEvent({
        type: "transform"
      });
      this._needRender = true;
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (factor <= 0) {
        throw new RangeError("Scale should be greater than zero");
      }
      this._objectControls.scale(factor);
      this.dispatchEvent({
        type: "transform"
      });
      this._needRender = true;
    }
  }, {
    key: "center",
    value: function center(selector) {
      if (selector === void 0) {
        this.setPivotSubset();
        this._needRender = true;
        return;
      }
      if (selector.obj !== void 0 && ("atom" in selector.obj || "residue" in selector.obj)) {
        if ("atom" in selector.obj) {
          this.setPivotAtom(selector.obj.atom);
        } else {
          this.setPivotResidue(selector.obj.residue);
        }
        this._needRender = true;
        return;
      }
      if (selector.obj === void 0 && selector !== "") {
        var sel = selectors$1.parse(selector);
        if (sel.error === void 0) {
          this.setPivotSubset(sel);
          this._needRender = true;
          return;
        }
      }
      this.resetPivot();
      this._needRender = true;
    }
  }, {
    key: "within",
    value: function within(selector, radius) {
      var visual = this._getComplexVisual();
      if (!visual) {
        return selectors$1.None();
      }
      if (selector instanceof String) {
        selector = selectors$1.parse(selector);
      }
      var res = visual.within(selector, radius);
      if (res) {
        visual.rebuildSelectionGeometry();
        this._needRender = true;
      }
      return res;
    }
  }, {
    key: "projected",
    value: function projected(fullAtomName, complexName) {
      var visual = this._getComplexVisual(complexName);
      if (!visual) {
        return false;
      }
      var atom = visual.getComplex().getAtomByFullname(fullAtomName);
      if (atom === null) {
        return false;
      }
      var pos = atom.position.clone();
      this._gfx.pivot.updateMatrixWorldRecursive();
      this._gfx.camera.updateMatrixWorldRecursive();
      this._gfx.pivot.localToWorld(pos);
      pos.project(this._gfx.camera);
      return {
        x: (pos.x + 1) * 0.5 * this._gfx.width,
        y: (1 - pos.y) * 0.5 * this._gfx.height
      };
    }
  }, {
    key: "dssp",
    value: function dssp(complexName) {
      var visual = this._getComplexVisual(complexName);
      if (!visual) {
        return;
      }
      visual.getComplex().dssp();
      visual._reprList.forEach(function(rep2) {
        if (rep2.mode.id === "CA" || rep2.colorer.id === "SS") {
          rep2.needsRebuild = true;
        }
      });
    }
  }, {
    key: "exportCML",
    value: function exportCML() {
      var self2 = this;
      function extractRotation(m2) {
        var xAxis = new Vector3();
        var yAxis = new Vector3();
        var zAxis = new Vector3();
        m2.extractBasis(xAxis, yAxis, zAxis);
        xAxis.normalize();
        yAxis.normalize();
        zAxis.normalize();
        var retMat = new Matrix4();
        retMat.identity();
        retMat.makeBasis(xAxis, yAxis, zAxis);
        return retMat;
      }
      function updateCMLData(complex2) {
        var root = self2._gfx.root;
        var mat = extractRotation(root.matrixWorld);
        var v4 = new Vector4(0, 0, 0, 0);
        var vCenter = new Vector4(0, 0, 0, 0);
        var xml = null;
        var ap = null;
        complex2.forEachAtom(function(atom) {
          if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
            xml = atom.xmlNodeRef.xmlNode;
            ap = atom.position;
            v4.set(ap.x, ap.y, ap.z, 1);
            v4.applyMatrix4(mat);
            xml.setAttribute("x3", v4.x.toString());
            xml.setAttribute("y3", v4.y.toString());
            xml.setAttribute("z3", v4.z.toString());
            xml.removeAttribute("x2");
            xml.removeAttribute("y2");
          }
        });
        complex2.forEachSGroup(function(sGroup) {
          if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
            xml = sGroup.xmlNodeRef.xmlNode;
            ap = sGroup.getPosition();
            v4.set(ap.x, ap.y, ap.z, 1);
            var cp = sGroup.getCentralPoint();
            if (cp === null) {
              v4.applyMatrix4(mat);
            } else {
              vCenter.set(cp.x, cp.y, cp.z, 0);
              v4.add(vCenter);
              v4.applyMatrix4(mat);
              vCenter.set(cp.x, cp.y, cp.z, 1);
              vCenter.applyMatrix4(mat);
              v4.sub(vCenter);
            }
            xml.setAttribute("x", v4.x.toString());
            xml.setAttribute("y", v4.y.toString());
            xml.setAttribute("z", v4.z.toString());
          }
        });
      }
      var visual = self2._getComplexVisual();
      var complex = visual ? visual.getComplex() : null;
      if (complex && complex.originalCML) {
        updateCMLData(complex);
        var oSerializer = new XMLSerializer();
        return oSerializer.serializeToString(complex.originalCML);
      }
      return null;
    }
  }, {
    key: "motm",
    value: function motm() {
      settings$1.set({
        fogColorEnable: true,
        fogColor: 0,
        outline: {
          on: true,
          threshold: 0.01
        },
        bg: {
          color: 16777215
        }
      });
      this._forEachComplexVisual(function(visual) {
        var rep2 = [];
        var complex = visual.getComplex();
        var palette2 = palettes$1.get(settings$1.now.palette);
        for (var i2 = 0; i2 < complex.getChainCount(); i2++) {
          var curChainName = complex._chains[i2]._name;
          var curChainColor = palette2.getChainColor(curChainName);
          rep2[i2] = {
            selector: "chain ".concat(curChainName),
            mode: "VW",
            colorer: ["CB", {
              color: curChainColor,
              factor: 0.9
            }],
            material: "FL"
          };
        }
        visual.resetReps(rep2);
      });
    }
  }]);
  return Miew2;
}(EventDispatcher2);
(0, import_lodash.assign)(
  Miew,
  {
    VERSION: Miew.VERSION,
    registeredPlugins: [],
    chem,
    io,
    modes: modes$1,
    colorers: colorers$1,
    materials: materials$1,
    palettes: palettes$1,
    options: options$1,
    settings: settings$1,
    utils,
    gfx: {
      Representation
    }
  }
);
var parser = function() {
  var o2 = function o3(k2, v2, _o, l2) {
    for (_o = _o || {}, l2 = k2.length; l2--; _o[k2[l2]] = v2) {
    }
    return _o;
  }, $V0 = [1, 60], $V1 = [1, 62], $V2 = [1, 63], $V3 = [1, 65], $V4 = [1, 66], $V5 = [1, 67], $V6 = [1, 68], $V7 = [1, 69], $V8 = [1, 80], $V9 = [1, 72], $Va = [1, 73], $Vb = [1, 74], $Vc = [1, 75], $Vd = [1, 99], $Ve = [1, 76], $Vf = [1, 100], $Vg = [1, 79], $Vh = [1, 51], $Vi = [1, 81], $Vj = [1, 82], $Vk = [1, 84], $Vl = [1, 83], $Vm = [1, 85], $Vn = [1, 96], $Vo = [1, 97], $Vp = [1, 98], $Vq = [1, 86], $Vr = [1, 87], $Vs = [1, 64], $Vt = [1, 70], $Vu = [1, 71], $Vv = [1, 77], $Vw = [1, 78], $Vx = [1, 53], $Vy = [1, 54], $Vz = [1, 55], $VA = [1, 61], $VB = [1, 88], $VC = [1, 89], $VD = [1, 90], $VE = [1, 91], $VF = [1, 92], $VG = [1, 93], $VH = [1, 94], $VI = [1, 95], $VJ = [1, 101], $VK = [1, 102], $VL = [1, 103], $VM = [1, 104], $VN = [1, 105], $VO = [1, 56], $VP = [1, 57], $VQ = [1, 58], $VR = [1, 59], $VS = [1, 115], $VT = [1, 111], $VU = [1, 114], $VV = [1, 112], $VW = [1, 113], $VX = [1, 118], $VY = [1, 117], $VZ = [1, 134], $V_ = [1, 149], $V$ = [1, 150], $V01 = [1, 157], $V11 = [5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101], $V21 = [5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 71, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101], $V31 = [5, 6, 7, 9, 13, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95], $V41 = [5, 70, 72], $V51 = [5, 74], $V61 = [71, 101];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: {
      error: 2,
      Program: 3,
      Command: 4,
      EOF: 5,
      RESET: 6,
      BUILD: 7,
      ALL: 8,
      HELP: 9,
      Path: 10,
      MOTM: 11,
      OneArgCommand: 12,
      GET: 13,
      STRING: 14,
      SET: 15,
      Value: 16,
      SET_SAVE: 17,
      SET_RESTORE: 18,
      SET_RESET: 19,
      PRESET: 20,
      AddRepresentation: 21,
      EditRepresentation: 22,
      REMOVE: 23,
      RepresentationReference: 24,
      HIDE: 25,
      SHOW: 26,
      LIST: 27,
      EXPAND_KEY: 28,
      SELECTOR_KEY: 29,
      SELECT: 30,
      AS: 31,
      WordAll: 32,
      SELECTOR: 33,
      WITHIN: 34,
      NUMBER: 35,
      OF: 36,
      MATERIAL: 37,
      IDENTIFIER: 38,
      ModeCMD: 39,
      ColorCMD: 40,
      VIEW: 41,
      BASE_64: 42,
      UNIT: 43,
      DSSP: 44,
      SCALE: 45,
      ROTATE: 46,
      AxesList: 47,
      TRANSLATE: 48,
      CENTER: 49,
      GetURLBranch: 50,
      Screenshot: 51,
      LINE: 52,
      ArgList: 53,
      LISTOBJ: 54,
      REMOVEOBJ: 55,
      URL: 56,
      VIEW_KEY: 57,
      SCREENSHOT: 58,
      LOAD: 59,
      Url: 60,
      FILE_KEY: 61,
      ADD: 62,
      Description: 63,
      REP: 64,
      MODE: 65,
      COLOR: 66,
      Descriptor: 67,
      RepresentationOwnProperty: 68,
      RepresentationOwnPropertyOpts: 69,
      DESC_KEY: 70,
      "=": 71,
      DESC_KEY_OPTS: 72,
      AxesArg: 73,
      DESC_KEY_AXES: 74,
      Arg: 75,
      PathWoDescKey: 76,
      HEX: 77,
      BOOL: 78,
      Word: 79,
      CommandSetWoDESC_KEY: 80,
      DescKeys: 81,
      CLEAR: 82,
      FILE_LIST: 83,
      FILE_REGISTER: 84,
      FILE_DELETE: 85,
      PRESET_ADD: 86,
      PRESET_DELETE: 87,
      PRESET_UPDATE: 88,
      PRESET_RENAME: 89,
      PRESET_OPEN: 90,
      CREATE_SCENARIO: 91,
      RESET_SCENARIO: 92,
      DELETE_SCENARIO: 93,
      ADD_SCENARIO_ITEM: 94,
      LIST_SCENARIO: 95,
      PDB_KEY: 96,
      DELAY_KEY: 97,
      PRST_KEY: 98,
      DESCRIPTION_KEY: 99,
      CommandSet: 100,
      ".": 101,
      PresetPath: 102,
      "/": 103,
      HexOrNumber: 104,
      $accept: 0,
      $end: 1
    },
    terminals_: {
      2: "error",
      5: "EOF",
      6: "RESET",
      7: "BUILD",
      8: "ALL",
      9: "HELP",
      11: "MOTM",
      13: "GET",
      14: "STRING",
      15: "SET",
      17: "SET_SAVE",
      18: "SET_RESTORE",
      19: "SET_RESET",
      20: "PRESET",
      23: "REMOVE",
      25: "HIDE",
      26: "SHOW",
      27: "LIST",
      28: "EXPAND_KEY",
      29: "SELECTOR_KEY",
      30: "SELECT",
      31: "AS",
      33: "SELECTOR",
      34: "WITHIN",
      35: "NUMBER",
      36: "OF",
      37: "MATERIAL",
      38: "IDENTIFIER",
      41: "VIEW",
      42: "BASE_64",
      43: "UNIT",
      44: "DSSP",
      45: "SCALE",
      46: "ROTATE",
      48: "TRANSLATE",
      49: "CENTER",
      52: "LINE",
      54: "LISTOBJ",
      55: "REMOVEOBJ",
      56: "URL",
      57: "VIEW_KEY",
      58: "SCREENSHOT",
      59: "LOAD",
      61: "FILE_KEY",
      62: "ADD",
      64: "REP",
      65: "MODE",
      66: "COLOR",
      70: "DESC_KEY",
      71: "=",
      72: "DESC_KEY_OPTS",
      74: "DESC_KEY_AXES",
      77: "HEX",
      78: "BOOL",
      82: "CLEAR",
      83: "FILE_LIST",
      84: "FILE_REGISTER",
      85: "FILE_DELETE",
      86: "PRESET_ADD",
      87: "PRESET_DELETE",
      88: "PRESET_UPDATE",
      89: "PRESET_RENAME",
      90: "PRESET_OPEN",
      91: "CREATE_SCENARIO",
      92: "RESET_SCENARIO",
      93: "DELETE_SCENARIO",
      94: "ADD_SCENARIO_ITEM",
      95: "LIST_SCENARIO",
      96: "PDB_KEY",
      97: "DELAY_KEY",
      98: "PRST_KEY",
      99: "DESCRIPTION_KEY",
      101: ".",
      103: "/"
    },
    productions_: [0, [3, 2], [3, 1], [4, 1], [4, 1], [4, 2], [4, 1], [4, 2], [4, 1], [4, 1], [4, 2], [4, 2], [4, 3], [4, 3], [4, 1], [4, 1], [4, 1], [4, 1], [4, 2], [4, 1], [4, 1], [4, 2], [4, 2], [4, 2], [4, 2], [4, 1], [4, 2], [4, 2], [4, 2], [4, 4], [4, 2], [4, 6], [4, 2], [4, 1], [4, 1], [4, 1], [4, 2], [4, 2], [4, 1], [4, 2], [4, 1], [4, 2], [4, 2], [4, 2], [4, 1], [4, 2], [4, 1], [4, 1], [4, 3], [4, 3], [4, 4], [4, 4], [4, 1], [4, 2], [50, 1], [50, 2], [50, 2], [50, 3], [50, 3], [51, 1], [51, 2], [51, 3], [12, 2], [12, 2], [12, 2], [21, 1], [21, 2], [21, 2], [21, 3], [22, 2], [22, 3], [39, 2], [39, 3], [40, 2], [40, 3], [24, 1], [24, 1], [63, 1], [63, 2], [63, 3], [63, 4], [67, 1], [67, 1], [67, 2], [68, 3], [69, 3], [47, 1], [47, 2], [73, 2], [53, 1], [53, 2], [75, 3], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [79, 1], [79, 1], [32, 1], [32, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [100, 1], [100, 1], [76, 1], [76, 3], [76, 3], [10, 1], [10, 1], [10, 3], [10, 3], [10, 3], [60, 1], [102, 1], [102, 3], [104, 1], [104, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
        case 3:
          this.$ = yy.miew.reset(false);
          yy.ClearContext();
          yy.miew.resetReps("empty");
          break;
        case 4:
          this.$ = yy.miew.rebuild();
          break;
        case 5:
          this.$ = yy.miew.rebuildAll();
          yy.miew.rebuild();
          break;
        case 6:
          this.$ = yy.echo(yy.utils.help().toString());
          break;
        case 7:
          this.$ = yy.echo(yy.utils.help($$[$0]).toString());
          break;
        case 8:
          this.$ = yy.miew.motm();
          break;
        case 10:
        case 11:
          this.$ = yy.utils.propagateProp($$[$0]);
          yy.echo(yy.miew.get($$[$0]).toString());
          break;
        case 12:
        case 13:
          this.$ = yy.miew.set($$[$0 - 1], yy.utils.propagateProp($$[$0 - 1], $$[$0]));
          break;
        case 14:
          this.$ = yy.miew.saveSettings();
          break;
        case 15:
          this.$ = yy.miew.restoreSettings();
          break;
        case 16:
          this.$ = yy.miew.resetSettings();
          break;
        case 17:
          this.$ = yy.miew.resetReps();
          break;
        case 18:
          this.$ = yy.miew.applyPreset($$[$0]);
          break;
        case 21:
          this.$ = yy.miew.repRemove($$[$0]);
          yy.representations.remove($$[$0]);
          break;
        case 22:
          this.$ = yy.miew.repHide($$[$0]);
          break;
        case 23:
          this.$ = yy.miew.repHide($$[$0], false);
          break;
        case 24:
          this.$ = yy.echo(yy.utils.listRep(yy.miew, yy.representations, $$[$0], "-e"));
          break;
        case 25:
          this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations));
          break;
        case 26:
          this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]));
          break;
        case 27:
          this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context));
          break;
        case 28:
          this.$ = yy.miew.select(yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0], true));
          break;
        case 29:
          this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg($$[$0 - 3].toLowerCase(), $$[$0 - 2], true);
          yy.miew.select(yy.Context[$$[$0].toLowerCase()]);
          break;
        case 30:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            selector: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0])
          });
          break;
        case 31:
          this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(yy.utils.checkArg("select", $$[$0 - 2], true), Number($$[$0 - 4]));
          break;
        case 32:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            material: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
          });
          break;
        case 35:
          this.$ = yy.echo(yy.miew.view());
          break;
        case 36:
        case 37:
          this.$ = yy.miew.view($$[$0]);
          break;
        case 38:
          this.$ = yy.echo(yy.miew.changeUnit());
          break;
        case 39:
          this.$ = yy.echo(yy.miew.changeUnit($$[$0]));
          break;
        case 40:
          this.$ = yy.miew.dssp();
          break;
        case 41:
          this.$ = yy.miew.scale($$[$0]);
          break;
        case 42:
          for (var i2 = 0, n2 = $$[$0].length; i2 < n2; i2++) {
            yy.miew.rotate($$[$0][i2]["x"] * Math.PI / 180, $$[$0][i2]["y"] * Math.PI / 180, $$[$0][i2]["z"] * Math.PI / 180);
          }
          break;
        case 43:
          for (var i2 = 0, n2 = $$[$0].length; i2 < n2; i2++) {
            yy.miew.translate($$[$0][i2]["x"] || 0, $$[$0][i2]["y"] || 0, $$[$0][i2]["z"] || 0);
          }
          break;
        case 44:
          this.$ = yy.miew.center();
          break;
        case 45:
          this.$ = yy.miew.center($$[$0]);
          break;
        case 48:
        case 49:
          this.$ = yy.miew.addObject({
            type: "line",
            params: [$$[$0 - 1], $$[$0]]
          }, true);
          break;
        case 50:
        case 51:
          this.$ = yy.miew.addObject({
            type: "line",
            params: [$$[$0 - 2], $$[$0 - 1]],
            opts: $$[$0].toJSO(yy.utils, "objects", "line")
          }, true);
          break;
        case 52:
          this.$ = yy.echo(yy.utils.listObjs(yy.miew));
          break;
        case 53:
          this.$ = yy.miew.removeObject($$[$0]);
          break;
        case 54:
          this.$ = yy.echo(yy.miew.getURL({
            view: false,
            settings: false
          }));
          break;
        case 55:
          this.$ = yy.echo(yy.miew.getURL({
            view: false,
            settings: true
          }));
          break;
        case 56:
          this.$ = yy.echo(yy.miew.getURL({
            view: true,
            settings: false
          }));
          break;
        case 57:
        case 58:
          this.$ = yy.echo(yy.miew.getURL({
            view: true,
            settings: true
          }));
          break;
        case 59:
          this.$ = yy.miew.screenshotSave();
          break;
        case 60:
          this.$ = yy.miew.screenshotSave("", Number($$[$0]));
          break;
        case 61:
          this.$ = yy.miew.screenshotSave("", Number($$[$0 - 1]), Number($$[$0]));
          break;
        case 62:
        case 63:
        case 64:
          this.$ = yy.utils.load(yy.miew, $$[$0]);
          yy.representations.clear();
          break;
        case 65:
          this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()));
          break;
        case 66:
          this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()));
          break;
        case 67:
          this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])));
          break;
        case 68:
          this.$ = yy.echo(yy.representations.add($$[$0 - 1], yy.miew.repAdd($$[$0])));
          break;
        case 69:
          this.$ = yy.miew.rep($$[$0]);
          yy.miew.repCurrent($$[$0]);
          break;
        case 70:
          this.$ = yy.miew.rep($$[$0 - 1], $$[$0]);
          yy.miew.repCurrent($$[$0 - 1]);
          break;
        case 71:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            mode: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
          });
          break;
        case 72:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            mode: new Array(yy.utils.checkArg($$[$0 - 2].toLowerCase(), $$[$0 - 1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase()))
          });
          break;
        case 73:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            colorer: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
          });
          break;
        case 74:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            colorer: new Array(yy.utils.checkArg($$[$0 - 2].toLowerCase(), $$[$0 - 1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase()))
          });
          break;
        case 75:
          this.$ = Number(yy.representations.get($$[$0]));
          break;
        case 76:
        case 92:
          this.$ = Number($$[$0]);
          break;
        case 77:
          this.$ = $$[$0];
          break;
        case 78:
          this.$ = yy.assign($$[$0 - 1], $$[$0]);
          break;
        case 79:
          this.$ = yy.assign($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 80:
          this.$ = yy.assign($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 81:
        case 82:
          this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val);
          break;
        case 83:
          this.$ = yy.CreateObjectPair($$[$0 - 1].key, new Array($$[$0 - 1].val, $$[$0].toJSO(yy.utils, $$[$0 - 1].key, $$[$0 - 1].val)));
          break;
        case 84:
        case 85:
          this.$ = /* @__PURE__ */ Object.create({
            key: yy.keyRemap($$[$0 - 2]),
            val: yy.utils.checkArg($$[$0 - 2], $$[$0])
          });
          break;
        case 86:
          this.$ = [$$[$0]];
          break;
        case 87:
          this.$ = $$[$0 - 1].concat($$[$0]);
          break;
        case 88:
          this.$ = yy.CreateObjectPair($$[$0 - 1].toLowerCase(), Number($$[$0]));
          break;
        case 89:
          this.$ = new yy.ArgList($$[$0]);
          break;
        case 90:
          this.$ = $$[$0 - 1].append($$[$0]);
          break;
        case 91:
          this.$ = new yy.Arg($$[$0 - 2], $$[$0]);
          break;
        case 93:
          this.$ = parseInt($$[$0]);
          break;
        case 94:
          this.$ = JSON.parse($$[$0]);
          break;
        case 95:
        case 96:
          this.$ = String($$[$0]);
          break;
        case 157:
        case 158:
        case 161:
        case 162:
        case 163:
          this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
          break;
        case 166:
          this.$ = $$[$0 - 2] = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
          break;
      }
    },
    table: [{
      3: 1,
      4: 2,
      5: [1, 3],
      6: [1, 4],
      7: [1, 5],
      9: [1, 6],
      11: [1, 7],
      12: 8,
      13: [1, 9],
      15: [1, 10],
      17: [1, 11],
      18: [1, 12],
      19: [1, 13],
      20: [1, 14],
      21: 15,
      22: 16,
      23: [1, 17],
      25: [1, 18],
      26: [1, 19],
      27: [1, 20],
      30: [1, 21],
      33: [1, 22],
      34: [1, 23],
      37: [1, 24],
      39: 25,
      40: 26,
      41: [1, 27],
      43: [1, 28],
      44: [1, 29],
      45: [1, 30],
      46: [1, 31],
      48: [1, 32],
      49: [1, 33],
      50: 34,
      51: 35,
      52: [1, 36],
      54: [1, 37],
      55: [1, 38],
      56: [1, 44],
      58: [1, 45],
      59: [1, 39],
      62: [1, 40],
      64: [1, 41],
      65: [1, 42],
      66: [1, 43]
    }, {
      1: [3]
    }, {
      5: [1, 46]
    }, {
      1: [2, 2]
    }, {
      5: [2, 3]
    }, {
      5: [2, 4],
      8: [1, 47]
    }, {
      5: [2, 6],
      6: $V0,
      7: $V1,
      9: $V2,
      10: 48,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 8]
    }, {
      5: [2, 9]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 106,
      13: $V3,
      14: [1, 107],
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 108,
      13: $V3,
      14: [1, 109],
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 14]
    }, {
      5: [2, 15]
    }, {
      5: [2, 16]
    }, {
      5: [2, 17],
      14: $VS,
      16: 110,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      5: [2, 19]
    }, {
      5: [2, 20]
    }, {
      24: 116,
      35: $VX,
      38: $VY
    }, {
      24: 119,
      35: $VX,
      38: $VY
    }, {
      24: 120,
      35: $VX,
      38: $VY
    }, {
      5: [2, 25],
      24: 121,
      28: [1, 122],
      29: [1, 123],
      35: $VX,
      38: $VY
    }, {
      14: [1, 124]
    }, {
      14: [1, 125]
    }, {
      35: [1, 126]
    }, {
      38: [1, 127]
    }, {
      5: [2, 33]
    }, {
      5: [2, 34]
    }, {
      5: [2, 35],
      14: [1, 128],
      42: [1, 129]
    }, {
      5: [2, 38],
      35: [1, 130]
    }, {
      5: [2, 40]
    }, {
      35: [1, 131]
    }, {
      47: 132,
      73: 133,
      74: $VZ
    }, {
      47: 135,
      73: 133,
      74: $VZ
    }, {
      5: [2, 44],
      14: [1, 136]
    }, {
      5: [2, 46]
    }, {
      5: [2, 47]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 138,
      13: $V3,
      14: [1, 137],
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 52]
    }, {
      35: [1, 139]
    }, {
      14: [1, 143],
      38: [1, 141],
      60: 140,
      61: [1, 142]
    }, {
      5: [2, 65],
      38: [1, 144],
      63: 145,
      67: 146,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, {
      24: 151,
      35: $VX,
      38: $VY
    }, {
      38: [1, 152]
    }, {
      38: [1, 153]
    }, {
      5: [2, 54],
      29: [1, 154],
      57: [1, 155]
    }, {
      5: [2, 59],
      35: [1, 156]
    }, {
      1: [2, 1]
    }, {
      5: [2, 5]
    }, {
      5: [2, 7],
      101: $V01
    }, o2($V11, [2, 159]), o2($V11, [2, 160]), o2($V21, [2, 97]), o2($V21, [2, 98]), o2($V11, [2, 147]), o2($V11, [2, 148]), o2($V11, [2, 149]), o2($V11, [2, 150]), o2($V11, [2, 151]), o2($V11, [2, 152]), o2($V11, [2, 153]), o2($V21, [2, 101]), o2($V21, [2, 102]), o2($V21, [2, 103]), o2($V21, [2, 104]), o2($V21, [2, 105]), o2($V21, [2, 106]), o2($V21, [2, 107]), o2($V21, [2, 108]), o2($V21, [2, 109]), o2($V21, [2, 110]), o2($V21, [2, 111]), o2($V21, [2, 112]), o2($V21, [2, 113]), o2($V21, [2, 114]), o2($V21, [2, 115]), o2($V21, [2, 116]), o2($V21, [2, 117]), o2($V21, [2, 118]), o2($V21, [2, 119]), o2($V21, [2, 120]), o2($V21, [2, 121]), o2($V21, [2, 122]), o2($V21, [2, 123]), o2($V21, [2, 124]), o2($V21, [2, 125]), o2($V21, [2, 126]), o2($V21, [2, 127]), o2($V21, [2, 128]), o2($V21, [2, 129]), o2($V21, [2, 130]), o2($V21, [2, 131]), o2($V21, [2, 132]), o2($V21, [2, 133]), o2($V21, [2, 134]), o2($V21, [2, 135]), o2($V21, [2, 136]), o2($V21, [2, 137]), o2($V21, [2, 138]), o2($V21, [2, 139]), o2($V21, [2, 140]), o2($V21, [2, 141]), o2($V21, [2, 142]), o2($V21, [2, 143]), o2($V21, [2, 144]), o2($V21, [2, 145]), o2($V21, [2, 146]), {
      5: [2, 10],
      101: $V01
    }, {
      5: [2, 11]
    }, {
      14: $VS,
      16: 158,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW,
      101: $V01
    }, {
      14: $VS,
      16: 159,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      5: [2, 18]
    }, o2($V31, [2, 92]), o2($V31, [2, 93]), o2($V31, [2, 94]), o2($V31, [2, 95]), o2($V31, [2, 96]), {
      5: [2, 21]
    }, o2($V41, [2, 75]), o2($V41, [2, 76]), {
      5: [2, 22]
    }, {
      5: [2, 23]
    }, {
      5: [2, 24]
    }, {
      5: [2, 26]
    }, {
      5: [2, 27]
    }, {
      5: [2, 28],
      31: [1, 160]
    }, {
      5: [2, 30]
    }, {
      36: [1, 161]
    }, {
      5: [2, 32]
    }, {
      5: [2, 36]
    }, {
      5: [2, 37]
    }, {
      5: [2, 39]
    }, {
      5: [2, 41]
    }, {
      5: [2, 42],
      73: 162,
      74: $VZ
    }, o2($V51, [2, 86]), {
      35: [1, 163]
    }, {
      5: [2, 43],
      73: 162,
      74: $VZ
    }, {
      5: [2, 45]
    }, {
      14: [1, 164]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 165,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR,
      101: $V01
    }, {
      5: [2, 53]
    }, {
      5: [2, 62]
    }, {
      5: [2, 63]
    }, {
      5: [2, 64]
    }, {
      5: [2, 164]
    }, {
      5: [2, 66],
      63: 166,
      67: 146,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, {
      5: [2, 67]
    }, {
      5: [2, 77],
      67: 167,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, o2($V41, [2, 81]), o2($V41, [2, 82], {
      80: 52,
      53: 168,
      75: 169,
      76: 170,
      79: 171,
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }), {
      71: [1, 172]
    }, {
      71: [1, 173]
    }, {
      5: [2, 69],
      63: 174,
      67: 146,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, {
      5: [2, 71],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 175,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 73],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 176,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 55],
      57: [1, 177]
    }, {
      5: [2, 56],
      29: [1, 178]
    }, {
      5: [2, 60],
      35: [1, 179]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      35: [1, 181],
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 180,
      80: 52,
      81: 182,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 12]
    }, {
      5: [2, 13]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      32: 183,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 184,
      80: 52,
      81: 185,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      14: [1, 186]
    }, o2($V51, [2, 87]), o2($V51, [2, 88]), {
      5: [2, 48],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 187,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 49],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 188,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      101: $V01
    }, {
      5: [2, 68]
    }, {
      5: [2, 78],
      67: 189,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, o2($V41, [2, 83], {
      80: 52,
      76: 170,
      79: 171,
      75: 190,
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }), o2($V31, [2, 89]), {
      71: [1, 191],
      101: [1, 192]
    }, o2($V61, [2, 156]), {
      14: $VS,
      16: 193,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      14: $VS,
      16: 194,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      5: [2, 70]
    }, {
      5: [2, 72],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 74],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 57]
    }, {
      5: [2, 58]
    }, {
      5: [2, 61]
    }, o2($V11, [2, 161]), o2($V11, [2, 162]), o2($V11, [2, 163]), {
      5: [2, 29]
    }, {
      5: [2, 99]
    }, {
      5: [2, 100]
    }, {
      31: [1, 195]
    }, {
      5: [2, 50],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 51],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 79],
      67: 196,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, o2($V31, [2, 90]), {
      14: $VS,
      16: 197,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      35: [1, 199],
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      79: 198,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, o2($V41, [2, 84]), o2($V31, [2, 85]), {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      32: 200,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 184,
      80: 52,
      81: 185,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 80]
    }, o2($V31, [2, 91]), o2($V61, [2, 157]), o2($V61, [2, 158]), {
      5: [2, 31]
    }],
    defaultActions: {
      3: [2, 2],
      4: [2, 3],
      7: [2, 8],
      8: [2, 9],
      11: [2, 14],
      12: [2, 15],
      13: [2, 16],
      15: [2, 19],
      16: [2, 20],
      25: [2, 33],
      26: [2, 34],
      29: [2, 40],
      34: [2, 46],
      35: [2, 47],
      37: [2, 52],
      46: [2, 1],
      47: [2, 5],
      107: [2, 11],
      110: [2, 18],
      116: [2, 21],
      119: [2, 22],
      120: [2, 23],
      121: [2, 24],
      122: [2, 26],
      123: [2, 27],
      125: [2, 30],
      127: [2, 32],
      128: [2, 36],
      129: [2, 37],
      130: [2, 39],
      131: [2, 41],
      136: [2, 45],
      139: [2, 53],
      140: [2, 62],
      141: [2, 63],
      142: [2, 64],
      143: [2, 164],
      145: [2, 67],
      158: [2, 12],
      159: [2, 13],
      166: [2, 68],
      174: [2, 70],
      177: [2, 57],
      178: [2, 58],
      179: [2, 61],
      183: [2, 29],
      184: [2, 99],
      185: [2, 100],
      196: [2, 80],
      200: [2, 31]
    },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self2 = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = {
        yy: {}
      };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token;
        token = tstack.pop() || lexer2.lex() || EOF;
        if (typeof token !== "number") {
          if (token instanceof Array) {
            tstack = token;
            token = tstack.pop();
          }
          token = self2.symbols_[token] || token;
        }
        return token;
      }
      var symbol5, state, action, r2, yyval = {}, p2, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol5 === null || typeof symbol5 == "undefined") {
            symbol5 = lex();
          }
          action = table[state] && table[state][symbol5];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p2 in table[state]) {
            if (this.terminals_[p2] && p2 > TERROR) {
              expected.push("'" + this.terminals_[p2] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol5] || symbol5) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol5 == EOF ? "end of input" : "'" + (this.terminals_[symbol5] || symbol5) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol5] || symbol5,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol5);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol5);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol5 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r2 = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
            if (typeof r2 !== "undefined") {
              return r2;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = /* @__PURE__ */ function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function setInput(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function input() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function unput(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r2 = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function more() {
        this._more = true;
        return this;
      },
      reject: function reject() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function less(n2) {
        this.unput(this.match.slice(n2));
      },
      pastInput: function pastInput() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function upcomingInput() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function showPosition() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function test_match(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function next() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i2 = 0; i2 < rules.length; i2++) {
          tempMatch = this._input.match(this.rules[rules[i2]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i2;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i2]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r2 = this.next();
        if (r2) {
          return r2;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n2 = this.conditionStack.length - 1;
        if (n2 > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n2) {
        n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
        if (n2 >= 0) {
          return this.conditionStack[n2];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {
        "case-insensitive": true
      },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return "";
          case 2:
            return "";
          case 3:
            return 42;
          case 4:
            return 35;
          case 5:
            return 77;
          case 6:
            return 78;
          case 7:
            return 78;
          case 8:
            return 8;
          case 9:
            return 6;
          case 10:
            return 82;
          case 11:
            return 7;
          case 12:
            return 9;
          case 13:
            return 59;
          case 14:
            return 13;
          case 15:
            return 15;
          case 16:
            return 17;
          case 17:
            return 18;
          case 18:
            return 19;
          case 19:
            return 20;
          case 20:
            return 11;
          case 21:
            return 62;
          case 22:
            return 64;
          case 23:
            return 23;
          case 24:
            return 25;
          case 25:
            return 26;
          case 26:
            return 27;
          case 27:
            return 30;
          case 28:
            return 34;
          case 29:
            return 33;
          case 30:
            return 65;
          case 31:
            return 66;
          case 32:
            return 37;
          case 33:
            return 41;
          case 34:
            return 43;
          case 35:
            return 52;
          case 36:
            return 54;
          case 37:
            return 55;
          case 38:
            return 46;
          case 39:
            return 48;
          case 40:
            return 45;
          case 41:
            return 49;
          case 42:
            return 56;
          case 43:
            return 58;
          case 44:
            return 44;
          case 45:
            return 83;
          case 46:
            return 84;
          case 47:
            return 85;
          case 48:
            return 86;
          case 49:
            return 87;
          case 50:
            return 88;
          case 51:
            return 89;
          case 52:
            return 90;
          case 53:
            return 91;
          case 54:
            return 92;
          case 55:
            return 93;
          case 56:
            return 94;
          case 57:
            return 95;
          case 58:
            return 70;
          case 59:
            return 70;
          case 60:
            return 72;
          case 61:
            return 72;
          case 62:
            return 74;
          case 63:
            return 74;
          case 64:
            return 74;
          case 65:
            return 31;
          case 66:
            return 36;
          case 67:
            return 96;
          case 68:
            return 97;
          case 69:
            return 98;
          case 70:
            return 99;
          case 71:
            yy_.yytext = yy.utils.unquoteString(yy_.yytext);
            return 14;
          case 72:
            return 38;
          case 73:
            return 5;
          case 74:
            return 101;
          case 75:
            return 103;
          case 76:
            return "\\";
          case 77:
            return 28;
          case 78:
            return 61;
          case 79:
            return 29;
          case 80:
            return 57;
          case 81:
            return 71;
        }
      },
      rules: [/^(?:\s+)/i, /^(?:[#].*)/i, /^(?:\/\/.*)/i, /^(?:([_A-Z0-9\/\+]+==))/i, /^(?:-?[0-9]+(\.[0-9]+)?\b)/i, /^(?:0[xX][0-9A-F]+\b)/i, /^(?:false\b)/i, /^(?:true\b)/i, /^(?:all\b)/i, /^(?:reset\b)/i, /^(?:clear\b)/i, /^(?:build\b)/i, /^(?:help\b)/i, /^(?:load\b)/i, /^(?:get\b)/i, /^(?:set\b)/i, /^(?:set_save\b)/i, /^(?:set_restore\b)/i, /^(?:set_reset\b)/i, /^(?:preset\b)/i, /^(?:motm\b)/i, /^(?:add\b)/i, /^(?:rep\b)/i, /^(?:remove\b)/i, /^(?:hide\b)/i, /^(?:show\b)/i, /^(?:list\b)/i, /^(?:select\b)/i, /^(?:within\b)/i, /^(?:selector\b)/i, /^(?:mode\b)/i, /^(?:color\b)/i, /^(?:material\b)/i, /^(?:view\b)/i, /^(?:unit\b)/i, /^(?:line\b)/i, /^(?:listobj\b)/i, /^(?:removeobj\b)/i, /^(?:rotate\b)/i, /^(?:translate\b)/i, /^(?:scale\b)/i, /^(?:center\b)/i, /^(?:url\b)/i, /^(?:screenshot\b)/i, /^(?:dssp\b)/i, /^(?:file_list\b)/i, /^(?:file_register\b)/i, /^(?:file_delete\b)/i, /^(?:preset_add\b)/i, /^(?:preset_delete\b)/i, /^(?:preset_update\b)/i, /^(?:preset_rename\b)/i, /^(?:preset_open\b)/i, /^(?:create_scenario\b)/i, /^(?:reset_scenario\b)/i, /^(?:delete_scenario\b)/i, /^(?:add_scenario_item\b)/i, /^(?:list_scenario\b)/i, /^(?:s\b)/i, /^(?:mt\b)/i, /^(?:m\b)/i, /^(?:c\b)/i, /^(?:x\b)/i, /^(?:y\b)/i, /^(?:z\b)/i, /^(?:as\b)/i, /^(?:of\b)/i, /^(?:pdb\b)/i, /^(?:delay\b)/i, /^(?:prst\b)/i, /^(?:desc\b)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:\.)/i, /^(?:\/)/i, /^(?:\\)/i, /^(?:-e\b)/i, /^(?:-f\b)/i, /^(?:-s\b)/i, /^(?:-v\b)/i, /^(?:=)/i],
      conditions: {
        INITIAL: {
          rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81],
          inclusive: true
        }
      }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
var MiewCLIParser = {
  parser
};
var modeIdDesc = {
  $help: ["Rendering mode shortcut", "    BS - balls and sticks mode", "    LN - lines mode", "    LC - licorice mode", "    VW - van der waals mode", "    TR - trace mode", "    TU - tube mode", "    CA - cartoon mode", "    SA - isosurface mode", "    QS - quick surface mode", "    SE - solvent excluded mode", "    TX - text mode"],
  BS: {
    $help: ["   Balls and sticks", "      aromrad = <number> #aromatic radius", "      atom = <number>    #atom radius", "      bond = <number>    #bond radius", "      multibond = <bool> #use multibond", "      showarom = <bool>  #show aromatic", "      space = <number>   #space value\n"]
  },
  CA: {
    $help: ["   Cartoon", "      arrow = <number>   #arrow size", "      depth = <number>   #depth of surface", "      heightSegmentsRatio = <number>", "      radius = <number>  #tube radius", "      tension = <number> #", "      width = <number>  #secondary width\n"]
  },
  LN: {
    $help: ["   Lines", "      atom = <number>    #atom radius", "      chunkarom = <number>", "      multibond = <bool> #use multibond", "      showarom = <bool>  #show aromatic", "      offsarom = <number>\n"]
  },
  LC: {
    $help: ["   Licorice", "      aromrad = <number> #aromatic radius", "      bond = <number>    #bond radius", "      multibond = <bool> #use multibond", "      showarom = <bool>  #show aromatic", "      space = <number>   #space value\n"]
  },
  VW: {
    $help: ["   Van der Waals", "      nothing\n"]
  },
  TR: {
    $help: ["   Trace", "      radius = <number>  #tube radius\n"]
  },
  TU: {
    $help: ["   Tube", "      heightSegmentsRatio = <number>", "      radius = <number>  #tube radius", "      tension = <number> \n"]
  },
  SA: {
    $help: ["   Surface", "      zClip = <bool> #clip z plane\n"]
  },
  QS: {
    $help: ["   Quick surface", "      isoValue = <number>", "      scale = <number>", "      wireframe = <bool>", "      zClip = <bool> #clip z plane\n"]
  },
  SE: {
    $help: ["   Solvent excluded surface", "      zClip = <bool> #clip z plane\n"]
  },
  TX: {
    $help: ["   Text mode", '      template = <format string> string that can include "{{ id }}"', "          it will be replaced by value, id can be one of next:", "          serial, name, type, sequence, residue, chain, hetatm, water\n", '      horizontalAlign = <string> {"left", "right", "center"}', '      verticalAlign = <string> {"top", "bottom", "middle"}', "      dx = <number> #offset along x", "      dy = <number> #offset along y", "      dz = <number> #offset along z", "      fg = <string> #text color modificator", "           could be keyword, named color or hex", "      fg = <string> #back color modificator", "           could be keyword, named color or hex", "      showBg = <bool> #if set show background", "           plate under text"]
  }
};
var colorDesc = {
  $help: ["Coloring mode shortcut", "    EL - color by element", "    CH - color by chain", "    SQ - color by sequence", "    RT - color by residue type", "    SS - color by secondary structure", "    UN - uniform"],
  UN: {
    $help: ["Parameters of coloring modes customization", "   Uniform", "      color = <number|color> #RGB->HEX->dec\n"],
    color: {
      $help: Object.keys(palettes$1.get(settings$1.now.palette).namedColors).sort().join("\n")
    }
  }
};
var materialDesc = {
  $help: ["Material shortcut", "    DF - diffuse", "    TR - transparent", "    SF - soft plastic", "    PL - glossy plastic", "    ME - metal", "    GL - glass"]
};
var addRepDesc = {
  $help: ["Short (packed) representation description as a set of variables", "    s=<EXPRESSION>", "        selector property", "    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]", "        render mode property", "    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]", "        color mode property", "    mt=<MATERIAL_ID>", "        material property"],
  s: {
    $help: "Selection expression string as it is in menu->representations->selection"
  },
  m: modeIdDesc,
  c: colorDesc,
  mt: materialDesc
};
var setGetParameterDesc = {
  $help: ["Parameters of rendering modes customization: modes", "Parameters of colorer customization: colorers", "Autobuild: autobuild = (<number>|<bool>)"],
  modes: modeIdDesc,
  colorers: colorDesc
};
var help = {
  $help: ["help (<cmd name>| <path to property>)", "You can get detailed information about command options", '   using "help cmd.opt.opt.[...]"\n', "   you can use one line comments", "   everything started from (#|//) will be skipped", "   Example: >build //some comment\n", "List of available commands:"],
  reset: {
    $help: ["Reload current object, delete all representations", "    Nothing will work until load new object"]
  },
  load: {
    $help: ["load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])", "    Load new pdb object from selected source"],
    PDBID: {
      $help: "pdb id in remote molecule database"
    },
    URL: {
      $help: "url to source file"
    },
    f: {
      $help: ["open file system dialog to fetch local file", "optionally you can determine trajectory file", "via URL for *.top model"]
    }
  },
  clear: {
    $help: "No args. Clear terminal"
  },
  add: {
    $help: ["add [<REP_NAME>] [<DESCRIPTION>]", "    Add new item to representation set with", "    default or <DESCRIPTION> params"],
    REP_NAME: {
      $help: "Identifier string [_,a-z,A-Z,0-9] can not start from digit"
    },
    DESCRIPTION: addRepDesc
  },
  rep: {
    $help: ["rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]", "    set current representation by name or index", "    edit current representation by <DESCRIPTION>"],
    REP_NAME: {
      $help: ["Identifier string [_,a-z,A-Z,0-9] can not start from digit", "Must be declared before"]
    },
    REP_INDEX: {
      $help: "Index of available representation"
    },
    DESCRIPTION: addRepDesc
  },
  remove: {
    $help: ["remove (<REP_NAME>|<REP_INDEX>)", "Remove representation by name or index"],
    REP_NAME: {
      $help: ["Identifier string [_,a-z,A-Z,0-9] can not start from digit", "Must be declared before"]
    },
    REP_INDEX: {
      $help: "Index of available representation"
    }
  },
  selector: {
    $help: ["selector <EXPRESSION>", "   set selector from EXPRESSION to current representation"],
    EXPRESSION: {
      $help: "Selection expression string as it is in menu->representations->selection"
    }
  },
  mode: {
    $help: ["mode <MODE_ID> [<PARAMETER>=<VALUE>...]", "   set rendering mode and apply parameters to current representation"],
    MODE_ID: modeIdDesc
  },
  color: {
    $help: ["color <COLORER_ID> [<PARAMETER>=<VALUE>...]", "   set colorer and apply parameters to current representation"],
    COLORER_ID: colorDesc
  },
  material: {
    $help: ["material <MATERIAL_ID>", "   set material to current representation"],
    MATERIAL_ID: materialDesc
  },
  build: {
    $help: "build help str",
    add: {
      $help: "build.add",
      new: {
        $help: ["add.new", "add.new new line 1", "add.new new line 2", "add.new new line 3"]
      }
    },
    del: {
      $help: "build.del"
    }
  },
  list: {
    $help: ["list [-e|-s|<REP_NAME>|<REP_INDEX>]", "Print representations if no args print list of representations", "    -e expand list and show all representations", "    -s show all user-registered selectors", "    <REP_NAME>|<REP_INDEX> show only current representation"]
  },
  hide: {
    $help: ["hide (<REP_NAME>|<REP_INDEX>)", "Hide representation referenced in args"]
  },
  show: {
    $help: ["show (<REP_NAME>|<REP_INDEX>)", "Show representation referenced in args"]
  },
  get: {
    $help: ["get <PARAMETER>", "Print <PARAMETER> value", "    <PARAMETER> - path to option use get.PARAMETER to get more info"],
    PARAMETER: setGetParameterDesc
  },
  set: {
    $help: ["set <PARAMETER> <VALUE>", "Set <PARAMETER> with <VALUE>", "    <PARAMETER> - path to option use set.PARAMETER to get more info"],
    PARAMETER: setGetParameterDesc
  },
  set_save: {
    $help: ["set_save", "Save current settings to cookie"]
  },
  set_restore: {
    $help: ["set_restore", "Load and apply settings from cookie"]
  },
  set_reset: {
    $help: ["set_reset", "Reset current settings to the defaults"]
  },
  preset: {
    $help: ["preset [<PRESET>]", "Reset current representation or set preset to <PRESET>"],
    PRESET: {
      $help: ["default", "wire", "small", "macro"]
    }
  },
  unit: {
    $help: ["unit [<unit_id>]", "Change current biological structure view. Zero <unit_id> value means asymmetric unit,", "positive values set an assembly with corresponding number.", "Being called with no parameters command prints current unit information."]
  },
  view: {
    $help: ["view [<ENCODED_VIEW>]", "Get current encoded view or set if ENCODED_VIEW placed as argument"],
    ENCODED_VIEW: {
      $help: ["encoded view matrix string (binary code)"]
    }
  },
  rotate: {
    $help: ["rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...", "Rotate scene"]
  },
  scale: {
    $help: ["scale <SCALE>", "Scale scene"]
  },
  select: {
    $help: ["select <SELECTOR_STRING> [as <SELECTOR_NAME>]", "Select atoms using selector defined in SELECTOR_STRING", "    and if SELECTOR_NAME is defined register it in viewer", "    you can use it later as a complex selector"]
  },
  within: {
    $help: ["within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>", "Build within named selector", "    DISTANCE        <number>", "    SELECTOR_STRING <string(selection language)>", "    SELECTOR_NAME   <identifier>"]
  },
  url: {
    $help: ["url [-s] [-v]", "Report URL encoded scene", "    if -s set that include settings in the URL", "    if -v set that include view in the URL"]
  },
  screenshot: {
    $help: ["screenshot [<WIDTH> [<HEIGHT>]]", "Make a screenshot of the scene", "    WIDTH  <number> in pixels", "    HEIGHT <number> in pixels, equal to WIDTH by default"]
  },
  line: {
    $help: ["line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]", "Draw dashed line between two specified atoms"]
  },
  removeobj: {
    $help: ["removeobj <id>", "Remove scene object by its index. Indices could be obtained by <listobj> command"]
  },
  listobj: {
    $help: ["listobj", "Display the list of all existing scene objects"]
  }
};
var selectors = Miew.chem.selectors;
var modes = Miew.modes;
var colorers = Miew.colorers;
var materials = Miew.materials;
var palettes = Miew.palettes;
var options = Miew.options;
var settings = Miew.settings;
function None() {
}
var NULL = function() {
  var obj = new None();
  return function() {
    return obj;
  };
}();
var RepresentationMap = function() {
  function RepresentationMap2() {
    _classCallCheck(this, RepresentationMap2);
    this.representationMap = {};
    this.representationID = {};
  }
  _createClass(RepresentationMap2, [{
    key: "get",
    value: function get3(strId) {
      return this.representationMap[strId] || this.representationID[strId] || "<no name>";
    }
  }, {
    key: "add",
    value: function add(strId, index) {
      if (strId === -1) {
        return "Can not create representation: there is no data";
      }
      if (index !== void 0) {
        if (!this.representationMap.hasOwnProperty(strId)) {
          this.representationMap[strId.toString()] = index;
          this.representationID[index] = strId.toString();
        } else {
          return "This name has already existed, registered without name";
        }
      }
      return "Representation ".concat(strId, " successfully added");
    }
  }, {
    key: "remove",
    value: function remove3(index) {
      if (index && this.representationID.hasOwnProperty(index)) {
        delete this.representationMap[this.representationID[index]];
        delete this.representationID[index];
      }
      var sortedKeys = Object.keys(this.representationID).sort();
      for (var i2 in sortedKeys) {
        if (sortedKeys.hasOwnProperty(i2)) {
          var id = sortedKeys[i2];
          if (id > index) {
            this.representationID[id - 1] = this.representationID[id];
            this.representationMap[this.representationID[id]] -= 1;
            delete this.representationID[id];
          }
        }
      }
    }
  }, {
    key: "clear",
    value: function clear3() {
      this.representationMap = {};
      this.representationID = {};
    }
  }]);
  return RepresentationMap2;
}();
var representationsStorage = new RepresentationMap();
function keyRemap(key) {
  var keys2 = {
    s: "selector",
    m: "mode",
    c: "colorer",
    mt: "material",
    mode: "modes",
    color: "colorers",
    colorer: "colorers",
    select: "selector",
    material: "materials",
    selector: "selector"
  };
  var ans = keys2[key];
  return ans === void 0 ? key : ans;
}
var CLIUtils = function() {
  function CLIUtils2() {
    _classCallCheck(this, CLIUtils2);
  }
  _createClass(CLIUtils2, [{
    key: "list",
    value: function list(miew, repMap, key) {
      var ret = "";
      if (miew && repMap !== void 0) {
        if (key === void 0 || key === "-e") {
          var count = miew.repCount();
          for (var i2 = 0; i2 < count; i2++) {
            ret += this.listRep(miew, repMap, i2, key);
          }
        }
      }
      return ret;
    }
  }, {
    key: "listRep",
    value: function listRep(miew, repMap, repIndex2, key) {
      var ret = "";
      var rep2 = miew.repGet(repIndex2);
      if (!rep2) {
        logger.warn("Rep ".concat(repIndex2, " does not exist!"));
        return ret;
      }
      var index = repIndex2;
      var repName = repMap.get(index);
      var mode2 = rep2.mode, colorer = rep2.colorer;
      var selectionStr = rep2.selectorString;
      var material2 = rep2.materialPreset;
      ret += "#".concat(index, " : ").concat(mode2.name).concat(repName === "<no name>" ? "" : ", ".concat(repName), "\n");
      if (key !== void 0) {
        ret += '    selection : "'.concat(selectionStr, '"\n');
        ret += "    mode      : (".concat(mode2.id, "), ").concat(mode2.name, "\n");
        ret += "    colorer   : (".concat(colorer.id, "), ").concat(colorer.name, "\n");
        ret += "    material  : (".concat(material2.id, "), ").concat(material2.name, "\n");
      }
      return ret;
    }
  }, {
    key: "listSelector",
    value: function listSelector(miew, context) {
      var ret = "";
      for (var k2 in context) {
        if (context.hasOwnProperty(k2)) {
          ret += "".concat(k2, ' : "').concat(context[k2], '"\n');
        }
      }
      return ret;
    }
  }, {
    key: "listObjs",
    value: function listObjs(miew) {
      var objs = miew._objects;
      if (!objs || !Array.isArray(objs) || objs.length === 0) {
        return "There are no objects on the scene";
      }
      var strList = [];
      for (var i2 = 0, n2 = objs.length; i2 < n2; ++i2) {
        strList[i2] = "".concat(i2, ": ").concat(objs[i2].toString());
      }
      return strList.join("\n");
    }
  }, {
    key: "joinHelpStr",
    value: function joinHelpStr(helpData) {
      if (helpData instanceof Array) {
        return helpData.join("\n");
      }
      return helpData;
    }
  }, {
    key: "help",
    value: function help$1(path) {
      if ((0, import_lodash.isUndefined)(path)) {
        return "".concat(this.joinHelpStr(help.$help), "\n").concat((0, import_lodash.slice)((0, import_lodash.sortBy)((0, import_lodash.keys)(help)), 1).join(", "), "\n");
      }
      var helpItem = (0, import_lodash.get)(help, path);
      return (0, import_lodash.isUndefined)(helpItem) ? this.help() : "".concat(this.joinHelpStr(helpItem.$help), "\n");
    }
  }, {
    key: "load",
    value: function load(miew, arg) {
      if (miew === void 0 || arg === void 0 || arg === "-f") {
        return;
      }
      miew.awaitWhileCMDisInProcess();
      var finish = function finish2() {
        return miew.finishAwaitingCMDInProcess();
      };
      miew.load(arg).then(finish, finish);
    }
  }, {
    key: "checkArg",
    value: function checkArg(key, arg, modificate) {
      if (key !== void 0 && arg !== void 0) {
        if (keyRemap(key) === "selector") {
          var res = selectors.parse(arg);
          if (res.error !== void 0) {
            var selExc = {
              message: res.error
            };
            throw selExc;
          }
          if (modificate !== void 0 && modificate) {
            return res.selector;
          }
          return arg;
        }
        var modificators = {
          colorers,
          modes,
          materials
        };
        var modificator = key;
        var temp;
        while (modificator !== temp) {
          temp = modificator;
          modificator = keyRemap(temp);
        }
        if (modificators[modificator].get(arg) === void 0) {
          var exc = {
            message: "".concat(arg, " is not existed in ").concat(modificator)
          };
          throw exc;
        }
        return arg;
      }
      return NULL;
    }
  }, {
    key: "propagateProp",
    value: function propagateProp(path, arg) {
      if (path !== void 0) {
        var argExc = {};
        var adapter = options.adapters[_typeof((0, import_lodash.get)(settings.defaults, path))];
        if (adapter === void 0) {
          var pathExc = {
            message: "".concat(path, " is not existed")
          };
          throw pathExc;
        }
        if ((path.endsWith(".color") || path.endsWith(".baseColor") || path.endsWith(".EL.carbon")) && typeof arg !== "number") {
          arg = palettes.get(settings.now.palette).getNamedColor(arg);
        }
        if (path.endsWith(".fg") || path.endsWith(".bg")) {
          if (typeof arg !== "number") {
            var val = palettes.get(settings.now.palette).getNamedColor(arg, true);
            if (val !== void 0) {
              arg = "0x".concat(val.toString(16));
            }
          } else {
            arg = "0x".concat(arg.toString(16));
          }
        }
        if (path.endsWith(".template")) {
          arg = arg.replace(/\\n/g, "\n");
        }
        if (arg !== void 0 && adapter(arg) !== arg && adapter(arg) !== arg > 0) {
          argExc = {
            message: "".concat(path, ' must be a "').concat(_typeof((0, import_lodash.get)(settings.defaults, path)), '"')
          };
          throw argExc;
        }
      }
      return arg;
    }
  }, {
    key: "unquoteString",
    value: function unquoteString2(value) {
      return utils.unquoteString(value);
    }
  }]);
  return CLIUtils2;
}();
var utilFunctions = new CLIUtils();
function CreateObjectPair(a2, b2) {
  var obj = {};
  obj[a2] = b2;
  return obj;
}
function ArgList(arg) {
  if (arg instanceof this.constructor) {
    return arg;
  }
  if (arg instanceof Array) {
    this._values = arg.slice(0);
  } else if (arg) {
    this._values = [arg];
  } else {
    this._values = [];
  }
}
ArgList.prototype.append = function(value) {
  var values = this._values;
  values[values.length] = value;
  return this;
};
ArgList.prototype.remove = function(value) {
  var values = this._values;
  var index = values.indexOf(value);
  if (index >= 0) {
    values.splice(index, 1);
  }
  return this;
};
ArgList.prototype.toJSO = function(cliUtils, cmd, arg) {
  var res = {};
  var list = this._values;
  for (var i2 = 0, n2 = list.length; i2 < n2; ++i2) {
    (0, import_lodash.set)(res, list[i2].id, cliUtils.propagateProp("".concat(keyRemap(cmd), ".").concat(arg, ".").concat(list[i2].id), list[i2].val));
  }
  return res;
};
function Arg(_id2, _val) {
  this.id = _id2;
  this.val = _val;
}
var cliutils = /* @__PURE__ */ Object.create({});
cliutils.Arg = Arg;
cliutils.ArgList = ArgList;
cliutils.miew = null;
cliutils.echo = null;
cliutils.representations = representationsStorage;
cliutils.utils = utilFunctions;
cliutils.assign = import_lodash.assign;
cliutils.CreateObjectPair = CreateObjectPair;
cliutils.keyRemap = keyRemap;
cliutils.Context = selectors.Context;
cliutils.ClearContext = selectors.ClearContext;
cliutils.NULL = NULL;
cliutils.notimplemented = function() {
  return this.NULL;
};
Miew.prototype.script = function(script, _printCallback, _errorCallback) {
  MiewCLIParser.parser.yy.miew = this;
  MiewCLIParser.parser.yy.echo = _printCallback;
  MiewCLIParser.parser.yy.error = _errorCallback;
  if (this.cmdQueue === void 0) {
    this.cmdQueue = [];
  }
  if (this.commandInAction === void 0) {
    this.commandInAction = false;
  }
  this.cmdQueue = this.cmdQueue.concat(script.split("\n"));
};
Miew.prototype.awaitWhileCMDisInProcess = function() {
  this.commandInAction = true;
};
Miew.prototype.finishAwaitingCMDInProcess = function() {
  this.commandInAction = false;
};
Miew.prototype.isScriptingCommandAvailable = function() {
  return this.commandInAction !== void 0 && !this.commandInAction && this.cmdQueue !== void 0 && this.cmdQueue.length > 0;
};
Miew.prototype.callNextCmd = function() {
  if (this.isScriptingCommandAvailable()) {
    var cmd = this.cmdQueue.shift();
    var res = {};
    res.success = false;
    try {
      MiewCLIParser.parser.parse(cmd);
      res.success = true;
    } catch (e2) {
      res.error = e2.message;
      MiewCLIParser.parser.yy.error(res.error);
      this.finishAwaitingCMDInProcess();
    }
    return res;
  }
  return "";
};
MiewCLIParser.parser.yy = cliutils;
MiewCLIParser.parser.yy.parseError = MiewCLIParser.parser.parseError;

// node_modules/use-resize-observer/dist/bundle.esm.js
var import_react2 = __toESM(require_react());
function useResolvedElement(subscriber, refOrElement) {
  var callbackRefElement = (0, import_react2.useRef)(null);
  var refCallback = (0, import_react2.useCallback)(function(element) {
    callbackRefElement.current = element;
    callSubscriber();
  }, []);
  var lastReportedElementRef = (0, import_react2.useRef)(null);
  var cleanupRef = (0, import_react2.useRef)();
  var callSubscriber = function callSubscriber2() {
    var element = null;
    if (callbackRefElement.current) {
      element = callbackRefElement.current;
    } else if (refOrElement) {
      if (refOrElement instanceof HTMLElement) {
        element = refOrElement;
      } else {
        element = refOrElement.current;
      }
    }
    if (lastReportedElementRef.current === element) {
      return;
    }
    if (cleanupRef.current) {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    lastReportedElementRef.current = element;
    if (element) {
      cleanupRef.current = subscriber(element);
    }
  };
  (0, import_react2.useEffect)(function() {
    callSubscriber();
  }, [refOrElement]);
  return refCallback;
}
function useResizeObserver(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var onResize = opts.onResize;
  var onResizeRef = (0, import_react2.useRef)(void 0);
  onResizeRef.current = onResize;
  var resizeObserverRef = (0, import_react2.useRef)();
  var _useState = (0, import_react2.useState)({
    width: void 0,
    height: void 0
  }), size = _useState[0], setSize = _useState[1];
  var didUnmount = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(function() {
    return function() {
      didUnmount.current = true;
    };
  }, []);
  var previous = (0, import_react2.useRef)({
    width: void 0,
    height: void 0
  });
  var refCallback = useResolvedElement(function(element) {
    if (!resizeObserverRef.current) {
      resizeObserverRef.current = new ResizeObserver(function(entries) {
        if (!Array.isArray(entries)) {
          return;
        }
        var entry = entries[0];
        var newWidth = Math.round(entry.contentRect.width);
        var newHeight = Math.round(entry.contentRect.height);
        if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          if (onResizeRef.current) {
            onResizeRef.current(newSize);
          } else {
            previous.current.width = newWidth;
            previous.current.height = newHeight;
            if (!didUnmount.current) {
              setSize(newSize);
            }
          }
        }
      });
    }
    resizeObserverRef.current.observe(element);
    return function() {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.unobserve(element);
      }
    };
  }, opts.ref);
  return (0, import_react2.useMemo)(function() {
    return {
      ref: refCallback,
      width: size.width,
      height: size.height
    };
  }, [refCallback, size ? size.width : null, size ? size.height : null]);
}
var bundle_esm_default = useResizeObserver;

// node_modules/miew-react/dist/index.modern.js
init_emotion_react_browser_development_esm();
var import_lodash2 = __toESM(require_lodash());

// node_modules/@redux-saga/symbols/dist/redux-saga-symbols.esm.js
var createSymbol = function createSymbol2(name2) {
  return "@@redux-saga/" + name2;
};
var CANCEL = createSymbol("CANCEL_PROMISE");
var CHANNEL_END_TYPE = createSymbol("CHANNEL_END");
var IO = createSymbol("IO");
var MATCH = createSymbol("MATCH");
var MULTICAST = createSymbol("MULTICAST");
var SAGA_ACTION = createSymbol("SAGA_ACTION");
var SELF_CANCELLATION = createSymbol("SELF_CANCELLATION");
var TASK = createSymbol("TASK");
var TASK_CANCEL = createSymbol("TASK_CANCEL");
var TERMINATE = createSymbol("TERMINATE");
var SAGA_LOCATION = createSymbol("LOCATION");

// node_modules/@redux-saga/core/dist/redux-saga-core.development.esm.js
init_extends();

// node_modules/@redux-saga/is/dist/redux-saga-is.esm.js
var undef = function undef2(v2) {
  return v2 === null || v2 === void 0;
};
var notUndef = function notUndef2(v2) {
  return v2 !== null && v2 !== void 0;
};
var func = function func2(f2) {
  return typeof f2 === "function";
};
var string = function string2(s2) {
  return typeof s2 === "string";
};
var array = Array.isArray;
var object2 = function object3(obj) {
  return obj && !array(obj) && typeof obj === "object";
};
var promise = function promise2(p2) {
  return p2 && func(p2.then);
};
var iterator = function iterator2(it) {
  return it && func(it.next) && func(it.throw);
};
var buffer = function buffer2(buf) {
  return buf && func(buf.isEmpty) && func(buf.take) && func(buf.put);
};
var _pattern = function pattern(pat) {
  return pat && (string(pat) || symbol(pat) || func(pat) || array(pat) && pat.every(_pattern));
};
var channel = function channel2(ch) {
  return ch && func(ch.take) && func(ch.close);
};
var stringableFunc = function stringableFunc2(f2) {
  return func(f2) && f2.hasOwnProperty("toString");
};
var symbol = function symbol2(sym) {
  return Boolean(sym) && typeof Symbol === "function" && sym.constructor === Symbol && sym !== Symbol.prototype;
};
var multicast = function multicast2(ch) {
  return channel(ch) && ch[MULTICAST];
};
var effect = function effect2(eff) {
  return eff && eff[IO];
};

// node_modules/@redux-saga/core/dist/io-e3db6b7a.development.esm.js
init_extends();

// node_modules/@redux-saga/delay-p/dist/redux-saga-delay-p.development.esm.js
var MAX_SIGNED_INT = 2147483647;
function delayP(ms, val) {
  if (val === void 0) {
    val = true;
  }
  if (ms > MAX_SIGNED_INT) {
    throw new Error("delay only supports a maximum value of " + MAX_SIGNED_INT + "ms");
  }
  var timeoutId;
  var promise4 = new Promise(function(resolve) {
    timeoutId = setTimeout(resolve, Math.min(MAX_SIGNED_INT, ms), val);
  });
  promise4[CANCEL] = function() {
    clearTimeout(timeoutId);
  };
  return promise4;
}

// node_modules/@redux-saga/core/dist/io-e3db6b7a.development.esm.js
var konst = function konst2(v2) {
  return function() {
    return v2;
  };
};
var kTrue = konst(true);
var noop = function noop2() {
};
if (typeof Proxy !== "undefined") {
  noop = new Proxy(noop, {
    set: function set3() {
      throw internalErr("There was an attempt to assign a property to internal `noop` function.");
    }
  });
}
var identity = function identity2(v2) {
  return v2;
};
var hasSymbol = typeof Symbol === "function";
var asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator ? Symbol.asyncIterator : "@@asyncIterator";
function check(value, predicate3, error) {
  if (!predicate3(value)) {
    throw new Error(error);
  }
}
var assignWithSymbols = function assignWithSymbols2(target, source) {
  _extends(target, source);
  if (Object.getOwnPropertySymbols) {
    Object.getOwnPropertySymbols(source).forEach(function(s2) {
      target[s2] = source[s2];
    });
  }
};
var flatMap = function flatMap2(mapper, arr) {
  var _ref;
  return (_ref = []).concat.apply(_ref, arr.map(mapper));
};
function remove2(array4, item) {
  var index = array4.indexOf(item);
  if (index >= 0) {
    array4.splice(index, 1);
  }
}
function once(fn2) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    fn2();
  };
}
var kThrow = function kThrow2(err) {
  throw err;
};
var kReturn = function kReturn2(value) {
  return {
    value,
    done: true
  };
};
function makeIterator(next, thro, name2) {
  if (thro === void 0) {
    thro = kThrow;
  }
  if (name2 === void 0) {
    name2 = "iterator";
  }
  var iterator3 = {
    meta: {
      name: name2
    },
    next,
    throw: thro,
    return: kReturn,
    isSagaIterator: true
  };
  if (typeof Symbol !== "undefined") {
    iterator3[Symbol.iterator] = function() {
      return iterator3;
    };
  }
  return iterator3;
}
function logError(error, _ref2) {
  var sagaStack2 = _ref2.sagaStack;
  console.error(error);
  console.error(sagaStack2);
}
var internalErr = function internalErr2(err) {
  return new Error("\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\n  Error: " + err + "\n");
};
var createSetContextWarning = function createSetContextWarning2(ctx, props) {
  return (ctx ? ctx + "." : "") + "setContext(props): argument " + props + " is not a plain object";
};
var FROZEN_ACTION_ERROR = "You can't put (a.k.a. dispatch from saga) frozen actions.\nWe have to define a special non-enumerable property on those actions for scheduling purposes.\nOtherwise you wouldn't be able to communicate properly between sagas & other subscribers (action ordering would become far less predictable).\nIf you are using redux and you care about this behaviour (frozen actions),\nthen you might want to switch to freezing actions in a middleware rather than in action creator.\nExample implementation:\n\nconst freezeActions = store => next => action => next(Object.freeze(action))\n";
var createEmptyArray = function createEmptyArray2(n2) {
  return Array.apply(null, new Array(n2));
};
var wrapSagaDispatch = function wrapSagaDispatch2(dispatch) {
  return function(action) {
    {
      check(action, function(ac) {
        return !Object.isFrozen(ac);
      }, FROZEN_ACTION_ERROR);
    }
    return dispatch(Object.defineProperty(action, SAGA_ACTION, {
      value: true
    }));
  };
};
var shouldTerminate = function shouldTerminate2(res) {
  return res === TERMINATE;
};
var shouldCancel = function shouldCancel2(res) {
  return res === TASK_CANCEL;
};
var shouldComplete = function shouldComplete2(res) {
  return shouldTerminate(res) || shouldCancel(res);
};
function createAllStyleChildCallbacks(shape, parentCallback) {
  var keys2 = Object.keys(shape);
  var totalCount = keys2.length;
  {
    check(totalCount, function(c2) {
      return c2 > 0;
    }, "createAllStyleChildCallbacks: get an empty array or object");
  }
  var completedCount = 0;
  var completed2;
  var results = array(shape) ? createEmptyArray(totalCount) : {};
  var childCallbacks = {};
  function checkEnd() {
    if (completedCount === totalCount) {
      completed2 = true;
      parentCallback(results);
    }
  }
  keys2.forEach(function(key) {
    var chCbAtKey = function chCbAtKey2(res, isErr) {
      if (completed2) {
        return;
      }
      if (isErr || shouldComplete(res)) {
        parentCallback.cancel();
        parentCallback(res, isErr);
      } else {
        results[key] = res;
        completedCount++;
        checkEnd();
      }
    };
    chCbAtKey.cancel = noop;
    childCallbacks[key] = chCbAtKey;
  });
  parentCallback.cancel = function() {
    if (!completed2) {
      completed2 = true;
      keys2.forEach(function(key) {
        return childCallbacks[key].cancel();
      });
    }
  };
  return childCallbacks;
}
function getMetaInfo(fn2) {
  return {
    name: fn2.name || "anonymous",
    location: getLocation(fn2)
  };
}
function getLocation(instrumented) {
  return instrumented[SAGA_LOCATION];
}
function compose2() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
var BUFFER_OVERFLOW = "Channel's Buffer overflow!";
var ON_OVERFLOW_THROW = 1;
var ON_OVERFLOW_DROP = 2;
var ON_OVERFLOW_SLIDE = 3;
var ON_OVERFLOW_EXPAND = 4;
var zeroBuffer = {
  isEmpty: kTrue,
  put: noop,
  take: noop
};
function ringBuffer(limit, overflowAction) {
  if (limit === void 0) {
    limit = 10;
  }
  var arr = new Array(limit);
  var length = 0;
  var pushIndex = 0;
  var popIndex = 0;
  var push = function push2(it) {
    arr[pushIndex] = it;
    pushIndex = (pushIndex + 1) % limit;
    length++;
  };
  var take2 = function take3() {
    if (length != 0) {
      var it = arr[popIndex];
      arr[popIndex] = null;
      length--;
      popIndex = (popIndex + 1) % limit;
      return it;
    }
  };
  var flush3 = function flush4() {
    var items = [];
    while (length) {
      items.push(take2());
    }
    return items;
  };
  return {
    isEmpty: function isEmpty2() {
      return length == 0;
    },
    put: function put2(it) {
      if (length < limit) {
        push(it);
      } else {
        var doubledLimit;
        switch (overflowAction) {
          case ON_OVERFLOW_THROW:
            throw new Error(BUFFER_OVERFLOW);
          case ON_OVERFLOW_SLIDE:
            arr[pushIndex] = it;
            pushIndex = (pushIndex + 1) % limit;
            popIndex = pushIndex;
            break;
          case ON_OVERFLOW_EXPAND:
            doubledLimit = 2 * limit;
            arr = flush3();
            length = arr.length;
            pushIndex = arr.length;
            popIndex = 0;
            arr.length = doubledLimit;
            limit = doubledLimit;
            push(it);
            break;
        }
      }
    },
    take: take2,
    flush: flush3
  };
}
var none3 = function none4() {
  return zeroBuffer;
};
var fixed = function fixed2(limit) {
  return ringBuffer(limit, ON_OVERFLOW_THROW);
};
var dropping = function dropping2(limit) {
  return ringBuffer(limit, ON_OVERFLOW_DROP);
};
var sliding = function sliding2(limit) {
  return ringBuffer(limit, ON_OVERFLOW_SLIDE);
};
var expanding = function expanding2(initialSize) {
  return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
};
var buffers = Object.freeze({
  __proto__: null,
  none: none3,
  fixed,
  dropping,
  sliding,
  expanding
});
var TAKE = "TAKE";
var PUT = "PUT";
var ALL = "ALL";
var RACE = "RACE";
var CALL = "CALL";
var CPS = "CPS";
var FORK = "FORK";
var JOIN = "JOIN";
var CANCEL2 = "CANCEL";
var SELECT = "SELECT";
var ACTION_CHANNEL = "ACTION_CHANNEL";
var CANCELLED = "CANCELLED";
var FLUSH = "FLUSH";
var GET_CONTEXT = "GET_CONTEXT";
var SET_CONTEXT = "SET_CONTEXT";
var effectTypes = Object.freeze({
  __proto__: null,
  TAKE,
  PUT,
  ALL,
  RACE,
  CALL,
  CPS,
  FORK,
  JOIN,
  CANCEL: CANCEL2,
  SELECT,
  ACTION_CHANNEL,
  CANCELLED,
  FLUSH,
  GET_CONTEXT,
  SET_CONTEXT
});
var makeEffect = function makeEffect2(type, payload) {
  var _ref;
  return _ref = {}, _ref[IO] = true, _ref.combinator = false, _ref.type = type, _ref.payload = payload, _ref;
};
var isForkEffect = function isForkEffect2(eff) {
  return effect(eff) && eff.type === FORK;
};
var detach = function detach2(eff) {
  {
    check(eff, isForkEffect, "detach(eff): argument must be a fork effect");
  }
  return makeEffect(FORK, _extends({}, eff.payload, {
    detached: true
  }));
};
function take(patternOrChannel, multicastPattern) {
  if (patternOrChannel === void 0) {
    patternOrChannel = "*";
  }
  if (arguments.length) {
    check(arguments[0], notUndef, "take(patternOrChannel): patternOrChannel is undefined");
  }
  if (_pattern(patternOrChannel)) {
    if (notUndef(multicastPattern)) {
      console.warn("take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types");
    }
    return makeEffect(TAKE, {
      pattern: patternOrChannel
    });
  }
  if (multicast(patternOrChannel) && notUndef(multicastPattern) && _pattern(multicastPattern)) {
    return makeEffect(TAKE, {
      channel: patternOrChannel,
      pattern: multicastPattern
    });
  }
  if (channel(patternOrChannel)) {
    if (notUndef(multicastPattern)) {
      console.warn("take(channel) takes one argument but two were provided. Second argument is ignored.");
    }
    return makeEffect(TAKE, {
      channel: patternOrChannel
    });
  }
  {
    throw new Error("take(patternOrChannel): argument " + patternOrChannel + " is not valid channel or a valid pattern");
  }
}
function put(channel4, action) {
  {
    if (arguments.length > 1) {
      check(channel4, notUndef, "put(channel, action): argument channel is undefined");
      check(channel4, channel, "put(channel, action): argument " + channel4 + " is not a valid channel");
      check(action, notUndef, "put(channel, action): argument action is undefined");
    } else {
      check(channel4, notUndef, "put(action): argument action is undefined");
    }
  }
  if (undef(action)) {
    action = channel4;
    channel4 = void 0;
  }
  return makeEffect(PUT, {
    channel: channel4,
    action
  });
}
var validateFnDescriptor = function validateFnDescriptor2(effectName, fnDescriptor) {
  check(fnDescriptor, notUndef, effectName + ": argument fn is undefined or null");
  if (func(fnDescriptor)) {
    return;
  }
  var context = null;
  var fn2;
  if (array(fnDescriptor)) {
    context = fnDescriptor[0];
    fn2 = fnDescriptor[1];
    check(fn2, notUndef, effectName + ": argument of type [context, fn] has undefined or null `fn`");
  } else if (object2(fnDescriptor)) {
    context = fnDescriptor.context;
    fn2 = fnDescriptor.fn;
    check(fn2, notUndef, effectName + ": argument of type {context, fn} has undefined or null `fn`");
  } else {
    check(fnDescriptor, func, effectName + ": argument fn is not function");
    return;
  }
  if (context && string(fn2)) {
    check(context[fn2], func, effectName + ': context arguments has no such method - "' + fn2 + '"');
    return;
  }
  check(fn2, func, effectName + ": unpacked fn argument (from [context, fn] or {context, fn}) is not a function");
};
function getFnCallDescriptor(fnDescriptor, args) {
  var context = null;
  var fn2;
  if (func(fnDescriptor)) {
    fn2 = fnDescriptor;
  } else {
    if (array(fnDescriptor)) {
      context = fnDescriptor[0];
      fn2 = fnDescriptor[1];
    } else {
      context = fnDescriptor.context;
      fn2 = fnDescriptor.fn;
    }
    if (context && string(fn2) && func(context[fn2])) {
      fn2 = context[fn2];
    }
  }
  return {
    context,
    fn: fn2,
    args
  };
}
var isNotDelayEffect = function isNotDelayEffect2(fn2) {
  return fn2 !== delay;
};
function call(fnDescriptor) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  {
    var arg0 = typeof args[0] === "number" ? args[0] : "ms";
    check(fnDescriptor, isNotDelayEffect, "instead of writing `yield call(delay, " + arg0 + ")` where delay is an effect from `redux-saga/effects` you should write `yield delay(" + arg0 + ")`");
    validateFnDescriptor("call", fnDescriptor);
  }
  return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));
}
function fork(fnDescriptor) {
  {
    validateFnDescriptor("fork", fnDescriptor);
    check(fnDescriptor, function(arg) {
      return !effect(arg);
    }, "fork: argument must not be an effect");
  }
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));
}
function spawn(fnDescriptor) {
  {
    validateFnDescriptor("spawn", fnDescriptor);
  }
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  return detach(fork.apply(void 0, [fnDescriptor].concat(args)));
}
var delay = call.bind(null, delayP);

// node_modules/@redux-saga/deferred/dist/redux-saga-deferred.esm.js
function deferred() {
  var def = {};
  def.promise = new Promise(function(resolve, reject) {
    def.resolve = resolve;
    def.reject = reject;
  });
  return def;
}

// node_modules/@redux-saga/core/dist/redux-saga-core.development.esm.js
var queue = [];
var semaphore = 0;
function exec(task2) {
  try {
    suspend();
    task2();
  } finally {
    release();
  }
}
function asap(task2) {
  queue.push(task2);
  if (!semaphore) {
    suspend();
    flush();
  }
}
function immediately(task2) {
  try {
    suspend();
    return task2();
  } finally {
    flush();
  }
}
function suspend() {
  semaphore++;
}
function release() {
  semaphore--;
}
function flush() {
  release();
  var task2;
  while (!semaphore && (task2 = queue.shift()) !== void 0) {
    exec(task2);
  }
}
var array2 = function array3(patterns) {
  return function(input) {
    return patterns.some(function(p2) {
      return matcher(p2)(input);
    });
  };
};
var predicate = function predicate2(_predicate) {
  return function(input) {
    return _predicate(input);
  };
};
var string3 = function string4(pattern2) {
  return function(input) {
    return input.type === String(pattern2);
  };
};
var symbol3 = function symbol4(pattern2) {
  return function(input) {
    return input.type === pattern2;
  };
};
var wildcard = function wildcard2() {
  return kTrue;
};
function matcher(pattern2) {
  var matcherCreator = pattern2 === "*" ? wildcard : string(pattern2) ? string3 : array(pattern2) ? array2 : stringableFunc(pattern2) ? string3 : func(pattern2) ? predicate : symbol(pattern2) ? symbol3 : null;
  if (matcherCreator === null) {
    throw new Error("invalid pattern: " + pattern2);
  }
  return matcherCreator(pattern2);
}
var END = {
  type: CHANNEL_END_TYPE
};
var isEnd = function isEnd2(a2) {
  return a2 && a2.type === CHANNEL_END_TYPE;
};
var CLOSED_CHANNEL_WITH_TAKERS = "Cannot have a closed channel with pending takers";
var INVALID_BUFFER = "invalid buffer passed to channel factory function";
var UNDEFINED_INPUT_ERROR = "Saga or channel was provided with an undefined action\nHints:\n  - check that your Action Creator returns a non-undefined value\n  - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners";
function channel3(buffer3) {
  if (buffer3 === void 0) {
    buffer3 = expanding();
  }
  var closed = false;
  var takers = [];
  {
    check(buffer3, buffer, INVALID_BUFFER);
  }
  function checkForbiddenStates() {
    if (closed && takers.length) {
      throw internalErr(CLOSED_CHANNEL_WITH_TAKERS);
    }
    if (takers.length && !buffer3.isEmpty()) {
      throw internalErr("Cannot have pending takers with non empty buffer");
    }
  }
  function put2(input) {
    {
      checkForbiddenStates();
      check(input, notUndef, UNDEFINED_INPUT_ERROR);
    }
    if (closed) {
      return;
    }
    if (takers.length === 0) {
      return buffer3.put(input);
    }
    var cb = takers.shift();
    cb(input);
  }
  function take2(cb) {
    {
      checkForbiddenStates();
      check(cb, func, "channel.take's callback must be a function");
    }
    if (closed && buffer3.isEmpty()) {
      cb(END);
    } else if (!buffer3.isEmpty()) {
      cb(buffer3.take());
    } else {
      takers.push(cb);
      cb.cancel = function() {
        remove2(takers, cb);
      };
    }
  }
  function flush3(cb) {
    {
      checkForbiddenStates();
      check(cb, func, "channel.flush' callback must be a function");
    }
    if (closed && buffer3.isEmpty()) {
      cb(END);
      return;
    }
    cb(buffer3.flush());
  }
  function close() {
    {
      checkForbiddenStates();
    }
    if (closed) {
      return;
    }
    closed = true;
    var arr = takers;
    takers = [];
    for (var i2 = 0, len = arr.length; i2 < len; i2++) {
      var taker = arr[i2];
      taker(END);
    }
  }
  return {
    take: take2,
    put: put2,
    flush: flush3,
    close
  };
}
function multicastChannel() {
  var _ref;
  var closed = false;
  var currentTakers = [];
  var nextTakers = currentTakers;
  function checkForbiddenStates() {
    if (closed && nextTakers.length) {
      throw internalErr(CLOSED_CHANNEL_WITH_TAKERS);
    }
  }
  var ensureCanMutateNextTakers = function ensureCanMutateNextTakers2() {
    if (nextTakers !== currentTakers) {
      return;
    }
    nextTakers = currentTakers.slice();
  };
  var close = function close2() {
    {
      checkForbiddenStates();
    }
    closed = true;
    var takers = currentTakers = nextTakers;
    nextTakers = [];
    takers.forEach(function(taker) {
      taker(END);
    });
  };
  return _ref = {}, _ref[MULTICAST] = true, _ref.put = function put2(input) {
    {
      checkForbiddenStates();
      check(input, notUndef, UNDEFINED_INPUT_ERROR);
    }
    if (closed) {
      return;
    }
    if (isEnd(input)) {
      close();
      return;
    }
    var takers = currentTakers = nextTakers;
    for (var i2 = 0, len = takers.length; i2 < len; i2++) {
      var taker = takers[i2];
      if (taker[MATCH](input)) {
        taker.cancel();
        taker(input);
      }
    }
  }, _ref.take = function take2(cb, matcher2) {
    if (matcher2 === void 0) {
      matcher2 = wildcard;
    }
    {
      checkForbiddenStates();
    }
    if (closed) {
      cb(END);
      return;
    }
    cb[MATCH] = matcher2;
    ensureCanMutateNextTakers();
    nextTakers.push(cb);
    cb.cancel = once(function() {
      ensureCanMutateNextTakers();
      remove2(nextTakers, cb);
    });
  }, _ref.close = close, _ref;
}
function stdChannel() {
  var chan = multicastChannel();
  var put2 = chan.put;
  chan.put = function(input) {
    if (input[SAGA_ACTION]) {
      put2(input);
      return;
    }
    asap(function() {
      put2(input);
    });
  };
  return chan;
}
var RUNNING = 0;
var CANCELLED2 = 1;
var ABORTED = 2;
var DONE = 3;
function resolvePromise(promise4, cb) {
  var cancelPromise = promise4[CANCEL];
  if (func(cancelPromise)) {
    cb.cancel = cancelPromise;
  }
  promise4.then(cb, function(error) {
    cb(error, true);
  });
}
var current = 0;
var nextSagaId = function() {
  return ++current;
};
var _effectRunnerMap;
function getIteratorMetaInfo(iterator3, fn2) {
  if (iterator3.isSagaIterator) {
    return {
      name: iterator3.meta.name
    };
  }
  return getMetaInfo(fn2);
}
function createTaskIterator(_ref) {
  var context = _ref.context, fn2 = _ref.fn, args = _ref.args;
  try {
    var result = fn2.apply(context, args);
    if (iterator(result)) {
      return result;
    }
    var resolved = false;
    var next = function next2(arg) {
      if (!resolved) {
        resolved = true;
        return {
          value: result,
          done: !promise(result)
        };
      } else {
        return {
          value: arg,
          done: true
        };
      }
    };
    return makeIterator(next);
  } catch (err) {
    return makeIterator(function() {
      throw err;
    });
  }
}
function runPutEffect(env, _ref2, cb) {
  var channel4 = _ref2.channel, action = _ref2.action, resolve = _ref2.resolve;
  asap(function() {
    var result;
    try {
      result = (channel4 ? channel4.put : env.dispatch)(action);
    } catch (error) {
      cb(error, true);
      return;
    }
    if (resolve && promise(result)) {
      resolvePromise(result, cb);
    } else {
      cb(result);
    }
  });
}
function runTakeEffect(env, _ref3, cb) {
  var _ref3$channel = _ref3.channel, channel4 = _ref3$channel === void 0 ? env.channel : _ref3$channel, pattern2 = _ref3.pattern, maybe = _ref3.maybe;
  var takeCb = function takeCb2(input) {
    if (input instanceof Error) {
      cb(input, true);
      return;
    }
    if (isEnd(input) && !maybe) {
      cb(TERMINATE);
      return;
    }
    cb(input);
  };
  try {
    channel4.take(takeCb, notUndef(pattern2) ? matcher(pattern2) : null);
  } catch (err) {
    cb(err, true);
    return;
  }
  cb.cancel = takeCb.cancel;
}
function runCallEffect(env, _ref4, cb, _ref5) {
  var context = _ref4.context, fn2 = _ref4.fn, args = _ref4.args;
  var task2 = _ref5.task;
  try {
    var result = fn2.apply(context, args);
    if (promise(result)) {
      resolvePromise(result, cb);
      return;
    }
    if (iterator(result)) {
      proc(
        env,
        result,
        task2.context,
        current,
        getMetaInfo(fn2),
        /* isRoot */
        false,
        cb
      );
      return;
    }
    cb(result);
  } catch (error) {
    cb(error, true);
  }
}
function runCPSEffect(env, _ref6, cb) {
  var context = _ref6.context, fn2 = _ref6.fn, args = _ref6.args;
  try {
    var cpsCb = function cpsCb2(err, res) {
      if (undef(err)) {
        cb(res);
      } else {
        cb(err, true);
      }
    };
    fn2.apply(context, args.concat(cpsCb));
    if (cpsCb.cancel) {
      cb.cancel = cpsCb.cancel;
    }
  } catch (error) {
    cb(error, true);
  }
}
function runForkEffect(env, _ref7, cb, _ref8) {
  var context = _ref7.context, fn2 = _ref7.fn, args = _ref7.args, detached = _ref7.detached;
  var parent = _ref8.task;
  var taskIterator = createTaskIterator({
    context,
    fn: fn2,
    args
  });
  var meta = getIteratorMetaInfo(taskIterator, fn2);
  immediately(function() {
    var child = proc(env, taskIterator, parent.context, current, meta, detached, void 0);
    if (detached) {
      cb(child);
    } else {
      if (child.isRunning()) {
        parent.queue.addTask(child);
        cb(child);
      } else if (child.isAborted()) {
        parent.queue.abort(child.error());
      } else {
        cb(child);
      }
    }
  });
}
function runJoinEffect(env, taskOrTasks, cb, _ref9) {
  var task2 = _ref9.task;
  var joinSingleTask = function joinSingleTask2(taskToJoin, cb2) {
    if (taskToJoin.isRunning()) {
      var joiner = {
        task: task2,
        cb: cb2
      };
      cb2.cancel = function() {
        if (taskToJoin.isRunning()) remove2(taskToJoin.joiners, joiner);
      };
      taskToJoin.joiners.push(joiner);
    } else {
      if (taskToJoin.isAborted()) {
        cb2(taskToJoin.error(), true);
      } else {
        cb2(taskToJoin.result());
      }
    }
  };
  if (array(taskOrTasks)) {
    if (taskOrTasks.length === 0) {
      cb([]);
      return;
    }
    var childCallbacks = createAllStyleChildCallbacks(taskOrTasks, cb);
    taskOrTasks.forEach(function(t2, i2) {
      joinSingleTask(t2, childCallbacks[i2]);
    });
  } else {
    joinSingleTask(taskOrTasks, cb);
  }
}
function cancelSingleTask(taskToCancel) {
  if (taskToCancel.isRunning()) {
    taskToCancel.cancel();
  }
}
function runCancelEffect(env, taskOrTasks, cb, _ref0) {
  var task2 = _ref0.task;
  if (taskOrTasks === SELF_CANCELLATION) {
    cancelSingleTask(task2);
  } else if (array(taskOrTasks)) {
    taskOrTasks.forEach(cancelSingleTask);
  } else {
    cancelSingleTask(taskOrTasks);
  }
  cb();
}
function runAllEffect(env, effects, cb, _ref1) {
  var digestEffect = _ref1.digestEffect;
  var effectId = current;
  var keys2 = Object.keys(effects);
  if (keys2.length === 0) {
    cb(array(effects) ? [] : {});
    return;
  }
  var childCallbacks = createAllStyleChildCallbacks(effects, cb);
  keys2.forEach(function(key) {
    digestEffect(effects[key], effectId, childCallbacks[key], key);
  });
}
function runRaceEffect(env, effects, cb, _ref10) {
  var digestEffect = _ref10.digestEffect;
  var effectId = current;
  var keys2 = Object.keys(effects);
  var response = array(effects) ? createEmptyArray(keys2.length) : {};
  var childCbs = {};
  var completed2 = false;
  keys2.forEach(function(key) {
    var chCbAtKey = function chCbAtKey2(res, isErr) {
      if (completed2) {
        return;
      }
      if (isErr || shouldComplete(res)) {
        cb.cancel();
        cb(res, isErr);
      } else {
        cb.cancel();
        completed2 = true;
        response[key] = res;
        cb(response);
      }
    };
    chCbAtKey.cancel = noop;
    childCbs[key] = chCbAtKey;
  });
  cb.cancel = function() {
    if (!completed2) {
      completed2 = true;
      keys2.forEach(function(key) {
        return childCbs[key].cancel();
      });
    }
  };
  keys2.forEach(function(key) {
    if (completed2) {
      return;
    }
    digestEffect(effects[key], effectId, childCbs[key], key);
  });
}
function runSelectEffect(env, _ref11, cb) {
  var selector = _ref11.selector, args = _ref11.args;
  try {
    var state = selector.apply(void 0, [env.getState()].concat(args));
    cb(state);
  } catch (error) {
    cb(error, true);
  }
}
function runChannelEffect(env, _ref12, cb) {
  var pattern2 = _ref12.pattern, buffer3 = _ref12.buffer;
  var chan = channel3(buffer3);
  var match = matcher(pattern2);
  var _taker = function taker(action) {
    if (!isEnd(action)) {
      env.channel.take(_taker, match);
    }
    chan.put(action);
  };
  var close = chan.close;
  chan.close = function() {
    _taker.cancel();
    close();
  };
  env.channel.take(_taker, match);
  cb(chan);
}
function runCancelledEffect(env, data, cb, _ref13) {
  var task2 = _ref13.task;
  cb(task2.isCancelled());
}
function runFlushEffect(env, channel4, cb) {
  channel4.flush(cb);
}
function runGetContextEffect(env, prop, cb, _ref14) {
  var task2 = _ref14.task;
  cb(task2.context[prop]);
}
function runSetContextEffect(env, props, cb, _ref15) {
  var task2 = _ref15.task;
  assignWithSymbols(task2.context, props);
  cb();
}
var effectRunnerMap = (_effectRunnerMap = {}, _effectRunnerMap[TAKE] = runTakeEffect, _effectRunnerMap[PUT] = runPutEffect, _effectRunnerMap[ALL] = runAllEffect, _effectRunnerMap[RACE] = runRaceEffect, _effectRunnerMap[CALL] = runCallEffect, _effectRunnerMap[CPS] = runCPSEffect, _effectRunnerMap[FORK] = runForkEffect, _effectRunnerMap[JOIN] = runJoinEffect, _effectRunnerMap[CANCEL2] = runCancelEffect, _effectRunnerMap[SELECT] = runSelectEffect, _effectRunnerMap[ACTION_CHANNEL] = runChannelEffect, _effectRunnerMap[CANCELLED] = runCancelledEffect, _effectRunnerMap[FLUSH] = runFlushEffect, _effectRunnerMap[GET_CONTEXT] = runGetContextEffect, _effectRunnerMap[SET_CONTEXT] = runSetContextEffect, _effectRunnerMap);
function forkQueue(mainTask, onAbort, cont) {
  var tasks = [];
  var result;
  var completed2 = false;
  addTask(mainTask);
  var getTasks = function getTasks2() {
    return tasks;
  };
  function abort(err) {
    onAbort();
    cancelAll();
    cont(err, true);
  }
  function addTask(task2) {
    tasks.push(task2);
    task2.cont = function(res, isErr) {
      if (completed2) {
        return;
      }
      remove2(tasks, task2);
      task2.cont = noop;
      if (isErr) {
        abort(res);
      } else {
        if (task2 === mainTask) {
          result = res;
        }
        if (!tasks.length) {
          completed2 = true;
          cont(result);
        }
      }
    };
  }
  function cancelAll() {
    if (completed2) {
      return;
    }
    completed2 = true;
    tasks.forEach(function(t2) {
      t2.cont = noop;
      t2.cancel();
    });
    tasks = [];
  }
  return {
    addTask,
    cancelAll,
    abort,
    getTasks
  };
}
function formatLocation(fileName, lineNumber) {
  return fileName + "?" + lineNumber;
}
function effectLocationAsString(effect3) {
  var location = getLocation(effect3);
  if (location) {
    var code = location.code, fileName = location.fileName, lineNumber = location.lineNumber;
    var source = code + "  " + formatLocation(fileName, lineNumber);
    return source;
  }
  return "";
}
function sagaLocationAsString(sagaMeta) {
  var name2 = sagaMeta.name, location = sagaMeta.location;
  if (location) {
    return name2 + "  " + formatLocation(location.fileName, location.lineNumber);
  }
  return name2;
}
function cancelledTasksAsString(sagaStack2) {
  var cancelledTasks = flatMap(function(i2) {
    return i2.cancelledTasks;
  }, sagaStack2);
  if (!cancelledTasks.length) {
    return "";
  }
  return ["Tasks cancelled due to error:"].concat(cancelledTasks).join("\n");
}
var crashedEffect = null;
var sagaStack = [];
var addSagaFrame = function addSagaFrame2(frame) {
  frame.crashedEffect = crashedEffect;
  sagaStack.push(frame);
};
var clear = function clear2() {
  crashedEffect = null;
  sagaStack.length = 0;
};
var setCrashedEffect = function setCrashedEffect2(effect3) {
  crashedEffect = effect3;
};
var toString = function toString2() {
  var firstSaga = sagaStack[0], otherSagas = sagaStack.slice(1);
  var crashedEffectLocation = firstSaga.crashedEffect ? effectLocationAsString(firstSaga.crashedEffect) : null;
  var errorMessage = "The above error occurred in task " + sagaLocationAsString(firstSaga.meta) + (crashedEffectLocation ? " \n when executing effect " + crashedEffectLocation : "");
  return [errorMessage].concat(otherSagas.map(function(s2) {
    return "    created by " + sagaLocationAsString(s2.meta);
  }), [cancelledTasksAsString(sagaStack)]).join("\n");
};
function newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont) {
  var _task;
  if (cont === void 0) {
    cont = noop;
  }
  var status = RUNNING;
  var taskResult;
  var taskError;
  var deferredEnd = null;
  var cancelledDueToErrorTasks = [];
  var context = Object.create(parentContext);
  var queue2 = forkQueue(mainTask, function onAbort() {
    cancelledDueToErrorTasks.push.apply(cancelledDueToErrorTasks, queue2.getTasks().map(function(t2) {
      return t2.meta.name;
    }));
  }, end);
  function cancel2() {
    if (status === RUNNING) {
      status = CANCELLED2;
      queue2.cancelAll();
      end(TASK_CANCEL, false);
    }
  }
  function end(result, isErr) {
    if (!isErr) {
      if (result === TASK_CANCEL) {
        status = CANCELLED2;
      } else if (status !== CANCELLED2) {
        status = DONE;
      }
      taskResult = result;
      deferredEnd && deferredEnd.resolve(result);
    } else {
      status = ABORTED;
      addSagaFrame({
        meta,
        cancelledTasks: cancelledDueToErrorTasks
      });
      if (task2.isRoot) {
        var sagaStack2 = toString();
        clear();
        env.onError(result, {
          sagaStack: sagaStack2
        });
      }
      taskError = result;
      deferredEnd && deferredEnd.reject(result);
    }
    task2.cont(result, isErr);
    task2.joiners.forEach(function(joiner) {
      joiner.cb(result, isErr);
    });
    task2.joiners = null;
  }
  function setContext2(props) {
    {
      check(props, object2, createSetContextWarning("task", props));
    }
    assignWithSymbols(context, props);
  }
  function toPromise() {
    if (deferredEnd) {
      return deferredEnd.promise;
    }
    deferredEnd = deferred();
    if (status === ABORTED) {
      deferredEnd.reject(taskError);
    } else if (status !== RUNNING) {
      deferredEnd.resolve(taskResult);
    }
    return deferredEnd.promise;
  }
  var task2 = (_task = {}, _task[TASK] = true, _task.id = parentEffectId, _task.meta = meta, _task.isRoot = isRoot, _task.context = context, _task.joiners = [], _task.queue = queue2, _task.cancel = cancel2, _task.cont = cont, _task.end = end, _task.setContext = setContext2, _task.toPromise = toPromise, _task.isRunning = function isRunning() {
    return status === RUNNING;
  }, _task.isCancelled = function isCancelled() {
    return status === CANCELLED2 || status === RUNNING && mainTask.status === CANCELLED2;
  }, _task.isAborted = function isAborted() {
    return status === ABORTED;
  }, _task.result = function result() {
    return taskResult;
  }, _task.error = function error() {
    return taskError;
  }, _task);
  return task2;
}
function proc(env, iterator3, parentContext, parentEffectId, meta, isRoot, cont) {
  if (iterator3[asyncIteratorSymbol]) {
    throw new Error("redux-saga doesn't support async generators, please use only regular ones");
  }
  var finalRunEffect = env.finalizeRunEffect(runEffect);
  next.cancel = noop;
  var mainTask = {
    meta,
    cancel: cancelMain,
    status: RUNNING
  };
  var task2 = newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont);
  var executingContext = {
    task: task2,
    digestEffect
  };
  function cancelMain() {
    if (mainTask.status === RUNNING) {
      mainTask.status = CANCELLED2;
      next(TASK_CANCEL);
    }
  }
  if (cont) {
    cont.cancel = task2.cancel;
  }
  next();
  return task2;
  function next(arg, isErr) {
    try {
      var result;
      if (isErr) {
        result = iterator3.throw(arg);
        clear();
      } else if (shouldCancel(arg)) {
        mainTask.status = CANCELLED2;
        next.cancel();
        result = func(iterator3.return) ? iterator3.return(TASK_CANCEL) : {
          done: true,
          value: TASK_CANCEL
        };
      } else if (shouldTerminate(arg)) {
        result = func(iterator3.return) ? iterator3.return() : {
          done: true
        };
      } else {
        result = iterator3.next(arg);
      }
      if (!result.done) {
        digestEffect(result.value, parentEffectId, next);
      } else {
        if (mainTask.status !== CANCELLED2) {
          mainTask.status = DONE;
        }
        mainTask.cont(result.value);
      }
    } catch (error) {
      if (mainTask.status === CANCELLED2) {
        throw error;
      }
      mainTask.status = ABORTED;
      mainTask.cont(error, true);
    }
  }
  function runEffect(effect3, effectId, currCb) {
    if (promise(effect3)) {
      resolvePromise(effect3, currCb);
    } else if (iterator(effect3)) {
      proc(
        env,
        effect3,
        task2.context,
        effectId,
        meta,
        /* isRoot */
        false,
        currCb
      );
    } else if (effect3 && effect3[IO]) {
      var effectRunner = effectRunnerMap[effect3.type];
      effectRunner(env, effect3.payload, currCb, executingContext);
    } else {
      currCb(effect3);
    }
  }
  function digestEffect(effect3, parentEffectId2, cb, label) {
    if (label === void 0) {
      label = "";
    }
    var effectId = nextSagaId();
    env.sagaMonitor && env.sagaMonitor.effectTriggered({
      effectId,
      parentEffectId: parentEffectId2,
      label,
      effect: effect3
    });
    var effectSettled;
    function currCb(res, isErr) {
      if (effectSettled) {
        return;
      }
      effectSettled = true;
      cb.cancel = noop;
      if (env.sagaMonitor) {
        if (isErr) {
          env.sagaMonitor.effectRejected(effectId, res);
        } else {
          env.sagaMonitor.effectResolved(effectId, res);
        }
      }
      if (isErr) {
        setCrashedEffect(effect3);
      }
      cb(res, isErr);
    }
    currCb.cancel = noop;
    cb.cancel = function() {
      if (effectSettled) {
        return;
      }
      effectSettled = true;
      currCb.cancel();
      currCb.cancel = noop;
      env.sagaMonitor && env.sagaMonitor.effectCancelled(effectId);
    };
    finalRunEffect(effect3, effectId, currCb);
  }
}
var RUN_SAGA_SIGNATURE = "runSaga(options, saga, ...args)";
var NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + ": saga argument must be a Generator function!";
function runSaga(_ref, saga) {
  var _ref$channel = _ref.channel, channel4 = _ref$channel === void 0 ? stdChannel() : _ref$channel, dispatch = _ref.dispatch, getState = _ref.getState, _ref$context = _ref.context, context = _ref$context === void 0 ? {} : _ref$context, sagaMonitor = _ref.sagaMonitor, effectMiddlewares = _ref.effectMiddlewares, _ref$onError = _ref.onError, onError = _ref$onError === void 0 ? logError : _ref$onError;
  {
    check(saga, func, NON_GENERATOR_ERR);
  }
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var iterator3 = saga.apply(void 0, args);
  {
    check(iterator3, iterator, NON_GENERATOR_ERR);
  }
  var effectId = nextSagaId();
  if (sagaMonitor) {
    sagaMonitor.rootSagaStarted = sagaMonitor.rootSagaStarted || noop;
    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || noop;
    sagaMonitor.effectResolved = sagaMonitor.effectResolved || noop;
    sagaMonitor.effectRejected = sagaMonitor.effectRejected || noop;
    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || noop;
    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || noop;
    sagaMonitor.rootSagaStarted({
      effectId,
      saga,
      args
    });
  }
  {
    if (notUndef(dispatch)) {
      check(dispatch, func, "dispatch must be a function");
    }
    if (notUndef(getState)) {
      check(getState, func, "getState must be a function");
    }
    if (notUndef(effectMiddlewares)) {
      var MIDDLEWARE_TYPE_ERROR = "effectMiddlewares must be an array of functions";
      check(effectMiddlewares, array, MIDDLEWARE_TYPE_ERROR);
      effectMiddlewares.forEach(function(effectMiddleware) {
        return check(effectMiddleware, func, MIDDLEWARE_TYPE_ERROR);
      });
    }
    check(onError, func, "onError passed to the redux-saga is not a function!");
  }
  var finalizeRunEffect;
  if (effectMiddlewares) {
    var middleware2 = compose2.apply(void 0, effectMiddlewares);
    finalizeRunEffect = function finalizeRunEffect2(runEffect) {
      return function(effect3, effectId2, currCb) {
        var plainRunEffect = function plainRunEffect2(eff) {
          return runEffect(eff, effectId2, currCb);
        };
        return middleware2(plainRunEffect)(effect3);
      };
    };
  } else {
    finalizeRunEffect = identity;
  }
  var env = {
    channel: channel4,
    dispatch: wrapSagaDispatch(dispatch),
    getState,
    sagaMonitor,
    onError,
    finalizeRunEffect
  };
  return immediately(function() {
    var task2 = proc(
      env,
      iterator3,
      context,
      effectId,
      getMetaInfo(saga),
      /* isRoot */
      true,
      void 0
    );
    if (sagaMonitor) {
      sagaMonitor.effectResolved(effectId, task2);
    }
    return task2;
  });
}
var _excluded = ["context", "channel", "sagaMonitor"];
function sagaMiddlewareFactory(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$context = _ref.context, context = _ref$context === void 0 ? {} : _ref$context, _ref$channel = _ref.channel, channel4 = _ref$channel === void 0 ? stdChannel() : _ref$channel, sagaMonitor = _ref.sagaMonitor, options2 = _objectWithoutPropertiesLoose(_ref, _excluded);
  var boundRunSaga;
  {
    check(channel4, channel, "options.channel passed to the Saga middleware is not a channel");
  }
  function sagaMiddleware2(_ref2) {
    var getState = _ref2.getState, dispatch = _ref2.dispatch;
    boundRunSaga = runSaga.bind(null, _extends({}, options2, {
      context,
      channel: channel4,
      dispatch,
      getState,
      sagaMonitor
    }));
    return function(next) {
      return function(action) {
        if (sagaMonitor && sagaMonitor.actionDispatched) {
          sagaMonitor.actionDispatched(action);
        }
        var result = next(action);
        channel4.put(action);
        return result;
      };
    };
  }
  sagaMiddleware2.run = function() {
    if (!boundRunSaga) {
      throw new Error("Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware");
    }
    return boundRunSaga.apply(void 0, arguments);
  };
  sagaMiddleware2.setContext = function(props) {
    {
      check(props, object2, createSetContextWarning("sagaMiddleware", props));
    }
    assignWithSymbols(context, props);
  };
  return sagaMiddleware2;
}

// node_modules/immer/dist/immer.esm.mjs
function n(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++) t2[e2 - 1] = arguments[e2];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? "function" == typeof i2 ? i2.apply(null, t2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  var r2;
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3) return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3) return true;
    var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L]) || s(n2) || v(n2));
}
function i(n2, r2, t2) {
  void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
    t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
  }) : n2.forEach(function(t3, e2) {
    return r2(e2, t3, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return 2 === o(n2) ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t2) {
  var e2 = o(n2);
  2 === e2 ? n2.set(r2, t2) : 3 === e2 ? n2.add(t2) : n2[r2] = t2;
}
function c(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2)) return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
    var i2 = t2[e2], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e2) {
  return void 0 === e2 && (e2 = false), y(n2) || r(n2) || !t(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e2 && i(n2, function(n3, r2) {
    return d(r2, true);
  }, true)), n2;
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(r2) {
  var t2 = tn[r2];
  return t2 || n(18, r2), t2;
}
function m(n2, r2) {
  tn[n2] || (tn[n2] = r2);
}
function _() {
  return U || n(0), U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function g(n2) {
  O(n2), n2.p.forEach(S), n2.p = null;
}
function O(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
}
function P(r2, e2) {
  e2._ = e2.p.length;
  var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e2.h.O || b("ES5").S(e2, r2, o2), o2 ? (i2[Q].P && (g(e2), n(4)), t(r2) && (r2 = M(e2, r2), e2.l || x(e2, r2)), e2.u && b("Patches").M(i2[Q].t, r2, e2.u, e2.s)) : r2 = M(e2, i2, []), g(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t2) {
  if (y(r2)) return r2;
  var e2 = r2[Q];
  if (!e2) return i(r2, function(i2, o3) {
    return A(n2, e2, r2, i2, o3, t2);
  }, true), r2;
  if (e2.A !== n2) return r2;
  if (!e2.P) return x(n2, e2.t, true), e2.t;
  if (!e2.I) {
    e2.I = true, e2.A._--;
    var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l(e2.k) : e2.o, u2 = o2, a2 = false;
    3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, function(r3, i2) {
      return A(n2, e2, o2, r3, i2, t2, a2);
    }), x(n2, o2, false), t2 && n2.u && b("Patches").N(e2, t2, n2.u, n2.s);
  }
  return e2.o;
}
function A(e2, i2, o2, a2, c2, s2, v2) {
  if (c2 === o2 && n(5), r(c2)) {
    var p2 = M(e2, c2, s2 && i2 && 3 !== i2.i && !u(i2.R, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, p2), !r(p2)) return;
    e2.m = false;
  } else v2 && o2.add(c2);
  if (t(c2) && !y(c2)) {
    if (!e2.h.D && e2._ < 1) return;
    M(e2, c2), i2 && i2.A.l || x(e2, c2);
  }
}
function x(n2, r2, t2) {
  void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d(r2, t2);
}
function z(n2, r2) {
  var t2 = n2[Q];
  return (t2 ? p(t2) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2) for (var t2 = Object.getPrototypeOf(n2); t2; ) {
    var e2 = Object.getOwnPropertyDescriptor(t2, r2);
    if (e2) return e2;
    t2 = Object.getPrototypeOf(t2);
  }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function N(n2, r2, t2) {
  var e2 = s(r2) ? b("MapSet").F(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
    var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en;
    t3 && (i2 = [e3], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e3.k = f2, e3.j = a2, f2;
  }(r2, t2) : b("ES5").J(r2, t2);
  return (t2 ? t2.A : _()).p.push(e2), e2;
}
function R(e2) {
  return r(e2) || n(22, e2), function n2(r2) {
    if (!t(r2)) return r2;
    var e3, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2))) return u2.t;
      u2.I = true, e3 = D(r2, c2), u2.I = false;
    } else e3 = D(r2, c2);
    return i(e3, function(r3, t2) {
      u2 && a(u2.t, r3) === t2 || f(e3, r3, n2(t2));
    }), 3 === c2 ? new Set(e3) : e3;
  }(e2);
}
function D(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
function F() {
  function t2(n2, r2) {
    var t3 = s2[n2];
    return t3 ? t3.enumerable = r2 : s2[n2] = t3 = { configurable: true, enumerable: r2, get: function() {
      var r3 = this[Q];
      return f2(r3), en.get(r3, n2);
    }, set: function(r3) {
      var t4 = this[Q];
      f2(t4), en.set(t4, n2, r3);
    } }, t3;
  }
  function e2(n2) {
    for (var r2 = n2.length - 1; r2 >= 0; r2--) {
      var t3 = n2[r2][Q];
      if (!t3.P) switch (t3.i) {
        case 5:
          a2(t3) && k(t3);
          break;
        case 4:
          o2(t3) && k(t3);
      }
    }
  }
  function o2(n2) {
    for (var r2 = n2.t, t3 = n2.k, e3 = nn(t3), i2 = e3.length - 1; i2 >= 0; i2--) {
      var o3 = e3[i2];
      if (o3 !== Q) {
        var a3 = r2[o3];
        if (void 0 === a3 && !u(r2, o3)) return true;
        var f3 = t3[o3], s3 = f3 && f3[Q];
        if (s3 ? s3.t !== a3 : !c(f3, a3)) return true;
      }
    }
    var v2 = !!r2[Q];
    return e3.length !== nn(r2).length + (v2 ? 0 : 1);
  }
  function a2(n2) {
    var r2 = n2.k;
    if (r2.length !== n2.t.length) return true;
    var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
    if (t3 && !t3.get) return true;
    for (var e3 = 0; e3 < r2.length; e3++) if (!r2.hasOwnProperty(e3)) return true;
    return false;
  }
  function f2(r2) {
    r2.g && n(3, JSON.stringify(p(r2)));
  }
  var s2 = {};
  m("ES5", { J: function(n2, r2) {
    var e3 = Array.isArray(n2), i2 = function(n3, r3) {
      if (n3) {
        for (var e4 = Array(r3.length), i3 = 0; i3 < r3.length; i3++) Object.defineProperty(e4, "" + i3, t2(i3, true));
        return e4;
      }
      var o4 = rn(r3);
      delete o4[Q];
      for (var u2 = nn(o4), a3 = 0; a3 < u2.length; a3++) {
        var f3 = u2[a3];
        o4[f3] = t2(f3, n3 || !!o4[f3].enumerable);
      }
      return Object.create(Object.getPrototypeOf(r3), o4);
    }(e3, n2), o3 = { i: e3 ? 5 : 4, A: r2 ? r2.A : _(), P: false, I: false, R: {}, l: r2, t: n2, k: i2, o: null, g: false, C: false };
    return Object.defineProperty(i2, Q, { value: o3, writable: true }), i2;
  }, S: function(n2, t3, o3) {
    o3 ? r(t3) && t3[Q].A === n2 && e2(n2.p) : (n2.u && function n3(r2) {
      if (r2 && "object" == typeof r2) {
        var t4 = r2[Q];
        if (t4) {
          var e3 = t4.t, o4 = t4.k, f3 = t4.R, c2 = t4.i;
          if (4 === c2) i(o4, function(r3) {
            r3 !== Q && (void 0 !== e3[r3] || u(e3, r3) ? f3[r3] || n3(o4[r3]) : (f3[r3] = true, k(t4)));
          }), i(e3, function(n4) {
            void 0 !== o4[n4] || u(o4, n4) || (f3[n4] = false, k(t4));
          });
          else if (5 === c2) {
            if (a2(t4) && (k(t4), f3.length = true), o4.length < e3.length) for (var s3 = o4.length; s3 < e3.length; s3++) f3[s3] = false;
            else for (var v2 = e3.length; v2 < o4.length; v2++) f3[v2] = true;
            for (var p2 = Math.min(o4.length, e3.length), l2 = 0; l2 < p2; l2++) o4.hasOwnProperty(l2) || (f3[l2] = true), void 0 === f3[l2] && n3(o4[l2]);
          }
        }
      }
    }(n2.p[0]), e2(n2.p));
  }, K: function(n2) {
    return 4 === n2.i ? o2(n2) : a2(n2);
  } });
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  }), r2;
};
var tn = {};
var en = { get: function(n2, r2) {
  if (r2 === Q) return n2;
  var e2 = p(n2);
  if (!u(e2, r2)) return function(n3, r3, t2) {
    var e3, i3 = I(r3, t2);
    return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
  }(n2, e2, r2);
  var i2 = e2[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t2) {
  var e2 = I(p(n2), r2);
  if (null == e2 ? void 0 : e2.set) return e2.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
    if (o2 && o2.t === t2) return n2.o[r2] = t2, n2.R[r2] = false, true;
    if (c(t2, i2) && (void 0 !== t2 || u(n2.t, r2))) return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
}, deleteProperty: function(n2, r2) {
  return void 0 !== z(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t2) {
  return isNaN(parseInt(t2)) && n(13), on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e2) {
  return "length" !== t2 && isNaN(parseInt(t2)) && n(14), en.set.call(this, r2[0], t2, e2, r2[0]);
};
var un = function() {
  function e2(r2) {
    var e3 = this;
    this.O = B, this.D = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e3;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++) e4[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
        var c2 = w(e3), s2 = N(e3, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? g(c2) : O(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw g(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e3.D && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2) return function(r4) {
        for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++) i4[o3 - 1] = arguments[o3];
        return e3.produceWithPatches(r4, function(r5) {
          return n2.apply(void 0, [r5].concat(i4));
        });
      };
      var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
        t2 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t2, i3];
      }) : [o2, t2, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e2.prototype;
  return i2.createDraft = function(e3) {
    t(e3) || n(8), r(e3) && (e3 = R(e3));
    var i3 = w(this), o2 = N(this, e3, void 0);
    return o2[Q].C = true, O(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e3 = r2 && r2[Q];
    e3 && e3.C || n(9), e3.I && n(10);
    var i3 = e3.A;
    return j(i3, t2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.D = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.O = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e3;
    for (e3 = t2.length - 1; e3 >= 0; e3--) {
      var i3 = t2[e3];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e3 > -1 && (t2 = t2.slice(e3 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
      return o2(n3, t2);
    });
  }, e2;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn;

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray = function(to, from) {
  for (var i2 = 0, il = from.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from[i2];
  return to;
};
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function(obj, key, value) {
  return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues = function(a2, b2) {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var _i = 0, _c = __getOwnPropSymbols(b2); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = function(a2, b2) {
  return __defProps(a2, __getOwnPropDescs(b2));
};
var __async = function(__this, __arguments, generator) {
  return new Promise(function(resolve, reject) {
    var fulfilled = function(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = function(value) {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = function(x2) {
      return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose;
  return compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop22) {
    return noop22;
  };
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  var baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
var hasMatchFunction = function(v2) {
  return v2 && typeof v2.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type, payload: args[0] };
  }
  actionCreator.toString = function() {
    return "" + type;
  };
  actionCreator.type = type;
  actionCreator.match = function(action) {
    return action.type === type;
  };
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && hasMatchFunction(action);
}
function getMessage(type) {
  var splitType = type ? ("" + type).split("/") : [];
  var actionName = splitType[splitType.length - 1] || "actionCreator";
  return 'Detected an action creator with type "' + (type || "unknown") + "\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. `dispatch(" + actionName + "())` instead of `dispatch(" + actionName + ")`. This is necessary even if the action has no payload.";
}
function createActionCreatorInvariantMiddleware(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (false) {
    return function() {
      return function(next) {
        return function(action) {
          return next(action);
        };
      };
    };
  }
  var _c = options2.isActionCreator, isActionCreator2 = _c === void 0 ? isActionCreator : _c;
  return function() {
    return function(next) {
      return function(action) {
        if (isActionCreator2(action)) {
          console.warn(getMessage(action.type));
        }
        return next(action);
      };
    };
  };
}
function getTimeMeasureUtils(maxDelay, fnName) {
  var elapsed = 0;
  return {
    measureTime: function(fn2) {
      var started = Date.now();
      try {
        return fn2();
      } finally {
        var finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded: function() {
      if (elapsed > maxDelay) {
        console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
      }
    }
  };
}
var MiddlewareArray = (
  /** @class */
  function(_super) {
    __extends(MiddlewareArray2, _super);
    function MiddlewareArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
      return _this;
    }
    Object.defineProperty(MiddlewareArray2, Symbol.species, {
      get: function() {
        return MiddlewareArray2;
      },
      enumerable: false,
      configurable: true
    });
    MiddlewareArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr[0].concat(this))))();
      }
      return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr.concat(this))))();
    };
    return MiddlewareArray2;
  }(Array)
);
var EnhancerArray = (
  /** @class */
  function(_super) {
    __extends(EnhancerArray2, _super);
    function EnhancerArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, EnhancerArray2.prototype);
      return _this;
    }
    Object.defineProperty(EnhancerArray2, Symbol.species, {
      get: function() {
        return EnhancerArray2;
      },
      enumerable: false,
      configurable: true
    });
    EnhancerArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    EnhancerArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr[0].concat(this))))();
      }
      return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr.concat(this))))();
    };
    return EnhancerArray2;
  }(Array)
);
function freezeDraftable(val) {
  return t(val) ? immer_esm_default(val, function() {
  }) : val;
}
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  throw new Error(prefix + ": " + (message || ""));
}
function stringify(obj, serializer, indent, decycler) {
  return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}
function getSerialize(serializer, decycler) {
  var stack = [], keys2 = [];
  if (!decycler)
    decycler = function(_2, value) {
      if (stack[0] === value)
        return "[Circular ~]";
      return "[Circular ~." + keys2.slice(0, stack.indexOf(value)).join(".") + "]";
    };
  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys2.splice(thisPos, Infinity, key) : keys2.push(key);
      if (~stack.indexOf(value))
        value = decycler.call(this, key, value);
    } else
      stack.push(value);
    return serializer == null ? value : serializer.call(this, key, value);
  };
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations: function() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths, obj, path, checkedObjects) {
  if (ignorePaths === void 0) {
    ignorePaths = [];
  }
  if (path === void 0) {
    path = "";
  }
  if (checkedObjects === void 0) {
    checkedObjects = /* @__PURE__ */ new Set();
  }
  var tracked = { value: obj };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (var key in obj) {
      var childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths, trackedProperty, obj, sameParentRef, path) {
  if (ignoredPaths === void 0) {
    ignoredPaths = [];
  }
  if (sameParentRef === void 0) {
    sameParentRef = false;
  }
  if (path === void 0) {
    path = "";
  }
  var prevObj = trackedProperty ? trackedProperty.value : void 0;
  var sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return { wasMutated: true, path };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return { wasMutated: false };
  }
  var keysToDetect = {};
  for (var key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (var key in obj) {
    keysToDetect[key] = true;
  }
  var hasIgnoredPaths = ignoredPaths.length > 0;
  var _loop_1 = function(key2) {
    var nestedPath = path ? path + "." + key2 : key2;
    if (hasIgnoredPaths) {
      var hasMatches = ignoredPaths.some(function(ignored) {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        return "continue";
      }
    }
    var result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key2], obj[key2], sameRef, nestedPath);
    if (result.wasMutated) {
      return { value: result };
    }
  };
  for (var key in keysToDetect) {
    var state_1 = _loop_1(key);
    if (typeof state_1 === "object")
      return state_1.value;
  }
  return { wasMutated: false };
}
function createImmutableStateInvariantMiddleware(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (false) {
    return function() {
      return function(next) {
        return function(action) {
          return next(action);
        };
      };
    };
  }
  var _c = options2.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options2.ignoredPaths, _d = options2.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options2.ignore;
  ignoredPaths = ignoredPaths || ignore;
  var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
  return function(_c2) {
    var getState = _c2.getState;
    var state = getState();
    var tracker = track(state);
    var result;
    return function(next) {
      return function(action) {
        var measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(function() {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          invariant(!result.wasMutated, "A state mutation was detected between dispatches, in the path '" + (result.path || "") + "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
        });
        var dispatchedAction = next(action);
        measureUtils.measureTime(function() {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          result.wasMutated && invariant(!result.wasMutated, "A state mutation was detected inside a dispatch, in the path: " + (result.path || "") + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  };
}
function isPlain(val) {
  var type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject2(val);
}
function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths, cache) {
  if (path === void 0) {
    path = "";
  }
  if (isSerializable === void 0) {
    isSerializable = isPlain;
  }
  if (ignoredPaths === void 0) {
    ignoredPaths = [];
  }
  var foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache == null ? void 0 : cache.has(value))
    return false;
  var entries = getEntries != null ? getEntries(value) : Object.entries(value);
  var hasIgnoredPaths = ignoredPaths.length > 0;
  var _loop_2 = function(key2, nestedValue2) {
    var nestedPath = path ? path + "." + key2 : key2;
    if (hasIgnoredPaths) {
      var hasMatches = ignoredPaths.some(function(ignored) {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        return "continue";
      }
    }
    if (!isSerializable(nestedValue2)) {
      return { value: {
        keyPath: nestedPath,
        value: nestedValue2
      } };
    }
    if (typeof nestedValue2 === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue2, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
      if (foundNestedSerializable) {
        return { value: foundNestedSerializable };
      }
    }
  };
  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
    var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];
    var state_2 = _loop_2(key, nestedValue);
    if (typeof state_2 === "object")
      return state_2.value;
  }
  if (cache && isNestedFrozen(value))
    cache.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value))
    return false;
  for (var _i = 0, _c = Object.values(value); _i < _c.length; _i++) {
    var nestedValue = _c[_i];
    if (typeof nestedValue !== "object" || nestedValue === null)
      continue;
    if (!isNestedFrozen(nestedValue))
      return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (false) {
    return function() {
      return function(next) {
        return function(action) {
          return next(action);
        };
      };
    };
  }
  var _c = options2.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options2.getEntries, _d = options2.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options2.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? ["meta.arg", "meta.baseQueryMeta"] : _e, _f = options2.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options2.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options2.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options2.ignoreActions, ignoreActions = _j === void 0 ? false : _j, _k = options2.disableCache, disableCache = _k === void 0 ? false : _k;
  var cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
  return function(storeAPI) {
    return function(next) {
      return function(action) {
        var result = next(action);
        var measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
        if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
          measureUtils.measureTime(function() {
            var foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache);
            if (foundActionNonSerializableValue) {
              var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;
              console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
            }
          });
        }
        if (!ignoreState) {
          measureUtils.measureTime(function() {
            var state = storeAPI.getState();
            var foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache);
            if (foundStateNonSerializableValue) {
              var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;
              console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
            }
          });
          measureUtils.warnIfExceeded();
        }
        return result;
      };
    };
  };
}
function isBoolean2(x2) {
  return typeof x2 === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options2) {
    return getDefaultMiddleware(options2);
  };
}
function getDefaultMiddleware(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _c = options2.thunk, thunk = _c === void 0 ? true : _c, _d = options2.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options2.serializableCheck, serializableCheck = _e === void 0 ? true : _e, _f = options2.actionCreatorCheck, actionCreatorCheck = _f === void 0 ? true : _f;
  var middlewareArray = new MiddlewareArray();
  if (thunk) {
    if (isBoolean2(thunk)) {
      middlewareArray.push(es_default);
    } else {
      middlewareArray.push(es_default.withExtraArgument(thunk.extraArgument));
    }
  }
  if (true) {
    if (immutableCheck) {
      var immutableOptions = {};
      if (!isBoolean2(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      var serializableOptions = {};
      if (!isBoolean2(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
    if (actionCreatorCheck) {
      var actionCreatorOptions = {};
      if (!isBoolean2(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
    }
  }
  return middlewareArray;
}
var IS_PRODUCTION = false;
function configureStore(options2) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  var _c = options2 || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware2 = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
  var rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject2(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  var finalMiddleware = middleware2;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
      throw new Error("when using a middleware builder function, an array of middleware must be returned");
    }
  }
  if (!IS_PRODUCTION && finalMiddleware.some(function(item) {
    return typeof item !== "function";
  })) {
    throw new Error("each middleware provided to configureStore must be a function");
  }
  var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
  var finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  var defaultEnhancers = new EnhancerArray(middlewareEnhancer);
  var storeEnhancers = defaultEnhancers;
  if (Array.isArray(enhancers)) {
    storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(defaultEnhancers);
  }
  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function(typeOrActionCreator, reducer) {
      if (true) {
        if (actionMatchers.length > 0) {
          throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error("`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error("`builder.addCase` cannot be called with two reducers for the same action type");
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher: function(matcher2, reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({ matcher: matcher2, reducer });
      return builder;
    },
    addDefaultCase: function(reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error("`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
var hasWarnedAboutObjectNotation = false;
function createReducer(initialState2, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }
  if (true) {
    if (typeof mapOrBuilderCallback === "object") {
      if (!hasWarnedAboutObjectNotation) {
        hasWarnedAboutObjectNotation = true;
        console.warn("The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
      }
    }
  }
  var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
  var getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = function() {
      return freezeDraftable(initialState2());
    };
  } else {
    var frozenInitialState_1 = freezeDraftable(initialState2);
    getInitialState = function() {
      return frozenInitialState_1;
    };
  }
  function reducer(state, action) {
    if (state === void 0) {
      state = getInitialState();
    }
    var caseReducers = __spreadArray([
      actionsMap[action.type]
    ], finalActionMatchers.filter(function(_c2) {
      var matcher2 = _c2.matcher;
      return matcher2(action);
    }).map(function(_c2) {
      var reducer2 = _c2.reducer;
      return reducer2;
    }));
    if (caseReducers.filter(function(cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce(function(previousState, caseReducer) {
      if (caseReducer) {
        if (r(previousState)) {
          var draft = previousState;
          var result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!t(previousState)) {
          var result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return immer_esm_default(previousState, function(draft2) {
            return caseReducer(draft2, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
var hasWarnedAboutObjectNotation2 = false;
function getType2(slice2, actionKey) {
  return slice2 + "/" + actionKey;
}
function createSlice(options2) {
  var name2 = options2.name;
  if (!name2) {
    throw new Error("`name` is a required option for createSlice");
  }
  if (typeof process !== "undefined" && true) {
    if (options2.initialState === void 0) {
      console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    }
  }
  var initialState2 = typeof options2.initialState == "function" ? options2.initialState : freezeDraftable(options2.initialState);
  var reducers = options2.reducers || {};
  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function(reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type = getType2(name2, reducerName);
    var caseReducer;
    var prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
  });
  function buildReducer() {
    if (true) {
      if (typeof options2.extraReducers === "object") {
        if (!hasWarnedAboutObjectNotation2) {
          hasWarnedAboutObjectNotation2 = true;
          console.warn("The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
        }
      }
    }
    var _c = typeof options2.extraReducers === "function" ? executeReducerBuilderCallback(options2.extraReducers) : [options2.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
    var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState2, function(builder) {
      for (var key in finalCaseReducers) {
        builder.addCase(key, finalCaseReducers[key]);
      }
      for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
        var m2 = actionMatchers_1[_i];
        builder.addMatcher(m2.matcher, m2.reducer);
      }
      if (defaultCaseReducer) {
        builder.addDefaultCase(defaultCaseReducer);
      }
    });
  }
  var _reducer;
  return {
    name: name2,
    reducer: function(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState: function() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function(size) {
  if (size === void 0) {
    size = 21;
  }
  var id = "";
  var i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var commonProperties = [
  "name",
  "message",
  "stack",
  "code"
];
var RejectWithValue = (
  /** @class */
  /* @__PURE__ */ function() {
    function RejectWithValue2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return RejectWithValue2;
  }()
);
var FulfillWithMeta = (
  /** @class */
  /* @__PURE__ */ function() {
    function FulfillWithMeta2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return FulfillWithMeta2;
  }()
);
var miniSerializeError = function(value) {
  if (typeof value === "object" && value !== null) {
    var simpleError = {};
    for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
      var property = commonProperties_1[_i];
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return { message: String(value) };
};
var createAsyncThunk = function() {
  function createAsyncThunk2(typePrefix, payloadCreator, options2) {
    var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
      return {
        payload,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "fulfilled"
        })
      };
    });
    var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
      return {
        payload: void 0,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "pending"
        })
      };
    });
    var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
      return {
        payload,
        error: (options2 && options2.serializeError || miniSerializeError)(error || "Rejected"),
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          rejectedWithValue: !!payload,
          requestStatus: "rejected",
          aborted: (error == null ? void 0 : error.name) === "AbortError",
          condition: (error == null ? void 0 : error.name) === "ConditionError"
        })
      };
    });
    var displayedWarning = false;
    var AC = typeof AbortController !== "undefined" ? AbortController : (
      /** @class */
      function() {
        function class_1() {
          this.signal = {
            aborted: false,
            addEventListener: function() {
            },
            dispatchEvent: function() {
              return false;
            },
            onabort: function() {
            },
            removeEventListener: function() {
            },
            reason: void 0,
            throwIfAborted: function() {
            }
          };
        }
        class_1.prototype.abort = function() {
          if (true) {
            if (!displayedWarning) {
              displayedWarning = true;
              console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.");
            }
          }
        };
        return class_1;
      }()
    );
    function actionCreator(arg) {
      return function(dispatch, getState, extra) {
        var requestId = (options2 == null ? void 0 : options2.idGenerator) ? options2.idGenerator(arg) : nanoid();
        var abortController = new AC();
        var abortReason;
        var started = false;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        var promise22 = function() {
          return __async(this, null, function() {
            var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _c.trys.push([0, 4, , 5]);
                  conditionResult = (_a = options2 == null ? void 0 : options2.condition) == null ? void 0 : _a.call(options2, arg, { getState, extra });
                  if (!isThenable(conditionResult)) return [3, 2];
                  return [4, conditionResult];
                case 1:
                  conditionResult = _c.sent();
                  _c.label = 2;
                case 2:
                  if (conditionResult === false || abortController.signal.aborted) {
                    throw {
                      name: "ConditionError",
                      message: "Aborted due to condition callback returning false."
                    };
                  }
                  started = true;
                  abortedPromise = new Promise(function(_2, reject) {
                    return abortController.signal.addEventListener("abort", function() {
                      return reject({
                        name: "AbortError",
                        message: abortReason || "Aborted"
                      });
                    });
                  });
                  dispatch(pending(requestId, arg, (_b = options2 == null ? void 0 : options2.getPendingMeta) == null ? void 0 : _b.call(options2, { requestId, arg }, { getState, extra })));
                  return [4, Promise.race([
                    abortedPromise,
                    Promise.resolve(payloadCreator(arg, {
                      dispatch,
                      getState,
                      extra,
                      requestId,
                      signal: abortController.signal,
                      abort,
                      rejectWithValue: function(value, meta) {
                        return new RejectWithValue(value, meta);
                      },
                      fulfillWithValue: function(value, meta) {
                        return new FulfillWithMeta(value, meta);
                      }
                    })).then(function(result) {
                      if (result instanceof RejectWithValue) {
                        throw result;
                      }
                      if (result instanceof FulfillWithMeta) {
                        return fulfilled(result.payload, requestId, arg, result.meta);
                      }
                      return fulfilled(result, requestId, arg);
                    })
                  ])];
                case 3:
                  finalAction = _c.sent();
                  return [3, 5];
                case 4:
                  err_1 = _c.sent();
                  finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                  return [3, 5];
                case 5:
                  skipDispatch = options2 && !options2.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                  if (!skipDispatch) {
                    dispatch(finalAction);
                  }
                  return [2, finalAction];
              }
            });
          });
        }();
        return Object.assign(promise22, {
          abort,
          requestId,
          arg,
          unwrap: function() {
            return promise22.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = function() {
    return createAsyncThunk2;
  };
  return createAsyncThunk2;
}();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = "task-" + cancelled;
var taskCompleted = "task-" + completed;
var listenerCancelled = listener + "-" + cancelled;
var listenerCompleted = listener + "-" + completed;
var alm = "listenerMiddleware";
var addListener = createAction(alm + "/add");
var clearAllListeners = createAction(alm + "/removeAll");
var removeListener = createAction(alm + "/remove");
var promise3;
var queueMicrotaskShim = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb) {
  return (promise3 || (promise3 = Promise.resolve())).then(cb).catch(function(err) {
    return setTimeout(function() {
      throw err;
    }, 0);
  });
};
var createQueueWithTimer = function(timeout) {
  return function(notify) {
    setTimeout(notify, timeout);
  };
};
var rAF = typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);
F();

// node_modules/miew-react/dist/index.modern.js
var import_regenerator = __toESM(require_regenerator());

// node_modules/@redux-saga/core/effects/dist/redux-saga-core-effects.development.esm.js
init_extends();
var done = function done2(value) {
  return {
    done: true,
    value
  };
};
var qEnd = {};
function safeName(patternOrChannel) {
  if (channel(patternOrChannel)) {
    return "channel";
  }
  if (stringableFunc(patternOrChannel)) {
    return String(patternOrChannel);
  }
  if (func(patternOrChannel)) {
    return patternOrChannel.name;
  }
  return String(patternOrChannel);
}
function fsmIterator(fsm, startState, name2) {
  var stateUpdater, errorState, effect3, nextState = startState;
  function next(arg, error) {
    if (nextState === qEnd) {
      return done(arg);
    }
    if (error && !errorState) {
      nextState = qEnd;
      throw error;
    } else {
      stateUpdater && stateUpdater(arg);
      var currentState = error ? fsm[errorState](error) : fsm[nextState]();
      nextState = currentState.nextState;
      effect3 = currentState.effect;
      stateUpdater = currentState.stateUpdater;
      errorState = currentState.errorState;
      return nextState === qEnd ? done(arg) : effect3;
    }
  }
  return makeIterator(next, function(error) {
    return next(null, error);
  }, name2);
}
function takeEvery$1(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var yTake = {
    done: false,
    value: take(patternOrChannel)
  };
  var yFork = function yFork2(ac) {
    return {
      done: false,
      value: fork.apply(void 0, [worker].concat(args, [ac]))
    };
  };
  var action, setAction = function setAction2(ac) {
    return action = ac;
  };
  return fsmIterator({
    q1: function q1() {
      return {
        nextState: "q2",
        effect: yTake,
        stateUpdater: setAction
      };
    },
    q2: function q2() {
      return {
        nextState: "q1",
        effect: yFork(action)
      };
    }
  }, "q1", "takeEvery(" + safeName(patternOrChannel) + ", " + worker.name + ")");
}
var validateTakeEffect = function validateTakeEffect2(fn2, patternOrChannel, worker) {
  check(patternOrChannel, notUndef, fn2.name + " requires a pattern or channel");
  check(worker, notUndef, fn2.name + " requires a saga parameter");
};
function takeEvery(patternOrChannel, worker) {
  {
    validateTakeEffect(takeEvery, patternOrChannel, worker);
  }
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  return fork.apply(void 0, [takeEvery$1, patternOrChannel, worker].concat(args));
}

// node_modules/miew-react/dist/index.modern.js
var initialState = {
  isInitialized: false,
  data: void 0,
  error: void 0
};
var InitSlice = createSlice({
  name: "init",
  initialState,
  reducers: {
    INIT: function INIT(state) {
      state.isInitialized = false;
      state.data = void 0;
      state.error = void 0;
    },
    INIT_SUCCESS: function INIT_SUCCESS(state, action) {
      state.isInitialized = true;
      state.data = action.payload;
      state.error = void 0;
    },
    INIT_FAIL: function INIT_FAIL(state, action) {
      state.isInitialized = false;
      state.data = void 0;
      state.error = action.payload;
    }
  }
});
var _InitSlice$actions = InitSlice.actions;
var INIT2 = _InitSlice$actions.INIT;
var INIT_SUCCESS2 = _InitSlice$actions.INIT_SUCCESS;
var INIT_FAIL2 = _InitSlice$actions.INIT_FAIL;
var initReducer = InitSlice.reducer;
var _marked$1 = import_regenerator.default.mark(initApp);
var _marked2 = import_regenerator.default.mark(watchInitApp);
var fetchInitData = function fetchInitData2(url) {
  return new Promise(function(resolve) {
    return setTimeout(function() {
      return resolve("data fetched from ".concat(url));
    }, 2e3);
  });
};
var TEST_URL = "some/url";
function initApp() {
  var data;
  return import_regenerator.default.wrap(function initApp$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _context2.next = 3;
          return call(fetchInitData, TEST_URL);
        case 3:
          data = _context2.sent;
          _context2.next = 6;
          return put(INIT_SUCCESS2(data));
        case 6:
          _context2.next = 12;
          break;
        case 8:
          _context2.prev = 8;
          _context2.t0 = _context2["catch"](0);
          _context2.next = 12;
          return put(INIT_FAIL2("SAMPLE ERROR"));
        case 12:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked$1, null, [[0, 8]]);
}
function watchInitApp() {
  return import_regenerator.default.wrap(function watchInitApp$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return takeEvery(INIT2, initApp);
        case 2:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
var _marked = import_regenerator.default.mark(rootSaga);
function rootSaga() {
  return import_regenerator.default.wrap(function rootSaga$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return spawn(watchInitApp);
        case 2:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked);
}
var sagaMiddleware = sagaMiddlewareFactory();
var store = configureStore({
  reducer: {
    init: initReducer
  },
  middleware: function middleware(getDefaultMiddleware2) {
    return getDefaultMiddleware2().concat(sagaMiddleware);
  }
});
sagaMiddleware.run(rootSaga);
var defaultTheme = {
  palette: {
    accent: {
      main: "#2E6DA4",
      dark: "#204D74",
      light: "#337AB7"
    },
    primary: {
      main: "#DDD",
      light: "#FFF",
      dark: "#DDD"
    },
    secondary: {
      main: "#333",
      light: "#C0C0C0",
      dark: "#383838"
    }
  },
  typography: {
    fontSize: 16,
    fontFamily: "sans-serif"
  }
};
function ownKeys2(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var MEDIA_SIZES = {
  smallWidth: 800,
  smallHeight: 400
};
var muiTheme = createTheme_default();
var Viewer = function Viewer2(_ref) {
  var onInit = _ref.onInit, options2 = _ref.options, theme = _ref.theme;
  var viewerTheme = theme ? (0, import_lodash2.merge)(defaultTheme, theme) : defaultTheme;
  var ref = (0, import_react3.useRef)(null);
  var _useResizeObserver = bundle_esm_default({
    ref
  }), width = _useResizeObserver.width, height = _useResizeObserver.height;
  var isSizeSmall = height && height <= MEDIA_SIZES.smallHeight || width && width <= MEDIA_SIZES.smallWidth;
  var viewerStyle = function viewerStyle2(theme2) {
    var palette2 = theme2.miew.palette;
    return {
      backgroundColor: isSizeSmall ? palette2.accent.main : palette2.primary.main,
      height: "100%",
      width: "100%",
      "& > .miew-canvas": {
        height: "100%",
        width: "100%"
      }
    };
  };
  (0, import_react3.useLayoutEffect)(function() {
    var miew = new Miew(_objectSpread2({
      container: ref === null || ref === void 0 ? void 0 : ref.current
    }, options2));
    if (miew.init()) miew.run();
    if (typeof onInit === "function") onInit(miew);
  }, [options2, onInit]);
  return jsx2(Provider_default, {
    store,
    children: jsxs2(ThemeProvider, {
      theme: (0, import_lodash2.merge)(muiTheme, {
        miew: viewerTheme
      }),
      children: [jsx2(CssBaseline_default, {}, void 0), jsx2("div", {
        ref,
        css: viewerStyle
      }, void 0)]
    }, void 0)
  }, void 0);
};
export {
  Viewer as default
};
/*! Bundled license information:

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=miew-react.js.map
